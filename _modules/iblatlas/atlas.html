

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>iblatlas.atlas &mdash; IBL Library  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/style.css?v=17142d56" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            IBL Library
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">The Open Neurophysiology Environment</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks_external/one_quickstart.html">ONE Quick Start</a></li>
<li class="toctree-l1"><a class="reference external" href="https://int-brain-lab.github.io/ONE/">Full documentation Website for ONE</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Public</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../public_docs/public_introduction.html">Publicly available IBL data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks_external/data_release_behavior.html">Data Release - Behavior</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../public_docs/data_release_pilot.html">Data Release - Pilot Dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks_external/data_release_repro_ephys.html">Data Release - Reproducible Ephys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks_external/data_release_brainwidemap.html">Data Release - Brain Wide Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks_external/data_release_spikesorting_benchmarks.html">Data Release - Spike sorting benchmark datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../public_docs/information_contact.html">Information and troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exploring IBL Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks_external/data_structure.html">Get to know the datasets and folder structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks_external/data_download.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks_external/data_download.html#Explore-and-download-data-using-the-ONE-api">Explore and download data using the ONE-api</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../loading_examples.html">Loading Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Miscellaneous</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../02_installation.html">Unified Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../09_contribution.html">How to contribute</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples &amp; Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../atlas_examples.html">Atlas Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks_external/docs_wheel_moves.html">Working with wheel data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks_external/docs_wheel_screen_stimulus.html">Computing the stimulus position using the wheel</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../010_api_reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">IBL Library</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">iblatlas.atlas</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for iblatlas.atlas</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes for manipulating brain atlases, insertions, and coordinates.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span><span class="p">,</span> <span class="n">PurePosixPath</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">nrrd</span>

<span class="kn">from</span> <span class="nn">one.webclient</span> <span class="kn">import</span> <span class="n">http_download_file</span>
<span class="kn">import</span> <span class="nn">one.params</span>
<span class="kn">import</span> <span class="nn">one.remote.aws</span> <span class="k">as</span> <span class="nn">aws</span>
<span class="kn">from</span> <span class="nn">iblutil.numerical</span> <span class="kn">import</span> <span class="n">ismember</span>
<span class="kn">from</span> <span class="nn">iblatlas.regions</span> <span class="kn">import</span> <span class="n">BrainRegions</span><span class="p">,</span> <span class="n">FranklinPaxinosRegions</span>

<span class="n">ALLEN_CCF_LANDMARKS_MLAPDV_UM</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bregma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5739</span><span class="p">,</span> <span class="mi">5400</span><span class="p">,</span> <span class="mi">332</span><span class="p">])}</span>
<span class="sd">&quot;&quot;&quot;dict: The ML AP DV voxel coordinates of brain landmarks in the Allen atlas.&quot;&quot;&quot;</span>

<span class="n">PAXINOS_CCF_LANDMARKS_MLAPDV_UM</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bregma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5700</span><span class="p">,</span> <span class="mi">4300</span> <span class="o">+</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">330</span><span class="p">])}</span>
<span class="sd">&quot;&quot;&quot;dict: The ML AP DV voxel coordinates of brain landmarks in the Franklin &amp; Paxinos atlas.&quot;&quot;&quot;</span>

<span class="n">S3_BUCKET_IBL</span> <span class="o">=</span> <span class="s1">&#39;ibl-brain-wide-map-public&#39;</span>
<span class="sd">&quot;&quot;&quot;str: The name of the public IBL S3 bucket containing atlas data.&quot;&quot;&quot;</span>

<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="cart2sph">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.cart2sph">[docs]</a>
<span class="k">def</span> <span class="nf">cart2sph</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts cartesian to spherical coordinates.</span>

<span class="sd">    Returns spherical coordinates (r, theta, phi).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : numpy.array</span>
<span class="sd">        A 1D array of x-axis coordinates.</span>
<span class="sd">    y : numpy.array</span>
<span class="sd">        A 1D array of y-axis coordinates.</span>
<span class="sd">    z : numpy.array</span>
<span class="sd">        A 1D array of z-axis coordinates.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.array</span>
<span class="sd">        The radial distance of each point.</span>
<span class="sd">    numpy.array</span>
<span class="sd">        The polar angle.</span>
<span class="sd">    numpy.array</span>
<span class="sd">        The azimuthal angle.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sph2cart</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">z</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">iok</span> <span class="o">=</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">theta</span><span class="p">[</span><span class="n">iok</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">iok</span><span class="p">]</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="n">iok</span><span class="p">])</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span></div>



<div class="viewcode-block" id="sph2cart">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.sph2cart">[docs]</a>
<span class="k">def</span> <span class="nf">sph2cart</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts Spherical to Cartesian coordinates.</span>

<span class="sd">    Returns Cartesian coordinates (x, y, z).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : numpy.array</span>
<span class="sd">        A 1D array of radial distances.</span>
<span class="sd">    theta : numpy.array</span>
<span class="sd">        A 1D array of polar angles.</span>
<span class="sd">    phi : numpy.array</span>
<span class="sd">        A 1D array of azimuthal angles.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : numpy.array</span>
<span class="sd">        A 1D array of x-axis coordinates.</span>
<span class="sd">    y : numpy.array</span>
<span class="sd">        A 1D array of y-axis coordinates.</span>
<span class="sd">    z : numpy.array</span>
<span class="sd">        A 1D array of z-axis coordinates.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cart2sph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span></div>



<div class="viewcode-block" id="BrainCoordinates">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainCoordinates">[docs]</a>
<span class="k">class</span> <span class="nc">BrainCoordinates</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for mapping and indexing a 3D array to real-world coordinates.</span>

<span class="sd">    * x = ml, right positive</span>
<span class="sd">    * y = ap, anterior positive</span>
<span class="sd">    * z = dv, dorsal positive</span>

<span class="sd">    The layout of the Atlas dimension is done according to the most used sections so they lay</span>
<span class="sd">    contiguous on disk assuming C-ordering: V[iap, iml, idv]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nxyz : array_like</span>
<span class="sd">        Number of elements along each Cartesian axis (nx, ny, nz) = (nml, nap, ndv).</span>
<span class="sd">    xyz0 : array_like</span>
<span class="sd">        Coordinates of the element volume[0, 0, 0] in the coordinate space.</span>
<span class="sd">    dxyz : array_like, float</span>
<span class="sd">        Spatial interval of the volume along the 3 dimensions.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    xyz0 : numpy.array</span>
<span class="sd">        The Cartesian coordinates of the element volume[0, 0, 0], i.e. the origin.</span>
<span class="sd">    x0 : int</span>
<span class="sd">        The x-axis origin coordinate of the element volume.</span>
<span class="sd">    y0 : int</span>
<span class="sd">        The y-axis origin coordinate of the element volume.</span>
<span class="sd">    z0 : int</span>
<span class="sd">        The z-axis origin coordinate of the element volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nxyz</span><span class="p">,</span> <span class="n">xyz0</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dxyz</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dxyz</span><span class="p">):</span>
            <span class="n">dxyz</span> <span class="o">=</span> <span class="p">[</span><span class="n">dxyz</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xyz0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dxyz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nxyz</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dxyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy.array: Spatial interval of the volume along the 3 dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nxyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy.array: Coordinates of the element volume[0, 0, 0] in the coordinate space.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">])</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods distance to indices&quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_round</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Round an input value to the nearest integer, replacing NaN values with 0.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int, float, numpy.nan, numpy.array</span>
<span class="sd">            A value or array of values to round.</span>
<span class="sd">        round : bool</span>
<span class="sd">            If false this function is identity.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int, float, numpy.nan, numpy.array</span>
<span class="sd">            If round is true, returns the nearest integer, replacing NaN values with 0, otherwise</span>
<span class="sd">            returns the input unaffected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nanval</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">round</span><span class="p">:</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">ii</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">nanval</span>
            <span class="k">return</span> <span class="n">ii</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span>

<div class="viewcode-block" id="BrainCoordinates.x2i">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainCoordinates.x2i">[docs]</a>
    <span class="k">def</span> <span class="nf">x2i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the nearest volume image index to a given x-axis coordinate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float, numpy.array</span>
<span class="sd">            One or more x-axis coordinates, relative to the origin, x0.</span>
<span class="sd">        round : bool</span>
<span class="sd">            If true, round to the nearest index, replacing NaN values with 0.</span>
<span class="sd">        mode : {&#39;raise&#39;, &#39;clip&#39;, &#39;wrap&#39;}, default=&#39;raise&#39;</span>
<span class="sd">            How to behave if the coordinate lies outside of the volume: raise (default) will raise</span>
<span class="sd">            a ValueError; &#39;clip&#39; will replace the index with the closest index inside the volume;</span>
<span class="sd">            &#39;wrap&#39; will return the index as is.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            The nearest indices of the image volume along the first dimension.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            At least one x value lies outside of the atlas volume. Change &#39;mode&#39; input to &#39;wrap&#39; to</span>
<span class="sd">            keep these values unchanged, or &#39;clip&#39; to return the nearest valid indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_round</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;clip&#39;</span><span class="p">:</span>
                <span class="n">i</span><span class="p">[</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">i</span><span class="p">[</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one x value lies outside of the atlas volume.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>  <span class="c1"># This is only here for legacy reasons</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">i</span></div>


<div class="viewcode-block" id="BrainCoordinates.y2i">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainCoordinates.y2i">[docs]</a>
    <span class="k">def</span> <span class="nf">y2i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the nearest volume image index to a given y-axis coordinate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : float, numpy.array</span>
<span class="sd">            One or more y-axis coordinates, relative to the origin, y0.</span>
<span class="sd">        round : bool</span>
<span class="sd">            If true, round to the nearest index, replacing NaN values with 0.</span>
<span class="sd">        mode : {&#39;raise&#39;, &#39;clip&#39;, &#39;wrap&#39;}</span>
<span class="sd">            How to behave if the coordinate lies outside of the volume: raise (default) will raise</span>
<span class="sd">            a ValueError; &#39;clip&#39; will replace the index with the closest index inside the volume;</span>
<span class="sd">            &#39;wrap&#39; will return the index as is.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            The nearest indices of the image volume along the second dimension.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            At least one y value lies outside of the atlas volume. Change &#39;mode&#39; input to &#39;wrap&#39; to</span>
<span class="sd">            keep these values unchanged, or &#39;clip&#39; to return the nearest valid indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_round</span><span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;clip&#39;</span><span class="p">:</span>
                <span class="n">i</span><span class="p">[</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">i</span><span class="p">[</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one y value lies outside of the atlas volume.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>  <span class="c1"># This is only here for legacy reasons</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">i</span></div>


<div class="viewcode-block" id="BrainCoordinates.z2i">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainCoordinates.z2i">[docs]</a>
    <span class="k">def</span> <span class="nf">z2i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the nearest volume image index to a given z-axis coordinate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        z : float, numpy.array</span>
<span class="sd">            One or more z-axis coordinates, relative to the origin, z0.</span>
<span class="sd">        round : bool</span>
<span class="sd">            If true, round to the nearest index, replacing NaN values with 0.</span>
<span class="sd">        mode : {&#39;raise&#39;, &#39;clip&#39;, &#39;wrap&#39;}</span>
<span class="sd">            How to behave if the coordinate lies outside of the volume: raise (default) will raise</span>
<span class="sd">            a ValueError; &#39;clip&#39; will replace the index with the closest index inside the volume;</span>
<span class="sd">            &#39;wrap&#39; will return the index as is.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            The nearest indices of the image volume along the third dimension.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            At least one z value lies outside of the atlas volume. Change &#39;mode&#39; input to &#39;wrap&#39; to</span>
<span class="sd">            keep these values unchanged, or &#39;clip&#39; to return the nearest valid indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_round</span><span class="p">((</span><span class="n">z</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">z0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;clip&#39;</span><span class="p">:</span>
                <span class="n">i</span><span class="p">[</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">i</span><span class="p">[</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one z value lies outside of the atlas volume.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>  <span class="c1"># This is only here for legacy reasons</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">i</span></div>


<div class="viewcode-block" id="BrainCoordinates.xyz2i">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainCoordinates.xyz2i">[docs]</a>
    <span class="k">def</span> <span class="nf">xyz2i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the nearest volume image indices to the given Cartesian coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz : array_like</span>
<span class="sd">            One or more Cartesian coordinates, relative to the origin, xyz0.</span>
<span class="sd">        round : bool</span>
<span class="sd">            If true, round to the nearest index, replacing NaN values with 0.</span>
<span class="sd">        mode : {&#39;raise&#39;, &#39;clip&#39;, &#39;wrap&#39;}</span>
<span class="sd">            How to behave if any coordinate lies outside of the volume: raise (default) will raise</span>
<span class="sd">            a ValueError; &#39;clip&#39; will replace the index with the closest index inside the volume;</span>
<span class="sd">            &#39;wrap&#39; will return the index as is.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            The nearest indices of the image volume.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            At least one coordinate lies outside of the atlas volume. Change &#39;mode&#39; input to &#39;wrap&#39;</span>
<span class="sd">            to keep these values unchanged, or &#39;clip&#39; to return the nearest valid indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="nb">int</span> <span class="k">if</span> <span class="nb">round</span> <span class="k">else</span> <span class="nb">float</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods indices to distance&quot;&quot;&quot;</span>
<div class="viewcode-block" id="BrainCoordinates.i2x">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainCoordinates.i2x">[docs]</a>
    <span class="k">def</span> <span class="nf">i2x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the x-axis coordinate of a given index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ind : int, numpy.array</span>
<span class="sd">            One or more indices along the first dimension of the image volume.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float, numpy.array</span>
<span class="sd">            The corresponding x-axis coordinate(s), relative to the origin, x0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ind</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span></div>


<div class="viewcode-block" id="BrainCoordinates.i2y">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainCoordinates.i2y">[docs]</a>
    <span class="k">def</span> <span class="nf">i2y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the y-axis coordinate of a given index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ind : int, numpy.array</span>
<span class="sd">            One or more indices along the second dimension of the image volume.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float, numpy.array</span>
<span class="sd">            The corresponding y-axis coordinate(s), relative to the origin, y0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ind</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span></div>


<div class="viewcode-block" id="BrainCoordinates.i2z">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainCoordinates.i2z">[docs]</a>
    <span class="k">def</span> <span class="nf">i2z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the z-axis coordinate of a given index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ind : int, numpy.array</span>
<span class="sd">            One or more indices along the third dimension of the image volume.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float, numpy.array</span>
<span class="sd">            The corresponding z-axis coordinate(s), relative to the origin, z0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ind</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">z0</span></div>


<div class="viewcode-block" id="BrainCoordinates.i2xyz">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainCoordinates.i2xyz">[docs]</a>
    <span class="k">def</span> <span class="nf">i2xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iii</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Cartesian coordinates of a given index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iii : array_like</span>
<span class="sd">            One or more image volume indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            The corresponding xyz coordinates, relative to the origin, xyz0.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">iii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">iii</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">iii</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2x</span><span class="p">(</span><span class="n">iii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2y</span><span class="p">(</span><span class="n">iii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">iii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">out</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods bounds&quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xlim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># FIXME Document</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2x</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ylim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># FIXME Document</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2y</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">zlim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># FIXME Document</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>

<div class="viewcode-block" id="BrainCoordinates.lim">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainCoordinates.lim">[docs]</a>
    <span class="k">def</span> <span class="nf">lim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="c1"># FIXME Document</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xlim</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ylim</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;returns scales&quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># FIXME Document</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2x</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">yscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># FIXME Document</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2y</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">zscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># FIXME Document</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;returns the 3d mgrid used for 3d visualization&quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># FIXME Document</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xscale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yscale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zscale</span><span class="p">)</span></div>



<div class="viewcode-block" id="BrainAtlas">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainAtlas">[docs]</a>
<span class="k">class</span> <span class="nc">BrainAtlas</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Objects that holds image, labels and coordinate transforms for a brain Atlas.</span>
<span class="sd">    Currently this is designed for the AllenCCF at several resolutions,</span>
<span class="sd">    yet this class can be used for other atlases arises.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;numpy.array: A 3D image volume.&quot;&quot;&quot;</span>
    <span class="n">image</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;numpy.array: A 3D annotation label volume.&quot;&quot;&quot;</span>
    <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;numpy.array: One or several optional data volumes, the 3 last dimensions should match</span>
<span class="sd">    the image and the label volumes dimensions&quot;&quot;&quot;</span>
    <span class="n">volumes</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">dxyz</span><span class="p">,</span> <span class="n">regions</span><span class="p">,</span> <span class="n">iorigin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                 <span class="n">dims2xyz</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">xyz2dims</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        self.image: image volume (ap, ml, dv)</span>
<span class="sd">        self.label: label volume (ap, ml, dv)</span>
<span class="sd">        self.bc: atlas.BrainCoordinate object</span>
<span class="sd">        self.regions: atlas.BrainRegions object</span>
<span class="sd">        self.top: 2d np array (ap, ml) containing the z-coordinate (m) of the surface of the brain</span>
<span class="sd">        self.dims2xyz and self.zyz2dims: map image axis order to xyz coordinates order</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regions</span> <span class="o">=</span> <span class="n">regions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dims2xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dims2xyz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xyz2dims</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims2xyz</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dims2xyz</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
        <span class="c1"># create the coordinate transform object that maps volume indices to real world coordinates</span>
        <span class="n">nxyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">dims2xyz</span><span class="p">]</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">BrainCoordinates</span><span class="p">(</span><span class="n">nxyz</span><span class="o">=</span><span class="n">nxyz</span><span class="p">,</span> <span class="n">xyz0</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dxyz</span><span class="o">=</span><span class="n">dxyz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">=</span> <span class="n">BrainCoordinates</span><span class="p">(</span><span class="n">nxyz</span><span class="o">=</span><span class="n">nxyz</span><span class="p">,</span> <span class="n">xyz0</span><span class="o">=-</span><span class="n">bc</span><span class="o">.</span><span class="n">i2xyz</span><span class="p">(</span><span class="n">iorigin</span><span class="p">),</span> <span class="n">dxyz</span><span class="o">=</span><span class="n">dxyz</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_cache_dir</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ./histology/ATLAS/Needles/Allen</span>
<span class="sd">        Where . is the main ONE cache directory</span>
<span class="sd">        :return: pathlib.Path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">par</span> <span class="o">=</span> <span class="n">one</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">silent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">path_atlas</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="n">CACHE_DIR</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">&#39;histology&#39;</span><span class="p">,</span> <span class="s1">&#39;ATLAS&#39;</span><span class="p">,</span> <span class="s1">&#39;Needles&#39;</span><span class="p">,</span> <span class="s1">&#39;Allen&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path_atlas</span>

<div class="viewcode-block" id="BrainAtlas.mask">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainAtlas.mask">[docs]</a>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Boolean mask volume of the brain atlas, where 1 is inside the convex brain and 0 is outside</span>
<span class="sd">        This returns an ovoid volume shaped like the brain and this will contain void values in the ventricules.</span>
<span class="sd">        :return: np.array Bool (nap, nml, ndv)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_surface</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="BrainAtlas.compute_surface">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainAtlas.compute_surface">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the volume top, bottom, left and right surfaces, and from these the outer surface of</span>
<span class="sd">        the image volume. This is needed to compute probe insertions intersections.</span>

<span class="sd">        NOTE: In places where the top or bottom surface touch the top or bottom of the atlas volume, the surface</span>
<span class="sd">        will be set to np.nan. If you encounter issues working with these surfaces check if this might be the cause.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># only compute if it hasn&#39;t already been computed</span>
            <span class="n">axz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># this is the dv axis</span>
            <span class="n">_surface</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="n">l0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_surface</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axz</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">l0</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axz</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">_top</span><span class="p">[</span><span class="n">_top</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">_bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nz</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axz</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axz</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">_bottom</span><span class="p">[</span><span class="n">_bottom</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nz</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">_top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">_bottom</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_surface</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">l0</span>
            <span class="n">idx_srf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="p">[</span><span class="n">idx_srf</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">srf_xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">i2xyz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">idx_srf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">idx_srf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                               <span class="n">idx_srf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span></div>


    <span class="k">def</span> <span class="nf">_lookup_inds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ixyz</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a 3D lookup from volume indices ixyz to the image volume</span>
<span class="sd">        :param ixyz: [n, 3] array of indices in the mlapdv order</span>
<span class="sd">        :return: n array of flat indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ixyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">idims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nxyz</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inds</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a 3D lookup from real world coordinates to the flat indices in the volume,</span>
<span class="sd">        defined in the BrainCoordinates object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz : numpy.array</span>
<span class="sd">            An (n, 3) array of Cartesian coordinates.</span>
<span class="sd">        mode : {&#39;raise&#39;, &#39;clip&#39;, &#39;wrap&#39;}</span>
<span class="sd">            How to behave if any coordinate lies outside of the volume: raise (default) will raise</span>
<span class="sd">            a ValueError; &#39;clip&#39; will replace the index with the closest index inside the volume;</span>
<span class="sd">            &#39;wrap&#39; will return the index as is.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            A 1D array of flat indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_inds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

<div class="viewcode-block" id="BrainAtlas.get_labels">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainAtlas.get_labels">[docs]</a>
    <span class="k">def</span> <span class="nf">get_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">radius_um</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a 3D lookup from real world coordinates to the volume labels</span>
<span class="sd">        and return the regions ids according to the mapping</span>
<span class="sd">        :param xyz: [n, 3] array of coordinates</span>
<span class="sd">        :param mapping: brain region mapping (defaults to original Allen mapping)</span>
<span class="sd">        :param radius_um: if not null, returns a regions ids array and an array of proportion</span>
<span class="sd">         of regions in a sphere of size radius around the coordinates.</span>
<span class="sd">        :param mode: {raise, &#39;clip&#39;} determines what to do when determined index lies outside the atlas volume</span>
<span class="sd">        &#39;raise&#39; will raise a ValueError (default)</span>
<span class="sd">        &#39;clip&#39; will replace the index with the closest index inside the volume</span>
<span class="sd">        :return: n array of region ids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="n">mapping</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">default_mapping</span>

        <span class="k">if</span> <span class="n">radius_um</span><span class="p">:</span>
            <span class="n">nrx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">radius_um</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">))</span>
            <span class="n">nry</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">radius_um</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">))</span>
            <span class="n">nrz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">radius_um</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">))</span>
            <span class="n">nr</span> <span class="o">=</span> <span class="p">[</span><span class="n">nrx</span><span class="p">,</span> <span class="n">nry</span><span class="p">,</span> <span class="n">nrz</span><span class="p">]</span>
            <span class="n">iii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
            <span class="c1"># computing the cube radius and indices is more complicated as volume indices are not</span>
            <span class="c1"># necessarily in ml, ap, dv order so the indices order is dynamic</span>
            <span class="n">rcube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="o">-</span><span class="n">nr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">dxyz</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">))</span>
            <span class="n">rcube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rcube</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">rcube</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rcube</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mf">1e6</span>
            <span class="n">icube</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">nr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">iii</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">iii</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">)</span>
            <span class="n">cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">mappings</span><span class="p">[</span><span class="n">mapping</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="n">icube</span><span class="p">]]</span>
            <span class="n">ilabs</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cube</span><span class="p">[</span><span class="n">rcube</span> <span class="o">&lt;=</span> <span class="n">radius_um</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="n">ilabs</span><span class="p">],</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">regions_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mapping</span><span class="p">(</span><span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_lookup</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)]]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="n">regions_indices</span><span class="p">]</span></div>


    <span class="k">def</span> <span class="nf">_get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Safe way to get mappings if nothing defined in regions.</span>
<span class="sd">        A mapping transforms from the full allen brain Atlas ids to the remapped ids</span>
<span class="sd">        new_ids = ids[mapping]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="n">mapping</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">default_mapping</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="p">,</span> <span class="s1">&#39;mappings&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">mappings</span><span class="p">[</span><span class="n">mapping</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_label2rgb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imlabel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a slice from the label volume to its RGB equivalent for display</span>
<span class="sd">        :param imlabel: 2D np-array containing label ids (slice of the label volume)</span>
<span class="sd">        :return: 3D np-array of the slice uint8 rgb values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="p">,</span> <span class="s1">&#39;rgb&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="n">imlabel</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if the regions exist and have the rgb attribute, do the rgb lookup</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">rgb</span><span class="p">[</span><span class="n">imlabel</span><span class="p">]</span>

<div class="viewcode-block" id="BrainAtlas.tilted_slice">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainAtlas.tilted_slice">[docs]</a>
    <span class="k">def</span> <span class="nf">tilted_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        From line coordinates, extracts the tilted plane containing the line from the 3D volume</span>
<span class="sd">        :param xyz: np.array: points defining a probe trajectory in 3D space (xyz triplets)</span>
<span class="sd">        if more than 2 points are provided will take the best fit</span>
<span class="sd">        :param axis:</span>
<span class="sd">            0: along ml = sagittal-slice</span>
<span class="sd">            1: along ap = coronal-slice</span>
<span class="sd">            2: along dv = horizontal-slice</span>
<span class="sd">        :param volume: &#39;image&#39; or &#39;annotation&#39;</span>
<span class="sd">        :return: np.array, abscissa extent (width), ordinate extent (height),</span>
<span class="sd">        squeezed axis extent (depth)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>   <span class="c1"># sagittal slice (squeeze/take along ml-axis)</span>
            <span class="n">wdim</span><span class="p">,</span> <span class="n">hdim</span><span class="p">,</span> <span class="n">ddim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># coronal slice (squeeze/take along ap-axis)</span>
            <span class="n">wdim</span><span class="p">,</span> <span class="n">hdim</span><span class="p">,</span> <span class="n">ddim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># horizontal slice (squeeze/take along dv-axis)</span>
            <span class="n">wdim</span><span class="p">,</span> <span class="n">hdim</span><span class="p">,</span> <span class="n">ddim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># get the best fit and find exit points of the volume along squeezed axis</span>
        <span class="n">trj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">sub_volume</span> <span class="o">=</span> <span class="n">trj</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">hdim</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">hdim</span><span class="p">)</span>
        <span class="n">sub_volume</span><span class="p">[:,</span> <span class="n">wdim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">wdim</span><span class="p">)</span>
        <span class="n">sub_volume_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">sub_volume</span><span class="p">)</span>
        <span class="n">tile_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sub_volume_i</span><span class="p">[:,</span> <span class="n">hdim</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nxyz</span><span class="p">[</span><span class="n">wdim</span><span class="p">]])</span>
        <span class="c1"># get indices along each dimension</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tile_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">indy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tile_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">sub_volume_i</span><span class="p">[:,</span> <span class="n">ddim</span><span class="p">],</span> <span class="n">tile_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># compute the slice indices and output the slice</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">INDS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">inds</span><span class="p">)))</span>
        <span class="n">INDX</span><span class="p">,</span> <span class="n">INDY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">indy</span><span class="p">)</span>
        <span class="n">indsl</span> <span class="o">=</span> <span class="p">[[</span><span class="n">INDX</span><span class="p">,</span> <span class="n">INDY</span><span class="p">,</span> <span class="n">INDS</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="n">wdim</span><span class="p">,</span> <span class="n">hdim</span><span class="p">,</span> <span class="n">ddim</span><span class="p">])[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">tslice</span> <span class="o">=</span> <span class="n">volume</span><span class="p">[</span><span class="n">indsl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">volume</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;annotation&#39;</span><span class="p">:</span>
            <span class="n">tslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label2rgb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="n">indsl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="n">volume</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="n">tslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">indsl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">volume</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;surface&#39;</span><span class="p">:</span>
            <span class="n">tslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="p">[</span><span class="n">indsl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

        <span class="c1">#  get extents with correct convention NB: matplotlib flips the y-axis on imshow !</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sub_volume</span><span class="p">[:,</span> <span class="n">wdim</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">wdim</span><span class="p">))]</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sub_volume</span><span class="p">[:,</span> <span class="n">hdim</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">hdim</span><span class="p">))])</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sub_volume</span><span class="p">[:,</span> <span class="n">ddim</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">ddim</span><span class="p">))])</span>
        <span class="k">return</span> <span class="n">tslice</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span></div>


<div class="viewcode-block" id="BrainAtlas.plot_tilted_slice">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainAtlas.plot_tilted_slice">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_tilted_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_sec</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        From line coordinates, extracts the tilted plane containing the line from the 3D volume</span>
<span class="sd">        :param xyz: np.array: points defining a probe trajectory in 3D space (xyz triplets)</span>
<span class="sd">        if more than 2 points are provided will take the best fit</span>
<span class="sd">        :param axis:</span>
<span class="sd">            0: along ml = sagittal-slice</span>
<span class="sd">            1: along ap = coronal-slice</span>
<span class="sd">            2: along dv = horizontal-slice</span>
<span class="sd">        :param volume: &#39;image&#39; or &#39;annotation&#39;</span>
<span class="sd">        :return: matplotlib axis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axis_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;ap (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;dv (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;ml (um)&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">axis_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;ml (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;dv (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;ap (um)&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">axis_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;ml (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;ap (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;dv (um)&#39;</span><span class="p">])</span>

        <span class="n">tslice</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tilted_slice</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cmap</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;bone&#39;</span><span class="p">)</span>
        <span class="c1"># get the transfer function from y-axis to squeezed axis for second axe</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">height</span><span class="p">,</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">depth</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">*</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">tslice</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">sec_ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">secondary_yaxis</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">functions</span><span class="o">=</span><span class="p">(</span>
                                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">axis_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">axis_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">sec_ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">axis_labels</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">return_sec</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ax</span><span class="p">,</span> <span class="n">sec_ax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ax</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_plot_slice</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot an atlas slice.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        im : numpy.array</span>
<span class="sd">            A 2D image slice to plot.</span>
<span class="sd">        extent : array_like</span>
<span class="sd">            The bounding box in data coordinates that the image will fill specified as (left,</span>
<span class="sd">            right, bottom, top) in data coordinates.</span>
<span class="sd">        ax : matplotlib.pyplot.Axes</span>
<span class="sd">            An optional Axes object to plot to.</span>
<span class="sd">        cmap : str, matplotlib.colors.Colormap</span>
<span class="sd">            The Colormap instance or registered colormap name used to map scalar data to colors.</span>
<span class="sd">            Defaults to &#39;bone&#39;.</span>
<span class="sd">        volume : str | np.array</span>
<span class="sd">            If &#39;boundary&#39;, assumes image is an outline of boundaries between all regions.</span>
<span class="sd">            FIXME How does this affect the plot?</span>
<span class="sd">        **kwargs</span>
<span class="sd">            See matplotlib.pyplot.imshow.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.pyplot.Axes</span>
<span class="sd">            The image axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cmap</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;bone&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;boundary&#39;</span><span class="p">:</span>
                <span class="n">imb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="o">*</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                <span class="n">imb</span><span class="p">[</span><span class="n">im</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">])</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">imb</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

<div class="viewcode-block" id="BrainAtlas.extent">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainAtlas.extent">[docs]</a>
    <span class="k">def</span> <span class="nf">extent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param axis: direction along which the volume is stacked:</span>
<span class="sd">         (2 = z for horizontal slice)</span>
<span class="sd">         (1 = y for coronal slice)</span>
<span class="sd">         (0 = x for sagittal slice)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">ylim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">zlim</span><span class="p">)]</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xlim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">zlim</span><span class="p">)]</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xlim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">ylim</span><span class="p">)]</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="k">return</span> <span class="n">extent</span></div>


<div class="viewcode-block" id="BrainAtlas.slice">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainAtlas.slice">[docs]</a>
    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get slice through atlas</span>

<span class="sd">        :param coordinate: coordinate to slice in metres, float</span>
<span class="sd">        :param axis: xyz convention:  0 for ml, 1 for ap, 2 for dv</span>
<span class="sd">            - 0: sagittal slice (along ml axis)</span>
<span class="sd">            - 1: coronal slice (along ap axis)</span>
<span class="sd">            - 2: horizontal slice (along dv axis)</span>
<span class="sd">        :param volume:</span>
<span class="sd">            - &#39;image&#39; - allen image volume</span>
<span class="sd">            - &#39;annotation&#39; - allen annotation volume</span>
<span class="sd">            - &#39;surface&#39; - outer surface of mesh</span>
<span class="sd">            - &#39;boundary&#39; - outline of boundaries between all regions</span>
<span class="sd">            - &#39;volume&#39; - custom volume, must pass in volume of shape ba.image.shape as regions_value argument</span>
<span class="sd">            - &#39;value&#39; - custom value per allen region, must pass in array of shape ba.regions.id as regions_value argument</span>
<span class="sd">        :param mode: error mode for out of bounds coordinates</span>
<span class="sd">            -   &#39;raise&#39; raise an error</span>
<span class="sd">            -   &#39;clip&#39; gets the first or last index</span>
<span class="sd">        :param region_values: custom values to plot</span>
<span class="sd">            - if volume=&#39;volume&#39;, region_values must have shape ba.image.shape</span>
<span class="sd">            - if volume=&#39;value&#39;, region_values must have shape ba.regions.id</span>
<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :return: 2d array or 3d RGB numpy int8 array of dimensions:</span>
<span class="sd">            - 0: nap x ndv (sagittal slice)</span>
<span class="sd">            - 1: nml x ndv (coronal slice)</span>
<span class="sd">            - 2: nap x nml (horizontal slice)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">x2i</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinate</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">y2i</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinate</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">z2i</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinate</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_take</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This is a 2 steps process to get the slice along the correct axis</span>
<span class="sd">            1) slice the volume according to the mapped axis corresponding to the sclice</span>
<span class="sd">            we do this because np.take is 50 thousand times slower than straight slicing !</span>
<span class="sd">            2) reshape the output array according to the slice specifications</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">volume_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;clip&#39;</span><span class="p">:</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">volume_axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">volume_axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">slic</span> <span class="o">=</span> <span class="n">vol</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">elif</span> <span class="n">volume_axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">slic</span> <span class="o">=</span> <span class="n">vol</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">elif</span> <span class="n">volume_axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">slic</span> <span class="o">=</span> <span class="n">vol</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ind</span><span class="p">]</span>
            <span class="n">output_sizes</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>  <span class="c1"># we expect those sizes where index is the axis</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="n">output_sizes</span><span class="p">[</span><span class="n">axis</span><span class="p">]])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">slic</span> <span class="o">=</span> <span class="n">slic</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">slic</span>

        <span class="k">def</span> <span class="nf">_take_remap</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
            <span class="c1"># For the labels, remap the regions indices according to the mapping</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mapping</span><span class="p">(</span><span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">)[</span><span class="n">_take</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_take</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="ow">in</span> <span class="s1">&#39;annotation&#39;</span><span class="p">:</span>
            <span class="n">iregion</span> <span class="o">=</span> <span class="n">_take_remap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label2rgb</span><span class="p">(</span><span class="n">iregion</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">region_values</span><span class="p">[</span><span class="n">_take_remap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">,</span> <span class="s1">&#39;edges&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_surface</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">_take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;boundary&#39;</span><span class="p">:</span>
            <span class="n">iregion</span> <span class="o">=</span> <span class="n">_take_remap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_boundaries</span><span class="p">(</span><span class="n">iregion</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;volume&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coordinate</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">_take</span><span class="p">(</span><span class="n">region_values</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="BrainAtlas.compute_boundaries">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainAtlas.compute_boundaries">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the boundaries between regions on slice</span>
<span class="sd">        :param values:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boundary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">boundary</span> <span class="o">=</span> <span class="n">boundary</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">boundary</span> <span class="o">=</span> <span class="n">boundary</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">boundary</span> <span class="o">=</span> <span class="n">boundary</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="n">boundary</span><span class="p">[</span><span class="n">boundary</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">boundary</span></div>


<div class="viewcode-block" id="BrainAtlas.plot_slices">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainAtlas.plot_slices">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        From a single coordinate, plots the 3 slices that intersect at this point in a single</span>
<span class="sd">        matplotlib figure</span>
<span class="sd">        :param xyz: mlapdv coordinate in m</span>
<span class="sd">        :param args: arguments to be forwarded to plot slices</span>
<span class="sd">        :param kwargs: keyword arguments to be forwarded to plot slices</span>
<span class="sd">        :return: 2 by 2 array of axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_cslice</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_sslice</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_hslice</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">xyz_um</span> <span class="o">=</span> <span class="n">xyz</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xyz_um</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xyz_um</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;g*&#39;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xyz_um</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xyz_um</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;g*&#39;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xyz_um</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xyz_um</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;g*&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">axs</span></div>


<div class="viewcode-block" id="BrainAtlas.plot_cslice">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainAtlas.plot_cslice">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_cslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ap_coordinate</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot coronal slice through atlas at given ap_coordinate</span>

<span class="sd">        :param: ap_coordinate (m)</span>
<span class="sd">        :param volume:</span>
<span class="sd">            - &#39;image&#39; - allen image volume</span>
<span class="sd">            - &#39;annotation&#39; - allen annotation volume</span>
<span class="sd">            - &#39;surface&#39; - outer surface of mesh</span>
<span class="sd">            - &#39;boundary&#39; - outline of boundaries between all regions</span>
<span class="sd">            - &#39;volume&#39; - custom volume, must pass in volume of shape ba.image.shape as regions_value argument</span>
<span class="sd">            - &#39;value&#39; - custom value per allen region, must pass in array of shape ba.regions.id as regions_value argument</span>
<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :param region_values: custom values to plot</span>
<span class="sd">            - if volume=&#39;volume&#39;, region_values must have shape ba.image.shape</span>
<span class="sd">            - if volume=&#39;value&#39;, region_values must have shape ba.regions.id</span>
<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :param **kwargs: matplotlib.pyplot.imshow kwarg arguments</span>
<span class="sd">        :return: matplotlib ax object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">ap_coordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="n">region_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_slice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">cslice</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="BrainAtlas.plot_hslice">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainAtlas.plot_hslice">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_hslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dv_coordinate</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot horizontal slice through atlas at given dv_coordinate</span>

<span class="sd">        :param: dv_coordinate (m)</span>
<span class="sd">        :param volume:</span>
<span class="sd">            - &#39;image&#39; - allen image volume</span>
<span class="sd">            - &#39;annotation&#39; - allen annotation volume</span>
<span class="sd">            - &#39;surface&#39; - outer surface of mesh</span>
<span class="sd">            - &#39;boundary&#39; - outline of boundaries between all regions</span>
<span class="sd">            - &#39;volume&#39; - custom volume, must pass in volume of shape ba.image.shape as regions_value argument</span>
<span class="sd">            - &#39;value&#39; - custom value per allen region, must pass in array of shape ba.regions.id as regions_value argument</span>
<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :param region_values: custom values to plot</span>
<span class="sd">            - if volume=&#39;volume&#39;, region_values must have shape ba.image.shape</span>
<span class="sd">            - if volume=&#39;value&#39;, region_values must have shape ba.regions.id</span>
<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :param **kwargs: matplotlib.pyplot.imshow kwarg arguments</span>
<span class="sd">        :return: matplotlib ax object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">hslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">dv_coordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="n">region_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_slice</span><span class="p">(</span><span class="n">hslice</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="BrainAtlas.plot_sslice">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainAtlas.plot_sslice">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_sslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ml_coordinate</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot sagittal slice through atlas at given ml_coordinate</span>

<span class="sd">        :param: ml_coordinate (m)</span>
<span class="sd">        :param volume:</span>
<span class="sd">            - &#39;image&#39; - allen image volume</span>
<span class="sd">            - &#39;annotation&#39; - allen annotation volume</span>
<span class="sd">            - &#39;surface&#39; - outer surface of mesh</span>
<span class="sd">            - &#39;boundary&#39; - outline of boundaries between all regions</span>
<span class="sd">            - &#39;volume&#39; - custom volume, must pass in volume of shape ba.image.shape as regions_value argument</span>
<span class="sd">            - &#39;value&#39; - custom value per allen region, must pass in array of shape ba.regions.id as regions_value argument</span>
<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :param region_values: custom values to plot</span>
<span class="sd">            - if volume=&#39;volume&#39;, region_values must have shape ba.image.shape</span>
<span class="sd">            - if volume=&#39;value&#39;, region_values must have shape ba.regions.id</span>
<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :param **kwargs: matplotlib.pyplot.imshow kwarg arguments</span>
<span class="sd">        :return: matplotlib ax object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">ml_coordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="n">region_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_slice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">sslice</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="BrainAtlas.plot_top">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.BrainAtlas.plot_top">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;annotation&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot top view of atlas</span>
<span class="sd">        :param volume:</span>
<span class="sd">            - &#39;image&#39; - allen image volume</span>
<span class="sd">            - &#39;annotation&#39; - allen annotation volume</span>
<span class="sd">            - &#39;boundary&#39; - outline of boundaries between all regions</span>
<span class="sd">            - &#39;volume&#39; - custom volume, must pass in volume of shape ba.image.shape as regions_value argument</span>
<span class="sd">            - &#39;value&#39; - custom value per allen region, must pass in array of shape ba.regions.id as regions_value argument</span>

<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :param region_values:</span>
<span class="sd">        :param ax:</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_surface</span><span class="p">()</span>
        <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span>
        <span class="n">iz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">z2i</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_inds</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mapping</span><span class="p">(</span><span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">inds</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;annotation&#39;</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label2rgb</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">region_values</span><span class="p">[</span><span class="n">regions</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;volume&#39;</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">iz</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">im</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">region_values</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">iz</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;boundary&#39;</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_boundaries</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_slice</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Trajectory">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.Trajectory">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Trajectory</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    3D Trajectory (usually for a linear probe), minimally defined by a vector and a point.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Instantiate from a best fit from an n by 3 array containing xyz coordinates:</span>

<span class="sd">    &gt;&gt;&gt; trj = Trajectory.fit(xyz)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">point</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

<div class="viewcode-block" id="Trajectory.fit">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.Trajectory.fit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="n">xyz</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits a line to a 3D cloud of points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz : numpy.array</span>
<span class="sd">            An n by 3 array containing a cloud of points to fit a line to.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Trajectory</span>
<span class="sd">            A new trajectory object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Trajectory</span><span class="p">(</span><span class="n">vector</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">xyz_mean</span><span class="p">)[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">point</span><span class="o">=</span><span class="n">xyz_mean</span><span class="p">)</span></div>


<div class="viewcode-block" id="Trajectory.eval_x">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.Trajectory.eval_x">[docs]</a>
    <span class="k">def</span> <span class="nf">eval_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        given an array of x coordinates, returns the xyz array of coordinates along the insertion</span>
<span class="sd">        :param x: n by 1 or numpy array containing x-coordinates</span>
<span class="sd">        :return: n by 3 numpy array containing xyz-coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="Trajectory.eval_y">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.Trajectory.eval_y">[docs]</a>
    <span class="k">def</span> <span class="nf">eval_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        given an array of y coordinates, returns the xyz array of coordinates along the insertion</span>
<span class="sd">        :param y: n by 1 or numpy array containing y-coordinates</span>
<span class="sd">        :return: n by 3 numpy array containing xyz-coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="Trajectory.eval_z">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.Trajectory.eval_z">[docs]</a>
    <span class="k">def</span> <span class="nf">eval_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        given an array of z coordinates, returns the xyz array of coordinates along the insertion</span>
<span class="sd">        :param z: n by 1 or numpy array containing z-coordinates</span>
<span class="sd">        :return: n by 3 numpy array containing xyz-coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Trajectory.project">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.Trajectory.project">[docs]</a>
    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        projects a point onto the trajectory line</span>
<span class="sd">        :param point: np.array(x, y, z) coordinates</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html</span>
        <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span> <span class="o">/</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span></div>


<div class="viewcode-block" id="Trajectory.mindist">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.Trajectory.mindist">[docs]</a>
    <span class="k">def</span> <span class="nf">mindist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the minimum distance to the trajectory line for one or a set of points.</span>
<span class="sd">        If bounds are provided, computes the minimum distance to the segment instead of an</span>
<span class="sd">        infinite line.</span>
<span class="sd">        :param xyz: [..., 3]</span>
<span class="sd">        :param bounds: defaults to None.  np.array [2, 3]: segment boundaries, inf line if None</span>
<span class="sd">        :return: minimum distance [...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">proj</span> <span class="o">-</span> <span class="n">xyz</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># project the boundaries and the points along the traj</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>
            <span class="n">ob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="c1"># for points below and above boundaries, compute cartesian distance to the boundary</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">xyz</span><span class="p">[</span><span class="n">imin</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="n">ob</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">imax</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">xyz</span><span class="p">[</span><span class="n">imax</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="n">ob</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span></div>


    <span class="k">def</span> <span class="nf">_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="c1"># uses symmetric form of 3d line equation to get xyz coordinates given one coordinate</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="c1"># there are cases where it&#39;s impossible to project if a line is // to the axis</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span>

<div class="viewcode-block" id="Trajectory.exit_points">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.Trajectory.exit_points">[docs]</a>
    <span class="k">def</span> <span class="nf">exit_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a Trajectory and a BrainCoordinates object, computes the intersection of the</span>
<span class="sd">        trajectory with the brain coordinates bounding box</span>
<span class="sd">        :param bc: BrainCoordinate objects</span>
<span class="sd">        :return: np.ndarray 2 y 3 corresponding to exit points xyz coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">xlim</span><span class="p">,</span> <span class="n">bc</span><span class="o">.</span><span class="n">ylim</span><span class="p">,</span> <span class="n">bc</span><span class="o">.</span><span class="n">zlim</span><span class="p">]</span>
        <span class="n">epoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_x</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">xlim</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_y</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">ylim</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_z</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">zlim</span><span class="p">)]</span>
        <span class="n">epoints</span> <span class="o">=</span> <span class="n">epoints</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">epoints</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;=</span> <span class="n">epoints</span><span class="p">,</span> <span class="n">epoints</span> <span class="o">&lt;=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">epoints</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="p">:]</span></div>
</div>



<div class="viewcode-block" id="Insertion">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.Insertion">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Insertion</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines an ephys probe insertion in 3D coordinate. IBL conventions.</span>

<span class="sd">    To instantiate, use the static methods: `Insertion.from_track` and `Insertion.from_dict`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">phi</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="Insertion.from_track">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.Insertion.from_track">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_track</span><span class="p">(</span><span class="n">xyzs</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define an insersion from one or more trajectory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyzs : numpy.array</span>
<span class="sd">             An n by 3 array xyz coordinates representing an insertion trajectory.</span>
<span class="sd">        brain_atlas : BrainAtlas</span>
<span class="sd">            A brain atlas instance, used to attain the point of entry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Insertion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">brain_atlas</span><span class="p">,</span> <span class="s1">&#39;Input argument brain_atlas must be defined&#39;</span>
        <span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">xyzs</span><span class="p">)</span>
        <span class="c1"># project the deepest point into the vector to get the tip coordinate</span>
        <span class="n">tip</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">xyzs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">xyzs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span> <span class="p">:])</span>
        <span class="c1"># get intersection with the brain surface as an entry point</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="n">Insertion</span><span class="o">.</span><span class="n">get_brain_entry</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">)</span>
        <span class="c1"># convert to spherical system to store the insertion</span>
        <span class="n">depth</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">cart2sph</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">entry</span> <span class="o">-</span> <span class="n">tip</span><span class="p">))</span>
        <span class="n">insertion_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;phi&#39;</span><span class="p">:</span> <span class="n">phi</span><span class="p">,</span> <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="n">theta</span><span class="p">,</span> <span class="s1">&#39;depth&#39;</span><span class="p">:</span> <span class="n">depth</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">Insertion</span><span class="p">(</span><span class="o">**</span><span class="n">insertion_dict</span><span class="p">)</span></div>


<div class="viewcode-block" id="Insertion.from_dict">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.Insertion.from_dict">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs an Insertion object from the json information stored in probes.description file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d : dict</span>
<span class="sd">            A dictionary containing at least the following keys {&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;phi&#39;, &#39;theta&#39;,</span>
<span class="sd">            &#39;depth&#39;}.  The depth and xyz coordinates must be in um.</span>
<span class="sd">        brain_atlas : BrainAtlas, default=None</span>
<span class="sd">            If provided, disregards the z coordinate and locks the insertion point to the z of the</span>
<span class="sd">            brain surface.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Insertion</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; tri = {&#39;x&#39;: 544.0, &#39;y&#39;: 1285.0, &#39;z&#39;: 0.0, &#39;phi&#39;: 0.0, &#39;theta&#39;: 5.0, &#39;depth&#39;: 4501.0}</span>
<span class="sd">        &gt;&gt;&gt; ins = Insertion.from_dict(tri)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">brain_atlas</span><span class="p">,</span> <span class="s1">&#39;Input argument brain_atlas must be defined&#39;</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">brain_atlas</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">):</span>
            <span class="n">brain_atlas</span><span class="o">.</span><span class="n">compute_surface</span><span class="p">()</span>
        <span class="n">iy</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">y2i</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">)</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">x2i</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">)</span>
        <span class="c1"># Only use the brain surface value as z if it isn&#39;t NaN (this happens when the surface touches the edges</span>
        <span class="c1"># of the atlas volume</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">brain_atlas</span><span class="o">.</span><span class="n">top</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]):</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">top</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Insertion</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span>
                         <span class="n">phi</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">],</span> <span class="n">theta</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">],</span> <span class="n">depth</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">,</span>
                         <span class="n">beta</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;beta&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the trajectory object matching insertion coordinates</span>
<span class="sd">        :return: atlas.Trajectory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Trajectory</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tip</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sph2cart</span><span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_surface_intersection</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the intersection of a trajectory with either the top or the bottom surface of an atlas.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        traj: iblatlas.atlas.Trajectory object</span>
<span class="sd">        brain_atlas: iblatlas.atlas.BrainAtlas (or descendant) object</span>
<span class="sd">        surface: str, optional (defaults to &#39;top&#39;) &#39;top&#39; or &#39;bottom&#39;</span>
<span class="sd">        mode: str, optional (defaults to &#39;raise&#39;) &#39;raise&#39; or &#39;none&#39;: raise an error if no intersection</span>
<span class="sd">         with the brain surface is found otherwise returns None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xyz: np.array, 3 elements, x, y, z coordinates of the intersection point with the surface</span>
<span class="sd">             None if no intersection is found and mode is not set to &#39;raise&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">brain_atlas</span><span class="o">.</span><span class="n">compute_surface</span><span class="p">()</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">mindist</span><span class="p">(</span><span class="n">brain_atlas</span><span class="o">.</span><span class="n">srf_xyz</span><span class="p">)</span>
        <span class="n">dist_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
        <span class="c1"># In some cases the nearest two intersection points are not the top and bottom of brain</span>
        <span class="c1"># So we find all intersection points that fall within one voxel and take the one with</span>
        <span class="c1"># highest dV to be entry and lowest dV to be exit</span>
        <span class="n">idx_lim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">distance</span><span class="p">[</span><span class="n">dist_sort</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e6</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">brain_atlas</span><span class="o">.</span><span class="n">res_um</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">idx_lim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># no intersection found</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No intersection found with brain surface&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="n">dist_lim</span> <span class="o">=</span> <span class="n">dist_sort</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">idx_lim</span><span class="p">]</span>
        <span class="n">z_val</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">srf_xyz</span><span class="p">[</span><span class="n">dist_lim</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">surface</span> <span class="o">==</span> <span class="s1">&#39;top&#39;</span><span class="p">:</span>
            <span class="n">ma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">z_val</span><span class="p">)</span>
            <span class="n">_xyz</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">srf_xyz</span><span class="p">[</span><span class="n">dist_lim</span><span class="p">[</span><span class="n">ma</span><span class="p">],</span> <span class="p">:]</span>
            <span class="n">_ixyz</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">_xyz</span><span class="p">)</span>
            <span class="n">_ixyz</span><span class="p">[</span><span class="n">brain_atlas</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">surface</span> <span class="o">==</span> <span class="s1">&#39;bottom&#39;</span><span class="p">:</span>
            <span class="n">ma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">z_val</span><span class="p">)</span>
            <span class="n">_xyz</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">srf_xyz</span><span class="p">[</span><span class="n">dist_lim</span><span class="p">[</span><span class="n">ma</span><span class="p">],</span> <span class="p">:]</span>
            <span class="n">_ixyz</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">_xyz</span><span class="p">)</span>

        <span class="n">xyz</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">i2xyz</span><span class="p">(</span><span class="n">_ixyz</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">xyz</span>

<div class="viewcode-block" id="Insertion.get_brain_exit">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.Insertion.get_brain_exit">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_brain_exit</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a Trajectory and a BrainAtlas object, computes the brain exit coordinate as the</span>
<span class="sd">        intersection of the trajectory and the brain surface (brain_atlas.surface)</span>
<span class="sd">        :param brain_atlas:</span>
<span class="sd">        :return: 3 element array x,y,z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find point where trajectory intersects with bottom of brain</span>
        <span class="k">return</span> <span class="n">Insertion</span><span class="o">.</span><span class="n">_get_surface_intersection</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span></div>


<div class="viewcode-block" id="Insertion.get_brain_entry">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.Insertion.get_brain_entry">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_brain_entry</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a Trajectory and a BrainAtlas object, computes the brain entry coordinate as the</span>
<span class="sd">        intersection of the trajectory and the brain surface (brain_atlas.surface)</span>
<span class="sd">        :param brain_atlas:</span>
<span class="sd">        :return: 3 element array x,y,z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find point where trajectory intersects with top of brain</span>
        <span class="k">return</span> <span class="n">Insertion</span><span class="o">.</span><span class="n">_get_surface_intersection</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="AllenAtlas">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.AllenAtlas">[docs]</a>
<span class="k">class</span> <span class="nc">AllenAtlas</span><span class="p">(</span><span class="n">BrainAtlas</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Allan Common Coordinate Framework (CCF) brain atlas.</span>

<span class="sd">    Instantiates an atlas.BrainAtlas corresponding to the Allen CCF at the given resolution</span>
<span class="sd">    using the IBL Bregma and coordinate system.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;pathlib.PurePosixPath: The default relative path of the Allen atlas file.&quot;&quot;&quot;</span>
    <span class="n">atlas_rel_path</span> <span class="o">=</span> <span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">&#39;histology&#39;</span><span class="p">,</span> <span class="s1">&#39;ATLAS&#39;</span><span class="p">,</span> <span class="s1">&#39;Needles&#39;</span><span class="p">,</span> <span class="s1">&#39;Allen&#39;</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;numpy.array: A diffusion weighted imaging (DWI) image volume.</span>

<span class="sd">    This average template brain was created from images of 1,675 young adult C57BL/6J mouse brains</span>
<span class="sd">    acquired using serial two-photon tomography.</span>
<span class="sd">    This volume has a C-ordered shape of (ap, ml, dv) and contains uint16</span>
<span class="sd">    values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">image</span> <span class="o">=</span> <span class="kc">None</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;numpy.array: An annotation label volume.</span>

<span class="sd">    The Allen atlas label volume has with the shape (ap, ml, dv) and contains uint16 indices</span>
<span class="sd">    of the Allen CCF brain regions to which each voxel belongs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res_um</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">mock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">hist_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiates an atlas.BrainAtlas corresponding to the Allen CCF at the given resolution</span>
<span class="sd">        using the IBL Bregma and coordinate system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        res_um : {10, 25, 50} int</span>
<span class="sd">            The Atlas resolution in micrometres; one of 10, 25 or 50um.</span>
<span class="sd">        scaling : float, numpy.array</span>
<span class="sd">            Scale factor along ml, ap, dv for squeeze and stretch (default: [1, 1, 1]).</span>
<span class="sd">        mock : bool</span>
<span class="sd">            For testing purposes, return atlas object with image comprising zeros.</span>
<span class="sd">        hist_path : str, pathlib.Path</span>
<span class="sd">            The location of the image volume. May be a full file path or a directory.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Instantiate Atlas from a non-default location, in this case the cache_dir of an ONE instance.</span>
<span class="sd">        &gt;&gt;&gt; target_dir = one.cache_dir / AllenAtlas.atlas_rel_path</span>
<span class="sd">        ... ba = AllenAtlas(hist_path=target_dir)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LUT_VERSION</span> <span class="o">=</span> <span class="s1">&#39;v01&#39;</span>  <span class="c1"># version 01 is the lateralized version</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="n">BrainRegions</span><span class="p">()</span>
        <span class="n">xyz2dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># this is the c-contiguous ordering</span>
        <span class="n">dims2xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="c1"># we use Bregma as the origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_um</span> <span class="o">=</span> <span class="n">res_um</span>
        <span class="n">ibregma</span> <span class="o">=</span> <span class="p">(</span><span class="n">ALLEN_CCF_LANDMARKS_MLAPDV_UM</span><span class="p">[</span><span class="s1">&#39;bregma&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_um</span><span class="p">)</span>
        <span class="n">dxyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_um</span> <span class="o">*</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">scaling</span>
        <span class="k">if</span> <span class="n">mock</span><span class="p">:</span>
            <span class="n">image</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">528</span><span class="p">,</span> <span class="mi">456</span><span class="p">,</span> <span class="mi">320</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
            <span class="n">label</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">100</span><span class="p">:</span><span class="mi">105</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1327</span>  <span class="c1"># lookup index for retina, id 304325711 (no id 1327)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Hist path may be a full path to an existing image file, or a path to a directory</span>
            <span class="n">cache_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">one</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">silent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">CACHE_DIR</span><span class="p">)</span>
            <span class="n">hist_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">hist_path</span> <span class="ow">or</span> <span class="n">cache_dir</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atlas_rel_path</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hist_path</span><span class="o">.</span><span class="n">suffix</span><span class="p">:</span>  <span class="c1"># check if folder</span>
                <span class="n">hist_path</span> <span class="o">/=</span> <span class="sa">f</span><span class="s1">&#39;average_template_</span><span class="si">{</span><span class="n">res_um</span><span class="si">}</span><span class="s1">.nrrd&#39;</span>
            <span class="c1"># get the image volume</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hist_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">hist_path</span> <span class="o">=</span> <span class="n">_download_atlas_allen</span><span class="p">(</span><span class="n">hist_path</span><span class="p">)</span>
            <span class="c1"># get the remapped label volume</span>
            <span class="n">file_label</span> <span class="o">=</span> <span class="n">hist_path</span><span class="o">.</span><span class="n">with_name</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;annotation_</span><span class="si">{</span><span class="n">res_um</span><span class="si">}</span><span class="s1">.nrrd&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_label</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">file_label</span> <span class="o">=</span> <span class="n">_download_atlas_allen</span><span class="p">(</span><span class="n">file_label</span><span class="p">)</span>
            <span class="n">file_label_remap</span> <span class="o">=</span> <span class="n">hist_path</span><span class="o">.</span><span class="n">with_name</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;annotation_</span><span class="si">{</span><span class="n">res_um</span><span class="si">}</span><span class="s1">_lut_</span><span class="si">{</span><span class="n">LUT_VERSION</span><span class="si">}</span><span class="s1">.npz&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_label_remap</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_volume</span><span class="p">(</span><span class="n">file_label</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing brain atlas annotations lookup table&quot;</span><span class="p">)</span>
                <span class="c1"># lateralize atlas: for this the regions of the left hemisphere have primary</span>
                <span class="c1"># keys opposite to to the normal ones</span>
                <span class="n">lateral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">lateral</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">ibregma</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">lateral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">lateral</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">label</span> <span class="o">*</span> <span class="n">lateral</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="c1"># the 10 um atlas is too big to fit in memory so work by chunks instead</span>
                <span class="k">if</span> <span class="n">res_um</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="n">first</span><span class="p">,</span> <span class="n">ncols</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
                    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">last</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">first</span> <span class="o">+</span> <span class="n">ncols</span><span class="p">,</span> <span class="n">label</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing... </span><span class="si">{</span><span class="n">last</span><span class="si">}</span><span class="s2"> on </span><span class="si">{</span><span class="n">label</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">_</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">ismember</span><span class="p">(</span><span class="n">label</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">first</span><span class="p">:</span><span class="n">last</span><span class="p">],</span> <span class="n">regions</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                        <span class="n">label</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">first</span><span class="p">:</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">label</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">first</span><span class="p">:</span><span class="n">last</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">last</span> <span class="o">==</span> <span class="n">label</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="k">break</span>
                        <span class="n">first</span> <span class="o">+=</span> <span class="n">ncols</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Saving npz, this can take a long time&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">ismember</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">regions</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">),</span> <span class="n">label</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">file_label_remap</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cached remapping file </span><span class="si">{</span><span class="n">file_label_remap</span><span class="si">}</span><span class="s2"> ...&quot;</span><span class="p">)</span>
            <span class="c1"># loads the files</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_volume</span><span class="p">(</span><span class="n">file_label_remap</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_volume</span><span class="p">(</span><span class="n">hist_path</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">dxyz</span><span class="p">,</span> <span class="n">regions</span><span class="p">,</span> <span class="n">ibregma</span><span class="p">,</span> <span class="n">dims2xyz</span><span class="o">=</span><span class="n">dims2xyz</span><span class="p">,</span> <span class="n">xyz2dims</span><span class="o">=</span><span class="n">xyz2dims</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_volume</span><span class="p">(</span><span class="n">file_volume</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">file_volume</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s1">&#39;.nrrd&#39;</span><span class="p">:</span>
            <span class="n">volume</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nrrd</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">file_volume</span><span class="p">,</span> <span class="n">index_order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>  <span class="c1"># ml, dv, ap</span>
            <span class="c1"># we want the coronal slice to be the most contiguous</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># image[iap, iml, idv]</span>
        <span class="k">elif</span> <span class="n">file_volume</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s1">&#39;.npz&#39;</span><span class="p">:</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_volume</span><span class="p">)[</span><span class="s1">&#39;arr_0&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">volume</span>

<div class="viewcode-block" id="AllenAtlas.xyz2ccf">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.AllenAtlas.xyz2ccf">[docs]</a>
    <span class="k">def</span> <span class="nf">xyz2ccf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">ccf_order</span><span class="o">=</span><span class="s1">&#39;mlapdv&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts anatomical coordinates to CCF coordinates.</span>

<span class="sd">        Anatomical coordinates are in meters, relative to bregma, which CFF coordinates are</span>
<span class="sd">        assumed to be the volume indices multiplied by the spacing in micormeters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz : numpy.array</span>
<span class="sd">            An N by 3 array of anatomical coordinates in meters, relative to bregma.</span>
<span class="sd">        ccf_order : {&#39;mlapdv&#39;, &#39;apdvml&#39;}, default=&#39;mlapdv&#39;</span>
<span class="sd">            The order of the CCF coordinates returned. For IBL (the default) this is (ML, AP, DV),</span>
<span class="sd">            for Allen MCC vertices, this is (AP, DV, ML).</span>
<span class="sd">        mode : {&#39;raise&#39;, &#39;clip&#39;, &#39;wrap&#39;}, default=&#39;raise&#39;</span>
<span class="sd">            How to behave if the coordinate lies outside of the volume: raise (default) will raise</span>
<span class="sd">            a ValueError; &#39;clip&#39; will replace the index with the closest index inside the volume;</span>
<span class="sd">            &#39;wrap&#39; will return the index as is.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            Coordinates in CCF space (um, origin is the front left top corner of the data</span>
<span class="sd">        volume, order determined by ccf_order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ordre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ccf_order</span><span class="p">(</span><span class="n">ccf_order</span><span class="p">)</span>
        <span class="n">ccf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_um</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ccf</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ordre</span><span class="p">]</span></div>


<div class="viewcode-block" id="AllenAtlas.ccf2xyz">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.AllenAtlas.ccf2xyz">[docs]</a>
    <span class="k">def</span> <span class="nf">ccf2xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ccf</span><span class="p">,</span> <span class="n">ccf_order</span><span class="o">=</span><span class="s1">&#39;mlapdv&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert anatomical coordinates from CCF coordinates.</span>

<span class="sd">        Anatomical coordinates are in meters, relative to bregma, which CFF coordinates are</span>
<span class="sd">        assumed to be the volume indices multiplied by the spacing in micormeters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ccf : numpy.array</span>
<span class="sd">            An N by 3 array of coordinates in CCF space (atlas volume indices * um resolution). The</span>
<span class="sd">            origin is the front left top corner of the data volume.</span>
<span class="sd">        ccf_order : {&#39;mlapdv&#39;, &#39;apdvml&#39;}, default=&#39;mlapdv&#39;</span>
<span class="sd">            The order of the CCF coordinates given. For IBL (the default) this is (ML, AP, DV),</span>
<span class="sd">            for Allen MCC vertices, this is (AP, DV, ML).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            The MLAPDV coordinates in meters, relative to bregma.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ordre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ccf_order</span><span class="p">(</span><span class="n">ccf_order</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">i2xyz</span><span class="p">((</span><span class="n">ccf</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ordre</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_um</span><span class="p">)))</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_ccf_order</span><span class="p">(</span><span class="n">ccf_order</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the mapping to go from CCF coordinates order to the brain atlas xyz</span>
<span class="sd">        :param ccf_order: &#39;mlapdv&#39; or &#39;apdvml&#39;</span>
<span class="sd">        :param reverse: defaults to False.</span>
<span class="sd">            If False, returns from CCF to brain atlas</span>
<span class="sd">            If True, returns from brain atlas to CCF</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ccf_order</span> <span class="o">==</span> <span class="s1">&#39;mlapdv&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">ccf_order</span> <span class="o">==</span> <span class="s1">&#39;apdvml&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ccf_order needs to be either &#39;mlapdv&#39; or &#39;apdvml&#39;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="AllenAtlas.compute_regions_volume">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.AllenAtlas.compute_regions_volume">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_regions_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cumsum</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sums the number of voxels in the labels volume for each region.</span>
<span class="sd">        Then compute volumes for all of the levels of hierarchy in cubic mm.</span>
<span class="sd">        :param: cumsum: computes the cumulative sum of the volume as per the hierarchy (defaults to False)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">minlength</span><span class="o">=</span><span class="n">nr</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cumsum</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_um</span> <span class="o">/</span> <span class="mf">1e3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">compute_hierarchy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nr</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">volume</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])]</span> <span class="o">+=</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">volume</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_um</span> <span class="o">/</span> <span class="mf">1e3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span></div>
</div>



<div class="viewcode-block" id="NeedlesAtlas">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.NeedlesAtlas">[docs]</a>
<span class="k">def</span> <span class="nf">NeedlesAtlas</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AllenAtlas</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instantiates an atlas.BrainAtlas corresponding to the Allen CCF at the given resolution</span>
<span class="sd">    using the IBL Bregma and coordinate system. The Needles atlas defines a stretch along AP</span>
<span class="sd">    axis and a squeeze along the DV axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    res_um : {10, 25, 50} int</span>
<span class="sd">        The Atlas resolution in micrometres; one of 10, 25 or 50um.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        See AllenAtlas.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    AllenAtlas</span>
<span class="sd">        An Allen atlas object with MRI atlas scaling applied.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The scaling was determined by manually transforming the DSURQE atlas [1]_ onto the Allen CCF.</span>
<span class="sd">    The DSURQE atlas is an MRI atlas acquired from 40 C57BL/6J mice post-mortem, with 40um</span>
<span class="sd">    isometric resolution.  The alignment was performed by Mayo Faulkner.</span>
<span class="sd">    The atlas data can be found `here &lt;http://repo.mouseimaging.ca/repo/DSURQE_40micron_nifti/&gt;`__.</span>
<span class="sd">    More information on the dataset and segmentation can be found</span>
<span class="sd">    `here &lt;http://repo.mouseimaging.ca/repo/DSURQE_40micron/notes_on_DSURQE_atlas&gt;`__.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Dorr AE, Lerch JP, Spring S, Kabani N, Henkelman RM (2008). High resolution</span>
<span class="sd">       three-dimensional brain atlas using an average magnetic resonance image of 40 adult C57Bl/6J</span>
<span class="sd">       mice. Neuroimage 42(1):60-9. [doi 10.1016/j.neuroimage.2008.03.037]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DV_SCALE</span> <span class="o">=</span> <span class="mf">0.952</span>  <span class="c1"># multiplicative factor on DV dimension, determined from MRI-&gt;CCF transform</span>
    <span class="n">AP_SCALE</span> <span class="o">=</span> <span class="mf">1.087</span>  <span class="c1"># multiplicative factor on AP dimension</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;scaling&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">AP_SCALE</span><span class="p">,</span> <span class="n">DV_SCALE</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">AllenAtlas</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="MRITorontoAtlas">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.MRITorontoAtlas">[docs]</a>
<span class="k">def</span> <span class="nf">MRITorontoAtlas</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The MRI Toronto brain atlas.</span>

<span class="sd">    Instantiates an atlas.BrainAtlas corresponding to the Allen CCF at the given resolution</span>
<span class="sd">    using the IBL Bregma and coordinate system. The MRI Toronto atlas defines a stretch along AP</span>
<span class="sd">    a squeeze along DV *and* a squeeze along ML. These are based on 12 p65 mice MRIs averaged [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    res_um : {10, 25, 50} int</span>
<span class="sd">        The Atlas resolution in micrometres; one of 10, 25 or 50um.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        See AllenAtlas.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    AllenAtlas</span>
<span class="sd">        An Allen atlas object with MRI atlas scaling applied.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Qiu, LR, Fernandes, DJ, Szulc-Lerch, KU et al. (2018) Mouse MRI shows brain areas</span>
<span class="sd">       relatively larger in males emerge before those larger in females. Nat Commun 9, 2615.</span>
<span class="sd">       [doi 10.1038/s41467-018-04921-2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ML_SCALE</span> <span class="o">=</span> <span class="mf">0.952</span>
    <span class="n">DV_SCALE</span> <span class="o">=</span> <span class="mf">0.885</span>  <span class="c1"># multiplicative factor on DV dimension, determined from MRI-&gt;CCF transform</span>
    <span class="n">AP_SCALE</span> <span class="o">=</span> <span class="mf">1.031</span>  <span class="c1"># multiplicative factor on AP dimension</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;scaling&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ML_SCALE</span><span class="p">,</span> <span class="n">AP_SCALE</span><span class="p">,</span> <span class="n">DV_SCALE</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">AllenAtlas</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_download_atlas_allen</span><span class="p">(</span><span class="n">target_file_image</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Download the Allen Atlas from the alleninstitute.org Website.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_file_image : str, pathlib.Path</span>
<span class="sd">        The full target file path to which to download the file. The name of the image file name</span>
<span class="sd">         must be either `average_template_&lt;res&gt;.nrrd` or `annotation_&lt;res&gt;.nrrd`, where &lt;res&gt; is</span>
<span class="sd">         one of {10, 25, 50}.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pathlib.Path</span>
<span class="sd">        The full path to the downloaded file.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    -  2015 Allen Institute for Brain Science. Allen Mouse Brain Atlas (2015) with region annotations (2017).</span>
<span class="sd">    - Available from: http://download.alleninstitute.org/informatics-archive/current-release/mouse_ccf/annotation/</span>
<span class="sd">    - See Allen Mouse Common Coordinate Framework Technical White Paper for details</span>
<span class="sd">      http://help.brain-map.org/download/attachments/8323525/Mouse_Common_Coordinate_Framework.pdf</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">target_file_image</span> <span class="o">:=</span> <span class="n">Path</span><span class="p">(</span><span class="n">target_file_image</span><span class="p">))</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ROOT_URL</span> <span class="o">=</span> <span class="s1">&#39;http://download.alleninstitute.org/informatics-archive/&#39;</span>

    <span class="k">if</span> <span class="n">target_file_image</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span>
        <span class="n">url</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ROOT_URL</span><span class="si">}</span><span class="s1">current-release/mouse_ccf/average_template/&#39;</span>
    <span class="k">elif</span> <span class="n">target_file_image</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;annotation&#39;</span><span class="p">:</span>
        <span class="n">url</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ROOT_URL</span><span class="si">}</span><span class="s1">current-release/mouse_ccf/annotation/ccf_2017/&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unrecognized file image&#39;</span><span class="p">)</span>
    <span class="n">url</span> <span class="o">+=</span> <span class="n">target_file_image</span><span class="o">.</span><span class="n">name</span>

    <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">http_download_file</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">target_dir</span><span class="o">=</span><span class="n">target_file_image</span><span class="o">.</span><span class="n">parent</span><span class="p">))</span>


<div class="viewcode-block" id="FranklinPaxinosAtlas">
<a class="viewcode-back" href="../../_autosummary/iblatlas.atlas.html#iblatlas.atlas.FranklinPaxinosAtlas">[docs]</a>
<span class="k">class</span> <span class="nc">FranklinPaxinosAtlas</span><span class="p">(</span><span class="n">BrainAtlas</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;pathlib.PurePosixPath: The default relative path of the atlas file.&quot;&quot;&quot;</span>
    <span class="n">atlas_rel_path</span> <span class="o">=</span> <span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">&#39;histology&#39;</span><span class="p">,</span> <span class="s1">&#39;ATLAS&#39;</span><span class="p">,</span> <span class="s1">&#39;Needles&#39;</span><span class="p">,</span> <span class="s1">&#39;FranklinPaxinos&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res_um</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">scaling</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">mock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">hist_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The Franklin &amp; Paxinos brain atlas.</span>

<span class="sd">        Instantiates an atlas.BrainAtlas corresponding to the Franklin &amp; Paxinos atlas [1]_ at the</span>
<span class="sd">        given resolution, matched to the Allen coordinate Framework [2]_ and using the IBL Bregma</span>
<span class="sd">        and coordinate system. The Franklin Paxisnos volume has resolution of 10um in ML and DV</span>
<span class="sd">        axis and 100 um in AP direction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        res_um : list, numpy.array</span>
<span class="sd">            The Atlas resolution in micometres in each dimension.</span>
<span class="sd">        scaling : float, numpy.array</span>
<span class="sd">            Scale factor along ml, ap, dv for squeeze and stretch (default: [1, 1, 1]).</span>
<span class="sd">        mock : bool</span>
<span class="sd">            For testing purposes, return atlas object with image comprising zeros.</span>
<span class="sd">        hist_path : str, pathlib.Path</span>
<span class="sd">            The location of the image volume. May be a full file path or a directory.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Instantiate Atlas from a non-default location, in this case the cache_dir of an ONE instance.</span>
<span class="sd">        &gt;&gt;&gt; target_dir = one.cache_dir / AllenAtlas.atlas_rel_path</span>
<span class="sd">        ... ba = FranklinPaxinosAtlas(hist_path=target_dir)</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Paxinos G, and Franklin KBJ (2012) The Mouse Brain in Stereotaxic Coordinates, 4th</span>
<span class="sd">        edition (Elsevier Academic Press)</span>
<span class="sd">        .. [2] Chon U et al (2019) Enhanced and unified anatomical labeling for a common mouse</span>
<span class="sd">        brain atlas [doi 10.1038/s41467-019-13057-w]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO interpolate?</span>
        <span class="n">LUT_VERSION</span> <span class="o">=</span> <span class="s1">&#39;v01&#39;</span>  <span class="c1"># version 01 is the lateralized version</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="n">FranklinPaxinosRegions</span><span class="p">()</span>
        <span class="n">xyz2dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># this is the c-contiguous ordering</span>
        <span class="n">dims2xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="c1"># we use Bregma as the origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_um</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">res_um</span><span class="p">)</span>
        <span class="n">ibregma</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAXINOS_CCF_LANDMARKS_MLAPDV_UM</span><span class="p">[</span><span class="s1">&#39;bregma&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_um</span><span class="p">)</span>
        <span class="n">dxyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_um</span> <span class="o">*</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">scaling</span>
        <span class="k">if</span> <span class="n">mock</span><span class="p">:</span>
            <span class="n">image</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">528</span><span class="p">,</span> <span class="mi">456</span><span class="p">,</span> <span class="mi">320</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
            <span class="n">label</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">100</span><span class="p">:</span><span class="mi">105</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1327</span>  <span class="c1"># lookup index for retina, id 304325711 (no id 1327)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Hist path may be a full path to an existing image file, or a path to a directory</span>
            <span class="n">cache_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">one</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">silent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">CACHE_DIR</span><span class="p">)</span>
            <span class="n">hist_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">hist_path</span> <span class="ow">or</span> <span class="n">cache_dir</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atlas_rel_path</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hist_path</span><span class="o">.</span><span class="n">suffix</span><span class="p">:</span>  <span class="c1"># check if folder</span>
                <span class="n">hist_path</span> <span class="o">/=</span> <span class="sa">f</span><span class="s1">&#39;average_template_</span><span class="si">{</span><span class="n">res_um</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">res_um</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">res_um</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1">.npz&#39;</span>

            <span class="c1"># get the image volume</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hist_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">hist_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">aws</span><span class="o">.</span><span class="n">s3_download_file</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;atlas/FranklinPaxinos/</span><span class="si">{</span><span class="n">hist_path</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">hist_path</span><span class="p">))</span>
            <span class="c1"># get the remapped label volume</span>
            <span class="n">file_label</span> <span class="o">=</span> <span class="n">hist_path</span><span class="o">.</span><span class="n">with_name</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;annotation_</span><span class="si">{</span><span class="n">res_um</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">res_um</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">res_um</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1">.npz&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_label</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">file_label</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">aws</span><span class="o">.</span><span class="n">s3_download_file</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;atlas/FranklinPaxinos/</span><span class="si">{</span><span class="n">file_label</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">file_label</span><span class="p">))</span>

            <span class="n">file_label_remap</span> <span class="o">=</span> <span class="n">hist_path</span><span class="o">.</span><span class="n">with_name</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;annotation_</span><span class="si">{</span><span class="n">res_um</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">res_um</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">res_um</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1">_lut_</span><span class="si">{</span><span class="n">LUT_VERSION</span><span class="si">}</span><span class="s1">.npz&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_label_remap</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_volume</span><span class="p">(</span><span class="n">file_label</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;computing brain atlas annotations lookup table&quot;</span><span class="p">)</span>
                <span class="c1"># lateralize atlas: for this the regions of the left hemisphere have primary</span>
                <span class="c1"># keys opposite to to the normal ones</span>
                <span class="n">lateral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">lateral</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">ibregma</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">lateral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">lateral</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">label</span> <span class="o">*</span> <span class="n">lateral</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">ismember</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">regions</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">),</span> <span class="n">label</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">file_label_remap</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cached remapping file </span><span class="si">{</span><span class="n">file_label_remap</span><span class="si">}</span><span class="s2"> ...&quot;</span><span class="p">)</span>
            <span class="c1"># loads the files</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_volume</span><span class="p">(</span><span class="n">file_label_remap</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_volume</span><span class="p">(</span><span class="n">hist_path</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">dxyz</span><span class="p">,</span> <span class="n">regions</span><span class="p">,</span> <span class="n">ibregma</span><span class="p">,</span> <span class="n">dims2xyz</span><span class="o">=</span><span class="n">dims2xyz</span><span class="p">,</span> <span class="n">xyz2dims</span><span class="o">=</span><span class="n">xyz2dims</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_volume</span><span class="p">(</span><span class="n">file_volume</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads an atlas image volume given a file path.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_volume : pathlib.Path</span>
<span class="sd">            The file path of an image volume.  Currently supports .nrrd and .npz files.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            The loaded image volume with dimensions (ap, ml, dv).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Unknown file extension, expects either &#39;.nrrd&#39; or &#39;.npz&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">file_volume</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s1">&#39;.nrrd&#39;</span><span class="p">:</span>
            <span class="n">volume</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nrrd</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">file_volume</span><span class="p">,</span> <span class="n">index_order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>  <span class="c1"># ml, dv, ap</span>
            <span class="c1"># we want the coronal slice to be the most contiguous</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># image[iap, iml, idv]</span>
        <span class="k">elif</span> <span class="n">file_volume</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s1">&#39;.npz&#39;</span><span class="p">:</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_volume</span><span class="p">)[</span><span class="s1">&#39;arr_0&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">file_volume</span><span class="o">.</span><span class="n">suffix</span><span class="si">}</span><span class="s1">&quot; files not supported, must be either &quot;.nrrd&quot; or &quot;.npz&quot;&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">volume</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, International Brain Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>