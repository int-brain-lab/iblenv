<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>brainbox.metrics.single_units &mdash; IBL Library  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/style.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> IBL Library
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">The Open Neurophysiology Environment</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks_external/one_quickstart.html">ONE Quick Start</a></li>
<li class="toctree-l1"><a class="reference external" href="https://int-brain-lab.github.io/ONE/">Full documentation Website for ONE</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">DataJoint</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dj_docs/dj_introduction.html">Introduction to DataJoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dj_docs/dj_public.html">Publicly available IBL data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dj_docs/dj_credentials.html">DataJoint credentials for internal IBL users</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Public</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../public_docs/public_introduction.html">Publicly available IBL data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exploring IBL Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../loading_examples.html">Loading Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Miscellaneous</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../02_installation.html">Unified Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../09_contribution.html">How to contribute</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples &amp; Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../06_examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/dj_intro/dj_intro.html">Datajoint Introductory Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/dj_basics/dj_basics.html">Exploring the IBL Data Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks_external/docs_wheel_moves.html">Working with wheel data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../010_api_reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Detailed Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">IBL Library</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>brainbox.metrics.single_units</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for brainbox.metrics.single_units</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Computes metrics for assessing quality of single units.</span>

<span class="sd">Run the following to set-up the workspace to run the docstring examples:</span>
<span class="sd">&gt;&gt;&gt; import brainbox as bb</span>
<span class="sd">&gt;&gt;&gt; import alf.io as aio</span>
<span class="sd">&gt;&gt;&gt; import numpy as np</span>
<span class="sd">&gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">&gt;&gt;&gt; import ibllib.ephys.spikes as e_spks</span>
<span class="sd"># (*Note, if there is no &#39;alf&#39; directory, make &#39;alf&#39; directory from &#39;ks2&#39; output directory):</span>
<span class="sd">&gt;&gt;&gt; e_spks.ks2_to_alf(path_to_ks_out, path_to_alf_out)</span>
<span class="sd"># Load the alf spikes bunch and clusters bunch, and get a units bunch.</span>
<span class="sd">&gt;&gt;&gt; spks_b = aio.load_object(path_to_alf_out, &#39;spikes&#39;)</span>
<span class="sd">&gt;&gt;&gt; clstrs_b = aio.load_object(path_to_alf_out, &#39;clusters&#39;)</span>
<span class="sd">&gt;&gt;&gt; units_b = bb.processing.get_units_bunch(spks_b)  # may take a few mins to compute</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage.filters</span> <span class="k">as</span> <span class="nn">filters</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">ibllib.io</span> <span class="kn">import</span> <span class="n">spikeglx</span>
<span class="kn">from</span> <span class="nn">phylib.stats</span> <span class="kn">import</span> <span class="n">correlograms</span>
<span class="kn">from</span> <span class="nn">iblutil.util</span> <span class="kn">import</span> <span class="n">Bunch</span>
<span class="kn">from</span> <span class="nn">iblutil.numerical</span> <span class="kn">import</span> <span class="n">ismember</span><span class="p">,</span> <span class="n">between_sorted</span>
<span class="kn">from</span> <span class="nn">brainbox</span> <span class="kn">import</span> <span class="n">singlecell</span>
<span class="kn">from</span> <span class="nn">brainbox.io.spikeglx</span> <span class="kn">import</span> <span class="n">extract_waveforms</span>
<span class="kn">from</span> <span class="nn">brainbox.processing</span> <span class="kn">import</span> <span class="n">bincount2D</span>
<span class="kn">from</span> <span class="nn">brainbox.metrics</span> <span class="kn">import</span> <span class="n">electrode_drift</span>


<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;ibllib&#39;</span><span class="p">)</span>

<span class="c1"># Parameters to be used in `quick_unit_metrics`</span>
<span class="n">METRICS_PARAMS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;acceptable_contamination&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="s1">&#39;bin_size&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">,</span>
    <span class="s1">&#39;med_amp_thresh_uv&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
    <span class="s1">&#39;min_isi&#39;</span><span class="p">:</span> <span class="mf">0.0001</span><span class="p">,</span>
    <span class="s1">&#39;min_num_bins_for_missed_spks_est&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
    <span class="s1">&#39;nc_bins&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
    <span class="s1">&#39;nc_n_low_bins&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s1">&#39;nc_quartile_length&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="s1">&#39;nc_thresh&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="s1">&#39;presence_window&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;refractory_period&#39;</span><span class="p">:</span> <span class="mf">0.0015</span><span class="p">,</span>
    <span class="s1">&#39;RPslide_thresh&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="s1">&#39;spks_per_bin_for_missed_spks_est&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;std_smoothing_kernel_for_missed_spks_est&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="unit_stability"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.unit_stability">[docs]</a><span class="k">def</span> <span class="nf">unit_stability</span><span class="p">(</span><span class="n">units_b</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">feat_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;amps&#39;</span><span class="p">],</span> <span class="n">dist</span><span class="o">=</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="s1">&#39;ks&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the probability that the empirical spike feature distribution(s), for specified</span>
<span class="sd">    feature(s), for all units, comes from a specific theoretical distribution, based on a specified</span>
<span class="sd">    statistical test. Also computes the coefficients of variation of the spike feature(s) for all</span>
<span class="sd">    units.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    units_b : bunch</span>
<span class="sd">        A units bunch containing fields with spike information (e.g. cluster IDs, times, features,</span>
<span class="sd">        etc.) for all units.</span>
<span class="sd">    units : array-like (optional)</span>
<span class="sd">        A subset of all units for which to create the bar plot. (If `None`, all units are used)</span>
<span class="sd">    feat_names : list of strings (optional)</span>
<span class="sd">        A list of names of spike features that can be found in `spks` to specify which features to</span>
<span class="sd">        use for calculating unit stability.</span>
<span class="sd">    dist : string (optional)</span>
<span class="sd">        The type of hypothetical null distribution for which the empirical spike feature</span>
<span class="sd">        distributions are presumed to belong to.</span>
<span class="sd">    test : string (optional)</span>
<span class="sd">        The statistical test used to compute the probability that the empirical spike feature</span>
<span class="sd">        distributions come from `dist`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    p_vals_b : bunch</span>
<span class="sd">        A bunch with `feat_names` as keys, containing a ndarray with p-values (the probabilities</span>
<span class="sd">        that the empirical spike feature distribution for each unit comes from `dist` based on</span>
<span class="sd">        `test`) for each unit for all `feat_names`.</span>
<span class="sd">    cv_b : bunch</span>
<span class="sd">        A bunch with `feat_names` as keys, containing a ndarray with the coefficients of variation</span>
<span class="sd">        of each unit&#39;s empirical spike feature distribution for all features.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    plot.feat_vars</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1) Compute 1) the p-values obtained from running a one-sample ks test on the spike amplitudes</span>
<span class="sd">    for each unit, and 2) the variances of the empirical spike amplitudes distribution for each</span>
<span class="sd">    unit. Create a histogram of the variances of the spike amplitudes for each unit, color-coded by</span>
<span class="sd">    depth of channel of max amplitudes. Get cluster IDs of those units which have variances greater</span>
<span class="sd">    than 50.</span>
<span class="sd">        &gt;&gt;&gt; p_vals_b, variances_b = bb.metrics.unit_stability(units_b)</span>
<span class="sd">        # Plot histograms of variances color-coded by depth of channel of max amplitudes</span>
<span class="sd">        &gt;&gt;&gt; fig = bb.plot.feat_vars(units_b, feat_name=&#39;amps&#39;)</span>
<span class="sd">        # Get all unit IDs which have amps variance &gt; 50</span>
<span class="sd">        &gt;&gt;&gt; var_vals = np.array(tuple(variances_b[&#39;amps&#39;].values()))</span>
<span class="sd">        &gt;&gt;&gt; bad_units = np.where(var_vals &gt; 50)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get units.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>  <span class="c1"># we&#39;re using a subset of all units</span>
        <span class="n">unit_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">units_b</span><span class="p">[</span><span class="n">feat_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># for each `feat` and unit in `unit_list`, remove unit from `units_b` if not in `units`</span>
        <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">feat_names</span><span class="p">:</span>
            <span class="p">[</span><span class="n">units_b</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">unit_list</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span> <span class="ow">in</span> <span class="n">units</span><span class="p">)]</span>
    <span class="n">unit_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">units_b</span><span class="p">[</span><span class="n">feat_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>  <span class="c1"># get new `unit_list` after removing units</span>

    <span class="c1"># Initialize `p_vals` and `variances`.</span>
    <span class="n">p_vals_b</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">()</span>
    <span class="n">cv_b</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">()</span>

    <span class="c1"># Set the test as a lambda function (in future, more tests can be added to this dict)</span>
    <span class="n">tests</span> <span class="o">=</span> \
        <span class="p">{</span>
            <span class="s1">&#39;ks&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">stats</span><span class="o">.</span><span class="n">kstest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="n">test_fun</span> <span class="o">=</span> <span class="n">tests</span><span class="p">[</span><span class="n">test</span><span class="p">]</span>

    <span class="c1"># Compute the statistical tests and variances. For each feature, iteratively get each unit&#39;s</span>
    <span class="c1"># p-values and variances, and add them as keys to the respective bunches `p_vals_feat` and</span>
    <span class="c1"># `variances_feat`. After iterating through all units, add these bunches as keys to their</span>
    <span class="c1"># respective parent bunches, `p_vals` and `variances`.</span>
    <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">feat_names</span><span class="p">:</span>
        <span class="n">p_vals_feat</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">((</span><span class="n">unit</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">unit_list</span><span class="p">)</span>
        <span class="n">cv_feat</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">((</span><span class="n">unit</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">unit_list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">unit_list</span><span class="p">:</span>
            <span class="c1"># If we&#39;re missing units/features, create a NaN placeholder and skip them:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">units_b</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">unit</span><span class="p">)])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">p_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">cv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># compute p_val and var for current feature</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">p_val</span> <span class="o">=</span> <span class="n">test_fun</span><span class="p">(</span><span class="n">units_b</span><span class="p">[</span><span class="n">feat</span><span class="p">][</span><span class="n">unit</span><span class="p">],</span> <span class="n">dist</span><span class="p">)</span>
                <span class="n">cv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">units_b</span><span class="p">[</span><span class="n">feat</span><span class="p">][</span><span class="n">unit</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">units_b</span><span class="p">[</span><span class="n">feat</span><span class="p">][</span><span class="n">unit</span><span class="p">])</span>
            <span class="c1"># Append current unit&#39;s values to list of units&#39; values for current feature:</span>
            <span class="n">p_vals_feat</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">unit</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p_val</span>
            <span class="n">cv_feat</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">unit</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cv</span>
        <span class="n">p_vals_b</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_vals_feat</span>
        <span class="n">cv_b</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv_feat</span>

    <span class="k">return</span> <span class="n">p_vals_b</span><span class="p">,</span> <span class="n">cv_b</span></div>


<div class="viewcode-block" id="missed_spikes_est"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.missed_spikes_est">[docs]</a><span class="k">def</span> <span class="nf">missed_spikes_est</span><span class="p">(</span><span class="n">feat</span><span class="p">,</span> <span class="n">spks_per_bin</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">min_num_bins</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the approximate fraction of spikes missing from a spike feature distribution for a</span>
<span class="sd">    given unit, assuming the distribution is symmetric.</span>
<span class="sd">    Inspired by metric described in Hill et al. (2011) J Neurosci 31: 8699-8705.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    feat : ndarray</span>
<span class="sd">        The spikes&#39; feature values (e.g. amplitudes)</span>
<span class="sd">    spks_per_bin : int (optional)</span>
<span class="sd">        The number of spikes per bin from which to compute the spike feature histogram.</span>
<span class="sd">    sigma : int (optional)</span>
<span class="sd">        The standard deviation for the gaussian kernel used to compute the pdf from the spike</span>
<span class="sd">        feature histogram.</span>
<span class="sd">    min_num_bins : int (optional)</span>
<span class="sd">        The minimum number of bins used to compute the spike feature histogram.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fraction_missing : float</span>
<span class="sd">        The fraction of missing spikes (0-0.5). *Note: If more than 50% of spikes are missing, an</span>
<span class="sd">        accurate estimate isn&#39;t possible.</span>
<span class="sd">    pdf : ndarray</span>
<span class="sd">        The computed pdf of the spike feature histogram.</span>
<span class="sd">    cutoff_idx : int</span>
<span class="sd">        The index for `pdf` at which point `pdf` is no longer symmetrical around the peak. (This</span>
<span class="sd">        is returned for plotting purposes).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    plot.feat_cutoff</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1) Determine the fraction of spikes missing from unit 1 based on the recorded unit&#39;s spike</span>
<span class="sd">    amplitudes, assuming the distribution of the unit&#39;s spike amplitudes is symmetric.</span>
<span class="sd">        # Get unit 1 amplitudes from a unit bunch, and compute fraction spikes missing.</span>
<span class="sd">        &gt;&gt;&gt; feat = units_b[&#39;amps&#39;][&#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; fraction_missing = bb.plot.feat_cutoff(feat)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ensure minimum number of spikes requirement is met, return Nan otherwise</span>
    <span class="k">if</span> <span class="n">feat</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">spks_per_bin</span> <span class="o">*</span> <span class="n">min_num_bins</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1"># compute the spike feature histogram and pdf:</span>
    <span class="n">num_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">feat</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">spks_per_bin</span><span class="p">)</span>
    <span class="n">hist</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">feat</span><span class="p">,</span> <span class="n">num_bins</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pdf</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">gaussian_filter1d</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>

    <span class="c1"># Find where the distribution stops being symmetric around the peak:</span>
    <span class="n">peak_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
    <span class="n">max_idx_sym_around_peak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="n">peak_idx</span><span class="p">:]</span> <span class="o">-</span> <span class="n">pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">cutoff_idx</span> <span class="o">=</span> <span class="n">peak_idx</span> <span class="o">+</span> <span class="n">max_idx_sym_around_peak</span>

    <span class="c1"># compute fraction missing from the tail of the pdf (the area where pdf stops being</span>
    <span class="c1"># symmetric around peak).</span>
    <span class="n">fraction_missing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="n">cutoff_idx</span><span class="p">:])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
    <span class="n">fraction_missing</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="k">if</span> <span class="p">(</span><span class="n">fraction_missing</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="k">else</span> <span class="n">fraction_missing</span>

    <span class="k">return</span> <span class="n">fraction_missing</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">cutoff_idx</span></div>


<div class="viewcode-block" id="wf_similarity"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.wf_similarity">[docs]</a><span class="k">def</span> <span class="nf">wf_similarity</span><span class="p">(</span><span class="n">wf1</span><span class="p">,</span> <span class="n">wf2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes a unit normalized spatiotemporal similarity score between two sets of waveforms.</span>
<span class="sd">    This score is based on how waveform shape correlates for each pair of spikes between the</span>
<span class="sd">    two sets of waveforms across space and time. The shapes of the arrays of the two sets of</span>
<span class="sd">    waveforms must be equal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wf1 : ndarray</span>
<span class="sd">        An array of shape (#spikes, #samples, #channels).</span>
<span class="sd">    wf2 : ndarray</span>
<span class="sd">        An array of shape (#spikes, #samples, #channels).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    s: float</span>
<span class="sd">        The unit normalized spatiotemporal similarity score.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    io.extract_waveforms</span>
<span class="sd">    plot.single_unit_wf_comp</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1) Compute the similarity between the first and last 100 waveforms for unit1, across the 20</span>
<span class="sd">    channels around the channel of max amplitude.</span>
<span class="sd">        # Get the channels around the max amp channel for the unit, two sets of timestamps for the</span>
<span class="sd">        # unit, and the two corresponding sets of waveforms for those two sets of timestamps.</span>
<span class="sd">        # Then compute `s`.</span>
<span class="sd">        &gt;&gt;&gt; max_ch = clstrs_b[&#39;channels&#39;][1]</span>
<span class="sd">        &gt;&gt;&gt; if max_ch &lt; 10:  # take only channels greater than `max_ch`.</span>
<span class="sd">        &gt;&gt;&gt;     ch = np.arange(max_ch, max_ch + 20)</span>
<span class="sd">        &gt;&gt;&gt; elif (max_ch + 10) &gt; 385:  # take only channels less than `max_ch`.</span>
<span class="sd">        &gt;&gt;&gt;    ch = np.arange(max_ch - 20, max_ch)</span>
<span class="sd">        &gt;&gt;&gt; else:  # take `n_c_ch` around `max_ch`.</span>
<span class="sd">        &gt;&gt;&gt;     ch = np.arange(max_ch - 10, max_ch + 10)</span>
<span class="sd">        &gt;&gt;&gt; ts1 = units_b[&#39;times&#39;][&#39;1&#39;][:100]</span>
<span class="sd">        &gt;&gt;&gt; ts2 = units_b[&#39;times&#39;][&#39;1&#39;][-100:]</span>
<span class="sd">        &gt;&gt;&gt; wf1 = bb.io.extract_waveforms(path_to_ephys_file, ts1, ch)</span>
<span class="sd">        &gt;&gt;&gt; wf2 = bb.io.extract_waveforms(path_to_ephys_file, ts2, ch)</span>
<span class="sd">        &gt;&gt;&gt; s = bb.metrics.wf_similarity(wf1, wf2)</span>

<span class="sd">    TODO check `s` calculation:</span>
<span class="sd">    take median of waveforms</span>
<span class="sd">    xcorr all waveforms with median, and divide by autocorr of all waveforms</span>
<span class="sd">    profile</span>
<span class="sd">    for two sets of units: xcorr(cl1, cl2) / (sqrt autocorr(cl1) * autocorr(cl2))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Remove warning for dividing by 0 when calculating `s` (this is resolved by using</span>
    <span class="c1"># `np.nan_to_num`)</span>
    <span class="kn">import</span> <span class="nn">warnings</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;invalid value encountered in true_divide&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">wf1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">wf2</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;The shapes of the sets of waveforms are inconsistent (</span><span class="si">{}</span><span class="s1">)&#39;</span>
                                    <span class="s1">&#39;(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wf1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">wf2</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Get number of spikes, samples, and channels of waveforms.</span>
    <span class="n">n_spks</span> <span class="o">=</span> <span class="n">wf1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">wf1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_ch</span> <span class="o">=</span> <span class="n">wf1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Create a matrix that will hold the similarity values of each spike in `wf1` to `wf2`.</span>
    <span class="c1"># Iterate over both sets of spikes, computing `s` for each pair.</span>
    <span class="n">similarity_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_spks</span><span class="p">,</span> <span class="n">n_spks</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">spk1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_spks</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">spk2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_spks</span><span class="p">):</span>
            <span class="n">s_spk</span> <span class="o">=</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span>
                    <span class="n">wf1</span><span class="p">[</span><span class="n">spk1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">wf2</span><span class="p">[</span><span class="n">spk2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">/</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">wf1</span><span class="p">[</span><span class="n">spk1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">wf2</span><span class="p">[</span><span class="n">spk2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_samples</span> <span class="o">*</span> <span class="n">n_ch</span><span class="p">)</span>
            <span class="n">similarity_matrix</span><span class="p">[</span><span class="n">spk1</span><span class="p">,</span> <span class="n">spk2</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_spk</span>

    <span class="c1"># Return mean of similarity matrix</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">similarity_matrix</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span></div>


<div class="viewcode-block" id="firing_rate_coeff_var"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.firing_rate_coeff_var">[docs]</a><span class="k">def</span> <span class="nf">firing_rate_coeff_var</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">hist_win</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">fr_win</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">n_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Computes the coefficient of variation of the firing rate: the ratio of the standard</span>
<span class="sd">    deviation to the mean.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : ndarray</span>
<span class="sd">        The spike timestamps from which to compute the firing rate.</span>
<span class="sd">    hist_win : float (optional)</span>
<span class="sd">        The time window (in s) to use for computing spike counts.</span>
<span class="sd">    fr_win : float (optional)</span>
<span class="sd">        The time window (in s) to use as a moving slider to compute the instantaneous firing rate.</span>
<span class="sd">    n_bins : int (optional)</span>
<span class="sd">        The number of bins in which to compute a coefficient of variation of the firing rate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cv : float</span>
<span class="sd">        The mean coefficient of variation of the firing rate of the `n_bins` number of coefficients</span>
<span class="sd">        computed.</span>
<span class="sd">    cvs : ndarray</span>
<span class="sd">        The coefficients of variation of the firing for each bin of `n_bins`.</span>
<span class="sd">    fr : ndarray</span>
<span class="sd">        The instantaneous firing rate over time (in hz).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    singlecell.firing_rate</span>
<span class="sd">    plot.firing_rate</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1) Compute the coefficient of variation of the firing rate for unit 1 from the time of its</span>
<span class="sd">    first to last spike, and compute the coefficient of variation of the firing rate for unit 2</span>
<span class="sd">    from the first to second minute.</span>
<span class="sd">        &gt;&gt;&gt; ts_1 = units_b[&#39;times&#39;][&#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; ts_2 = units_b[&#39;times&#39;][&#39;2&#39;]</span>
<span class="sd">        &gt;&gt;&gt; ts_2 = np.intersect1d(np.where(ts_2 &gt; 60)[0], np.where(ts_2 &lt; 120)[0])</span>
<span class="sd">        &gt;&gt;&gt; cv, cvs, fr = bb.metrics.firing_rate_coeff_var(ts_1)</span>
<span class="sd">        &gt;&gt;&gt; cv_2, cvs_2, fr_2 = bb.metrics.firing_rate_coeff_var(ts_2)</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Compute overall instantaneous firing rate and firing rate for each bin.</span>
    <span class="n">fr</span> <span class="o">=</span> <span class="n">singlecell</span><span class="o">.</span><span class="n">firing_rate</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">hist_win</span><span class="o">=</span><span class="n">hist_win</span><span class="p">,</span> <span class="n">fr_win</span><span class="o">=</span><span class="n">fr_win</span><span class="p">)</span>
    <span class="n">bin_sz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fr</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">n_bins</span><span class="p">)</span>
    <span class="n">fr_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fr</span><span class="p">[(</span><span class="n">b</span> <span class="o">*</span> <span class="n">bin_sz</span><span class="p">):(</span><span class="n">b</span> <span class="o">*</span> <span class="n">bin_sz</span> <span class="o">+</span> <span class="n">bin_sz</span><span class="p">)]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)])</span>

    <span class="c1"># Compute coefficient of variations of firing rate for each bin, and the mean c.v.</span>
    <span class="n">cvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">fr_binned</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fr_binned</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># NaNs from zero spikes are turned into 0&#39;s</span>
    <span class="c1"># cvs[np.isnan(cvs)] = 0 nan&#39;s can happen if neuron doesn&#39;t spike in a bin</span>
    <span class="n">cv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cvs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cv</span><span class="p">,</span> <span class="n">cvs</span><span class="p">,</span> <span class="n">fr</span></div>


<div class="viewcode-block" id="firing_rate_fano_factor"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.firing_rate_fano_factor">[docs]</a><span class="k">def</span> <span class="nf">firing_rate_fano_factor</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">hist_win</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">fr_win</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">n_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Computes the fano factor of the firing rate: the ratio of the variance to the mean.</span>
<span class="sd">    (Almost identical to coeff. of variation)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : ndarray</span>
<span class="sd">        The spike timestamps from which to compute the firing rate.</span>
<span class="sd">    hist_win : float</span>
<span class="sd">        The time window (in s) to use for computing spike counts.</span>
<span class="sd">    fr_win : float</span>
<span class="sd">        The time window (in s) to use as a moving slider to compute the instantaneous firing rate.</span>
<span class="sd">    n_bins : int (optional)</span>
<span class="sd">        The number of bins in which to compute a fano factor of the firing rate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ff : float</span>
<span class="sd">        The mean fano factor of the firing rate of the `n_bins` number of factors</span>
<span class="sd">        computed.</span>
<span class="sd">    ffs : ndarray</span>
<span class="sd">        The fano factors of the firing for each bin of `n_bins`.</span>
<span class="sd">    fr : ndarray</span>
<span class="sd">        The instantaneous firing rate over time (in hz).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    singlecell.firing_rate</span>
<span class="sd">    plot.firing_rate</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1) Compute the fano factor of the firing rate for unit 1 from the time of its</span>
<span class="sd">    first to last spike, and compute the fano factor of the firing rate for unit 2</span>
<span class="sd">    from the first to second minute.</span>
<span class="sd">        &gt;&gt;&gt; ts_1 = units_b[&#39;times&#39;][&#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; ts_2 = units_b[&#39;times&#39;][&#39;2&#39;]</span>
<span class="sd">        &gt;&gt;&gt; ts_2 = np.intersect1d(np.where(ts_2 &gt; 60)[0], np.where(ts_2 &lt; 120)[0])</span>
<span class="sd">        &gt;&gt;&gt; ff, ffs, fr = bb.metrics.firing_rate_fano_factor(ts_1)</span>
<span class="sd">        &gt;&gt;&gt; ff_2, ffs_2, fr_2 = bb.metrics.firing_rate_fano_factor(ts_2)</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Compute overall instantaneous firing rate and firing rate for each bin.</span>
    <span class="n">fr</span> <span class="o">=</span> <span class="n">singlecell</span><span class="o">.</span><span class="n">firing_rate</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">hist_win</span><span class="o">=</span><span class="n">hist_win</span><span class="p">,</span> <span class="n">fr_win</span><span class="o">=</span><span class="n">fr_win</span><span class="p">)</span>
    <span class="c1"># this procedure can cut off data at the end, up to n_bins last timesteps</span>
    <span class="n">bin_sz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fr</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">n_bins</span><span class="p">)</span>
    <span class="n">fr_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fr</span><span class="p">[(</span><span class="n">b</span> <span class="o">*</span> <span class="n">bin_sz</span><span class="p">):(</span><span class="n">b</span> <span class="o">*</span> <span class="n">bin_sz</span> <span class="o">+</span> <span class="n">bin_sz</span><span class="p">)]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)])</span>

    <span class="c1"># Compute fano factor of firing rate for each bin, and the mean fano factor</span>
    <span class="n">ffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">fr_binned</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fr_binned</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># ffs[np.isnan(ffs)] = 0 nan&#39;s can happen if neuron doesn&#39;t spike in a bin</span>
    <span class="n">ff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ffs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ff</span><span class="p">,</span> <span class="n">ffs</span><span class="p">,</span> <span class="n">fr</span></div>


<div class="viewcode-block" id="average_drift"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.average_drift">[docs]</a><span class="k">def</span> <span class="nf">average_drift</span><span class="p">(</span><span class="n">feat</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the cumulative drift (normalized by the total number of spikes) of a spike feature</span>
<span class="sd">    array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    feat : ndarray</span>
<span class="sd">        The spike feature values from which to compute the maximum drift.</span>
<span class="sd">        Usually amplitudes</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cd : float</span>
<span class="sd">        The cumulative drift of the unit.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    max_drift</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1) Get the cumulative depth drift for unit 1.</span>
<span class="sd">        &gt;&gt;&gt; unit_idxs = np.where(spks_b[&#39;clusters&#39;] == 1)[0]</span>
<span class="sd">        &gt;&gt;&gt; depths = spks_b[&#39;depths&#39;][unit_idxs]</span>
<span class="sd">        &gt;&gt;&gt; amps = spks_b[&#39;amps&#39;][unit_idxs]</span>
<span class="sd">        &gt;&gt;&gt; depth_cd = bb.metrics.cum_drift(depths)</span>
<span class="sd">        &gt;&gt;&gt; amp_cd = bb.metrics.cum_drift(amps)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">feat</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">times</span><span class="p">)))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">feat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cd</span></div>


<div class="viewcode-block" id="pres_ratio"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.pres_ratio">[docs]</a><span class="k">def</span> <span class="nf">pres_ratio</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">hist_win</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the presence ratio of spike counts: the number of bins where there is at least one</span>
<span class="sd">    spike, over the total number of bins, given a specified bin width.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : ndarray</span>
<span class="sd">        The spike timestamps from which to compute the presence ratio.</span>
<span class="sd">    hist_win : float (optional)</span>
<span class="sd">        The time window (in s) to use for computing the presence ratio.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pr : float</span>
<span class="sd">        The presence ratio.</span>
<span class="sd">    spks_bins : ndarray</span>
<span class="sd">        The number of spks in each bin.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    plot.pres_ratio</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1) Compute the presence ratio for unit 1, given a window of 10 s.</span>
<span class="sd">        &gt;&gt;&gt; ts = units_b[&#39;times&#39;][&#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; pr, pr_bins = bb.metrics.pres_ratio(ts)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">hist_win</span><span class="p">,</span> <span class="n">hist_win</span><span class="p">)</span>
    <span class="n">spks_bins</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
    <span class="n">pr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spks_bins</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">spks_bins</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pr</span><span class="p">,</span> <span class="n">spks_bins</span></div>


<div class="viewcode-block" id="ptp_over_noise"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.ptp_over_noise">[docs]</a><span class="k">def</span> <span class="nf">ptp_over_noise</span><span class="p">(</span><span class="n">ephys_file</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">30000</span><span class="p">,</span> <span class="n">n_ch_probe</span><span class="o">=</span><span class="mi">385</span><span class="p">,</span> <span class="n">car</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For specified channels, for specified timestamps, computes the mean (peak-to-peak amplitudes /</span>
<span class="sd">    the MADs of the background noise).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ephys_file : string</span>
<span class="sd">        The file path to the binary ephys data.</span>
<span class="sd">    ts : ndarray_like</span>
<span class="sd">        The timestamps (in s) of the spikes.</span>
<span class="sd">    ch : ndarray_like</span>
<span class="sd">        The channels on which to extract the waveforms.</span>
<span class="sd">    t : numeric (optional)</span>
<span class="sd">        The time (in ms) of the waveforms to extract to compute the ptp.</span>
<span class="sd">    sr : int (optional)</span>
<span class="sd">        The sampling rate (in hz) that the ephys data was acquired at.</span>
<span class="sd">    n_ch_probe : int (optional)</span>
<span class="sd">        The number of channels of the recording.</span>
<span class="sd">    car: bool (optional)</span>
<span class="sd">        A flag to perform common-average-referencing before extracting waveforms.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ptp_sigma : ndarray</span>
<span class="sd">        An array containing the mean ptp_over_noise values for the specified `ts` and `ch`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1) Compute ptp_over_noise for all spikes on 20 channels around the channel of max amplitude</span>
<span class="sd">    for unit 1.</span>
<span class="sd">        &gt;&gt;&gt; ts = units_b[&#39;times&#39;][&#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; max_ch = max_ch = clstrs_b[&#39;channels&#39;][1]</span>
<span class="sd">        &gt;&gt;&gt; if max_ch &lt; 10:  # take only channels greater than `max_ch`.</span>
<span class="sd">        &gt;&gt;&gt;     ch = np.arange(max_ch, max_ch + 20)</span>
<span class="sd">        &gt;&gt;&gt; elif (max_ch + 10) &gt; 385:  # take only channels less than `max_ch`.</span>
<span class="sd">        &gt;&gt;&gt;     ch = np.arange(max_ch - 20, max_ch)</span>
<span class="sd">        &gt;&gt;&gt; else:  # take `n_c_ch` around `max_ch`.</span>
<span class="sd">        &gt;&gt;&gt;     ch = np.arange(max_ch - 10, max_ch + 10)</span>
<span class="sd">        &gt;&gt;&gt; p = bb.metrics.ptp_over_noise(ephys_file, ts, ch)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ensure `ch` is ndarray</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">ch</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">ch</span>

    <span class="c1"># Get waveforms.</span>
    <span class="n">wf</span> <span class="o">=</span> <span class="n">extract_waveforms</span><span class="p">(</span><span class="n">ephys_file</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_ch_probe</span><span class="o">=</span><span class="n">n_ch_probe</span><span class="p">,</span> <span class="n">car</span><span class="o">=</span><span class="n">car</span><span class="p">)</span>

    <span class="c1"># Initialize `mean_ptp` based on `ch`, and compute mean ptp of all spikes for each ch.</span>
    <span class="n">mean_ptp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ch</span><span class="o">.</span><span class="n">size</span><span class="p">,))</span>
    <span class="k">for</span> <span class="n">cur_ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="p">):</span>
        <span class="n">mean_ptp</span><span class="p">[</span><span class="n">cur_ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">wf</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">cur_ch</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">wf</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">cur_ch</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Compute MAD for `ch` in chunks.</span>
    <span class="k">with</span> <span class="n">spikeglx</span><span class="o">.</span><span class="n">Reader</span><span class="p">(</span><span class="n">ephys_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">s_reader</span><span class="p">:</span>
        <span class="n">file_m</span> <span class="o">=</span> <span class="n">s_reader</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># the memmapped array</span>
        <span class="n">n_chunk_samples</span> <span class="o">=</span> <span class="mf">5e6</span>  <span class="c1"># number of samples per chunk</span>
        <span class="n">n_chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">file_m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_chunk_samples</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="c1"># Get samples that make up each chunk. e.g. `chunk_sample[1] - chunk_sample[0]` are the</span>
        <span class="c1"># samples that make up the first chunk.</span>
        <span class="n">chunk_sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">file_m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_chunk_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">chunk_sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_sample</span><span class="p">,</span> <span class="n">file_m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Give time estimate for computing MAD.</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">stats</span><span class="o">.</span><span class="n">median_absolute_deviation</span><span class="p">(</span><span class="n">file_m</span><span class="p">[</span><span class="n">chunk_sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">chunk_sample</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ch</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Performing MAD computation. Estimated time is </span><span class="si">{:.2f}</span><span class="s1"> mins.&#39;</span>
              <span class="s1">&#39; (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">n_chunks</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()))</span>
        <span class="c1"># Compute MAD for each chunk, then take the median MAD of all chunks.</span>
        <span class="n">mad_chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_chunks</span><span class="p">,</span> <span class="n">ch</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chunks</span><span class="p">):</span>
            <span class="n">mad_chunks</span><span class="p">[</span><span class="n">chunk</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">median_absolute_deviation</span><span class="p">(</span>
                <span class="n">file_m</span><span class="p">[</span><span class="n">chunk_sample</span><span class="p">[</span><span class="n">chunk</span><span class="p">]:</span><span class="n">chunk_sample</span><span class="p">[</span><span class="n">chunk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ch</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done. (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()))</span>

    <span class="c1"># Return `mean_ptp` over `mad`</span>
    <span class="n">mad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">mad_chunks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ptp_sigma</span> <span class="o">=</span> <span class="n">mean_ptp</span> <span class="o">/</span> <span class="n">mad</span>
    <span class="k">return</span> <span class="n">ptp_sigma</span></div>


<div class="viewcode-block" id="contamination_alt"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.contamination_alt">[docs]</a><span class="k">def</span> <span class="nf">contamination_alt</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">rp</span><span class="o">=</span><span class="mf">0.002</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An estimate of the contamination of the unit (i.e. a pseudo false positive measure) based on</span>
<span class="sd">    the number of spikes, number of isi violations, and time between the first and last spike.</span>
<span class="sd">    (see Hill et al. (2011) J Neurosci 31: 8699-8705).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : ndarray_like</span>
<span class="sd">        The timestamps (in s) of the spikes.</span>
<span class="sd">    rp : float (optional)</span>
<span class="sd">        The refractory period (in s).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ce : float</span>
<span class="sd">        An estimate of the fraction of contamination.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    contamination_alt</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1) Compute contamination estimate for unit 1.</span>
<span class="sd">        &gt;&gt;&gt; ts = units_b[&#39;times&#39;][&#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; ce = bb.metrics.contamination(ts)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get number of spikes, number of isi violations, and time from first to final spike.</span>
    <span class="n">n_spks</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">size</span>
    <span class="n">n_isi_viol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">rp</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># `ce` is min of roots of solved quadratic equation.</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">n_isi_viol</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">rp</span> <span class="o">*</span> <span class="n">n_spks</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># 3rd term in quadratic</span>
    <span class="n">ce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roots</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">])))</span>  <span class="c1"># solve quadratic</span>
    <span class="k">return</span> <span class="n">ce</span></div>


<div class="viewcode-block" id="contamination"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.contamination">[docs]</a><span class="k">def</span> <span class="nf">contamination</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">min_time</span><span class="p">,</span> <span class="n">max_time</span><span class="p">,</span> <span class="n">rp</span><span class="o">=</span><span class="mf">0.002</span><span class="p">,</span> <span class="n">min_isi</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An estimate of the contamination of the unit (i.e. a pseudo false positive measure) based on</span>
<span class="sd">    the number of spikes, number of isi violations, and time between the first and last spike.</span>
<span class="sd">    (see Hill et al. (2011) J Neurosci 31: 8699-8705).</span>

<span class="sd">    Modified by Dan Denman from cortex-lab/sortingQuality GitHub by Nick Steinmetz.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : ndarray_like</span>
<span class="sd">        The timestamps (in s) of the spikes.</span>
<span class="sd">    min_time : float</span>
<span class="sd">        The minimum time (in s) that a potential spike occurred.</span>
<span class="sd">    max_time : float</span>
<span class="sd">        The maximum time (in s) that a potential spike occurred.</span>
<span class="sd">    rp : float (optional)</span>
<span class="sd">        The refractory period (in s).</span>
<span class="sd">    min_isi : float (optional)</span>
<span class="sd">        The minimum interspike-interval (in s) for counting duplicate spikes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ce : float</span>
<span class="sd">        An estimate of the contamination.</span>
<span class="sd">        A perfect unit has a ce = 0</span>
<span class="sd">        A unit with some contamination has a ce &lt; 0.5</span>
<span class="sd">        A unit with lots of contamination has a ce &gt; 1.0</span>
<span class="sd">    num_violations : int</span>
<span class="sd">        The total number of isi violations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    contamination</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1) Compute contamination estimate for unit 1, with a minimum isi for counting duplicate</span>
<span class="sd">    spikes of 0.1 ms.</span>
<span class="sd">        &gt;&gt;&gt; ts = units_b[&#39;times&#39;][&#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; ce = bb.metrics.contamination_alt(ts, min_isi=0.0001)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">duplicate_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">min_isi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">duplicate_spikes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">isis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

    <span class="n">num_spikes</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">size</span>
    <span class="n">num_violations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">isis</span> <span class="o">&lt;</span> <span class="n">rp</span><span class="p">)</span>
    <span class="n">violation_time</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_spikes</span> <span class="o">*</span> <span class="p">(</span><span class="n">rp</span> <span class="o">-</span> <span class="n">min_isi</span><span class="p">)</span>
    <span class="n">total_rate</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_time</span> <span class="o">-</span> <span class="n">min_time</span><span class="p">)</span>
    <span class="n">violation_rate</span> <span class="o">=</span> <span class="n">num_violations</span> <span class="o">/</span> <span class="n">violation_time</span>
    <span class="n">ce</span> <span class="o">=</span> <span class="n">violation_rate</span> <span class="o">/</span> <span class="n">total_rate</span>

    <span class="k">return</span> <span class="n">ce</span><span class="p">,</span> <span class="n">num_violations</span></div>


<span class="k">def</span> <span class="nf">_max_acceptable_cont</span><span class="p">(</span><span class="n">FR</span><span class="p">,</span> <span class="n">RP</span><span class="p">,</span> <span class="n">rec_duration</span><span class="p">,</span> <span class="n">acceptableCont</span><span class="p">,</span> <span class="n">thresh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to compute the maximum acceptable refractory period contamination</span>
<span class="sd">        called during slidingRP_viol</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">time_for_viol</span> <span class="o">=</span> <span class="n">RP</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FR</span> <span class="o">*</span> <span class="n">rec_duration</span>
    <span class="n">expected_count_for_acceptable_limit</span> <span class="o">=</span> <span class="n">acceptableCont</span> <span class="o">*</span> <span class="n">time_for_viol</span>
    <span class="n">max_acceptable</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">thresh</span><span class="p">,</span> <span class="n">expected_count_for_acceptable_limit</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_acceptable</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stats</span><span class="o">.</span><span class="n">poisson</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">expected_count_for_acceptable_limit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">max_acceptable</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">max_acceptable</span>


<div class="viewcode-block" id="slidingRP_viol"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.slidingRP_viol">[docs]</a><span class="k">def</span> <span class="nf">slidingRP_viol</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">acceptThresh</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A binary metric which determines whether there is an acceptable level of</span>
<span class="sd">    refractory period violations by using a sliding refractory period:</span>

<span class="sd">    This takes into account the firing rate of the neuron and computes a</span>
<span class="sd">    maximum acceptable level of contamination at different possible values of</span>
<span class="sd">    the refractory period. If the unit has less than the maximum contamination</span>
<span class="sd">    at any of the possible values of the refractory period, the unit passes.</span>

<span class="sd">    A neuron will always fail this metric for very low firing rates, and thus</span>
<span class="sd">    this metric takes into account both firing rate and refractory period</span>
<span class="sd">    violations.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : ndarray_like</span>
<span class="sd">        The timestamps (in s) of the spikes.</span>
<span class="sd">    bin_size : float</span>
<span class="sd">        The size of binning for the autocorrelogram.</span>
<span class="sd">    thresh : float</span>
<span class="sd">        Spike rate used to generate poisson distribution (to compute maximum</span>
<span class="sd">              acceptable contamination, see _max_acceptable_cont)</span>
<span class="sd">    acceptThresh : float</span>
<span class="sd">        The fraction of contamination we are willing to accept (default value</span>
<span class="sd">              set to 0.1, or 10% contamination)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    didpass : int</span>
<span class="sd">        0 if unit didn&#39;t pass</span>
<span class="sd">        1 if unit did pass</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    contamination</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1) Compute whether a unit has too much refractory period contamination at</span>
<span class="sd">    any possible value of a refractory period, for a 0.25 ms bin, with a</span>
<span class="sd">    threshold of 10% acceptable contamination</span>
<span class="sd">        &gt;&gt;&gt; ts = units_b[&#39;times&#39;][&#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; didpass = bb.metrics.slidingRP_viol(ts, bin_size=0.25, thresh=0.1,</span>
<span class="sd">                                                acceptThresh=0.1)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">10.25</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">+</span> <span class="mf">1e-6</span>  <span class="c1"># bins in seconds</span>
    <span class="n">bTestIdx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">40</span><span class="p">]</span>
    <span class="n">bTest</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bTestIdx</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>  <span class="c1"># only do this for units with samples</span>
        <span class="n">recDur</span> <span class="o">=</span> <span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># compute acg</span>
        <span class="n">c0</span> <span class="o">=</span> <span class="n">correlograms</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int8&#39;</span><span class="p">),</span> <span class="n">cluster_ids</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                          <span class="n">bin_size</span><span class="o">=</span><span class="n">bin_size</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span>
                          <span class="n">window_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                          <span class="n">symmetrize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># cumulative sum of acg, i.e. number of total spikes occuring from 0</span>
        <span class="c1"># to end of that bin</span>
        <span class="n">cumsumc0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">c0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="c1"># cumulative sum at each of the testing bins</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">cumsumc0</span><span class="p">[</span><span class="n">bTestIdx</span><span class="p">]</span>
        <span class="n">total_spike_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

        <span class="c1"># divide each bin&#39;s count by the total spike count and the bin size</span>
        <span class="n">bin_count_normalized</span> <span class="o">=</span> <span class="n">c0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">total_spike_count</span> <span class="o">/</span> <span class="n">bin_size</span> <span class="o">*</span> <span class="mi">1000</span>
        <span class="n">num_bins_2s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># number of total bins that equal 2 secs</span>
        <span class="n">num_bins_1s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_bins_2s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># number of bins that equal 1 sec</span>
        <span class="c1"># compute fr based on the  mean of bin_count_normalized from 1 to 2 s</span>
        <span class="c1"># instead of as before (len(ts)/recDur) for a better estimate</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_count_normalized</span><span class="p">[</span><span class="n">num_bins_1s</span><span class="p">:</span><span class="n">num_bins_2s</span><span class="p">])</span> <span class="o">/</span> <span class="n">num_bins_1s</span>
        <span class="n">mfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_max_acceptable_cont</span><span class="p">)</span>
        <span class="c1"># compute the maximum allowed number of spikes per testing bin</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">mfunc</span><span class="p">(</span><span class="n">fr</span><span class="p">,</span> <span class="n">bTest</span><span class="p">,</span> <span class="n">recDur</span><span class="p">,</span> <span class="n">fr</span> <span class="o">*</span> <span class="n">acceptThresh</span><span class="p">,</span> <span class="n">thresh</span><span class="p">)</span>
        <span class="c1"># did the unit pass (resulting number of spikes less than maximum</span>
        <span class="c1"># allowed spikes) at any of the testing bins?</span>
        <span class="n">didpass</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">m</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">didpass</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">didpass</span></div>


<div class="viewcode-block" id="noise_cutoff"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.noise_cutoff">[docs]</a><span class="k">def</span> <span class="nf">noise_cutoff</span><span class="p">(</span><span class="n">amps</span><span class="p">,</span> <span class="n">quartile_length</span><span class="o">=</span><span class="mf">.2</span><span class="p">,</span> <span class="n">n_bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_low_bins</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A metric to determine whether a unit&#39;s amplitude distribution is cut off</span>
<span class="sd">    (at floor), without assuming a Gaussian distribution.</span>

<span class="sd">    This metric takes the amplitude distribution, computes the mean and std</span>
<span class="sd">    of an upper quartile of the distribution, and determines how many standard</span>
<span class="sd">    deviations away from that mean a lower quartile lies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    amps : ndarray_like</span>
<span class="sd">        The amplitudes (in uV) of the spikes.</span>
<span class="sd">    quartile_length : float</span>
<span class="sd">        The size of the upper quartile of the amplitude distribution.</span>
<span class="sd">    n_bins : int</span>
<span class="sd">        The number of bins used to compute a histogram of the amplitude</span>
<span class="sd">        distribution.</span>
<span class="sd">    n_low_bins : int</span>
<span class="sd">        The number of bins used in the lower part of the distribution (where</span>
<span class="sd">        cutoff is determined).</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cutoff : float</span>
<span class="sd">        Number of standard deviations that the lower mean is outside of the</span>
<span class="sd">        mean of the upper quartile.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    missed_spikes_est</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1) Compute whether a unit&#39;s amplitude distribution is cut off</span>
<span class="sd">        &gt;&gt;&gt; amps = spks_b[&#39;amps&#39;][unit_idxs]</span>
<span class="sd">        &gt;&gt;&gt; cutoff = bb.metrics.noise_cutoff(amps, quartile_length=.2,</span>
<span class="sd">                                             n_bins=100, n_low_bins=2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">amps</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">bins_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">amps</span><span class="p">),</span> <span class="n">n_bins</span><span class="p">)</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">amps</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins_list</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">idx_nz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>  <span class="c1"># indices of nonzeros</span>
        <span class="n">idx_peak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">length_top_half</span> <span class="o">=</span> <span class="n">idx_nz</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_peak</span>
        <span class="n">high_quartile</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">quartile_length</span><span class="p">)</span>

        <span class="n">high_quartile_start_ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">high_quartile</span> <span class="o">*</span> <span class="n">length_top_half</span> <span class="o">+</span> <span class="n">idx_peak</span><span class="p">))</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">idx_nz</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx_nz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">high_quartile_start_ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">xx</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mean_high_quartile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">xx</span><span class="p">])</span>
            <span class="n">std_high_quartile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">xx</span><span class="p">])</span>
            <span class="n">first_low_quartile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">idx_nz</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="n">n_low_bins</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">std_high_quartile</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cutoff</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_low_quartile</span> <span class="o">-</span> <span class="n">mean_high_quartile</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_high_quartile</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cutoff</span></div>


<div class="viewcode-block" id="spike_sorting_metrics"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.spike_sorting_metrics">[docs]</a><span class="k">def</span> <span class="nf">spike_sorting_metrics</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">amps</span><span class="p">,</span> <span class="n">depths</span><span class="p">,</span> <span class="n">cluster_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">METRICS_PARAMS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes:</span>
<span class="sd">    -   cell level metrics (cf quick_unit_metrics)</span>
<span class="sd">    -   label the metrics according to quality thresholds</span>
<span class="sd">    -   estimates drift as a function of time</span>
<span class="sd">    :param times: vector of spike times</span>
<span class="sd">    :param clusters:</span>
<span class="sd">    :param amplitudes:</span>
<span class="sd">    :param depths:</span>
<span class="sd">    :param cluster_ids (optional): set of clusters (if None the output datgrame will match</span>
<span class="sd">     the unique set of clusters represented in spike clusters)</span>
<span class="sd">    :param params: dict (optional) parameters for qc computation (</span>
<span class="sd">     see constant at the top of the module for default values and keys)</span>
<span class="sd">    :return: data_frame of metrics (cluster records, columns are qc attributes)|</span>
<span class="sd">    :return: dictionary of recording qc (keys &#39;time_scale&#39; and &#39;drift_um&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute metrics and convert to `DataFrame`</span>
    <span class="n">df_units</span> <span class="o">=</span> <span class="n">quick_unit_metrics</span><span class="p">(</span>
        <span class="n">clusters</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">amps</span><span class="p">,</span> <span class="n">depths</span><span class="p">,</span> <span class="n">cluster_ids</span><span class="o">=</span><span class="n">cluster_ids</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
    <span class="n">df_units</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">df_units</span><span class="p">)</span>
    <span class="c1"># compute drift as a function of time and put in a dictionary</span>
    <span class="n">drift</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">electrode_drift</span><span class="o">.</span><span class="n">estimate_drift</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">amps</span><span class="p">,</span> <span class="n">depths</span><span class="p">)</span>
    <span class="n">rec_qc</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;time_scale&#39;</span><span class="p">:</span> <span class="n">ts</span><span class="p">,</span> <span class="s1">&#39;drift_um&#39;</span><span class="p">:</span> <span class="n">drift</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">df_units</span><span class="p">,</span> <span class="n">rec_qc</span></div>


<div class="viewcode-block" id="quick_unit_metrics"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.quick_unit_metrics">[docs]</a><span class="k">def</span> <span class="nf">quick_unit_metrics</span><span class="p">(</span><span class="n">spike_clusters</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">,</span> <span class="n">spike_amps</span><span class="p">,</span> <span class="n">spike_depths</span><span class="p">,</span>
                       <span class="n">params</span><span class="o">=</span><span class="n">METRICS_PARAMS</span><span class="p">,</span> <span class="n">cluster_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tbounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes single unit metrics from only the spike times, amplitudes, and</span>
<span class="sd">    depths for a set of units.</span>

<span class="sd">    Metrics computed:</span>
<span class="sd">        &#39;amp_max&#39;,</span>
<span class="sd">        &#39;amp_min&#39;,</span>
<span class="sd">        &#39;amp_median&#39;,</span>
<span class="sd">        &#39;amp_std_dB&#39;,</span>
<span class="sd">        &#39;contamination&#39;,</span>
<span class="sd">        &#39;contamination_alt&#39;,</span>
<span class="sd">        &#39;drift&#39;,</span>
<span class="sd">        &#39;missed_spikes_est&#39;,</span>
<span class="sd">        &#39;noise_cutoff&#39;,</span>
<span class="sd">        &#39;presence_ratio&#39;,</span>
<span class="sd">        &#39;presence_ratio_std&#39;,</span>
<span class="sd">        &#39;slidingRP_viol&#39;,</span>
<span class="sd">        &#39;spike_count&#39;</span>

<span class="sd">    Parameters (see the METRICS_PARAMS constant)</span>
<span class="sd">    ----------</span>
<span class="sd">    spike_clusters : ndarray_like</span>
<span class="sd">        A vector of the unit ids for a set of spikes.</span>
<span class="sd">    spike_times : ndarray_like</span>
<span class="sd">        A vector of the timestamps for a set of spikes.</span>
<span class="sd">    spike_amps : ndarray_like</span>
<span class="sd">        A vector of the amplitudes for a set of spikes.</span>
<span class="sd">    spike_depths : ndarray_like</span>
<span class="sd">        A vector of the depths for a set of spikes.</span>
<span class="sd">    clusters_id: (optional) lists of cluster ids. If not all clusters are represented in the</span>
<span class="sd">    spikes_clusters (ie. cluster has no spike), this will ensure the output size is consistent</span>
<span class="sd">    with the input arrays.</span>
<span class="sd">    tbounds: (optional) list or 2 elements array containing a time-selection to perform the</span>
<span class="sd">     metrics computation on.</span>
<span class="sd">    params : dict (optional)</span>
<span class="sd">        Parameters used for computing some of the metrics in the function:</span>
<span class="sd">            &#39;presence_window&#39;: float</span>
<span class="sd">                The time window (in s) used to look for spikes when computing the presence ratio.</span>
<span class="sd">            &#39;refractory_period&#39;: float</span>
<span class="sd">                The refractory period used when computing isi violations and the contamination</span>
<span class="sd">                estimate.</span>
<span class="sd">            &#39;min_isi&#39;: float</span>
<span class="sd">                The minimum interspike-interval (in s) for counting duplicate spikes when computing</span>
<span class="sd">                the contamination estimate.</span>
<span class="sd">            &#39;spks_per_bin_for_missed_spks_est&#39;: int</span>
<span class="sd">                The number of spikes per bin used to compute the spike amplitude pdf for a unit,</span>
<span class="sd">                when computing the missed spikes estimate.</span>
<span class="sd">            &#39;std_smoothing_kernel_for_missed_spks_est&#39;: float</span>
<span class="sd">                The standard deviation for the gaussian kernel used to compute the spike amplitude</span>
<span class="sd">                pdf for a unit, when computing the missed spikes estimate.</span>
<span class="sd">            &#39;min_num_bins_for_missed_spks_est&#39;: int</span>
<span class="sd">                The minimum number of bins used to compute the spike amplitude pdf for a unit,</span>
<span class="sd">                when computing the missed spikes estimate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    r : bunch</span>
<span class="sd">        A bunch whose keys are the computed spike metrics.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is called by `ephysqc.unit_metrics_ks2` which is called by `spikes.ks2_to_alf`</span>
<span class="sd">    during alf extraction of an ephys dataset in the ibl ephys extraction pipeline.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1) Compute quick metrics from a ks2 output directory:</span>
<span class="sd">        &gt;&gt;&gt; from ibllib.ephys.ephysqc import phy_model_from_ks2_path</span>
<span class="sd">        &gt;&gt;&gt; m = phy_model_from_ks2_path(path_to_ks2_out)</span>
<span class="sd">        &gt;&gt;&gt; cluster_ids = m.spike_clusters</span>
<span class="sd">        &gt;&gt;&gt; ts = m.spike_times</span>
<span class="sd">        &gt;&gt;&gt; amps = m.amplitudes</span>
<span class="sd">        &gt;&gt;&gt; depths = m.depths</span>
<span class="sd">        &gt;&gt;&gt; r = bb.metrics.quick_unit_metrics(cluster_ids, ts, amps, depths)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metrics_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;cluster_id&#39;</span><span class="p">,</span>
        <span class="s1">&#39;amp_max&#39;</span><span class="p">,</span>
        <span class="s1">&#39;amp_min&#39;</span><span class="p">,</span>
        <span class="s1">&#39;amp_median&#39;</span><span class="p">,</span>
        <span class="s1">&#39;amp_std_dB&#39;</span><span class="p">,</span>
        <span class="s1">&#39;contamination&#39;</span><span class="p">,</span>
        <span class="s1">&#39;contamination_alt&#39;</span><span class="p">,</span>
        <span class="s1">&#39;drift&#39;</span><span class="p">,</span>
        <span class="s1">&#39;missed_spikes_est&#39;</span><span class="p">,</span>
        <span class="s1">&#39;noise_cutoff&#39;</span><span class="p">,</span>
        <span class="s1">&#39;presence_ratio&#39;</span><span class="p">,</span>
        <span class="s1">&#39;presence_ratio_std&#39;</span><span class="p">,</span>
        <span class="s1">&#39;slidingRP_viol&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spike_count&#39;</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="n">tbounds</span><span class="p">:</span>
        <span class="n">ispi</span> <span class="o">=</span> <span class="n">between_sorted</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">tbounds</span><span class="p">)</span>
        <span class="n">spike_times</span> <span class="o">=</span> <span class="n">spike_times</span><span class="p">[</span><span class="n">ispi</span><span class="p">]</span>
        <span class="n">spike_clusters</span> <span class="o">=</span> <span class="n">spike_clusters</span><span class="p">[</span><span class="n">ispi</span><span class="p">]</span>
        <span class="n">spike_amps</span> <span class="o">=</span> <span class="n">spike_amps</span><span class="p">[</span><span class="n">ispi</span><span class="p">]</span>
        <span class="n">spike_depths</span> <span class="o">=</span> <span class="n">spike_depths</span><span class="p">[</span><span class="n">ispi</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">cluster_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cluster_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">spike_clusters</span><span class="p">)</span>
    <span class="n">nclust</span> <span class="o">=</span> <span class="n">cluster_ids</span><span class="o">.</span><span class="n">size</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nclust</span><span class="p">,),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">metrics_list</span><span class="p">})</span>
    <span class="n">r</span><span class="p">[</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_ids</span>

    <span class="c1"># vectorized computation of basic metrics such as presence ratio and firing rate</span>
    <span class="n">tmin</span> <span class="o">=</span> <span class="n">spike_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">tmax</span> <span class="o">=</span> <span class="n">spike_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">presence_ratio</span> <span class="o">=</span> <span class="n">bincount2D</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">spike_clusters</span><span class="p">,</span>
                                <span class="n">xbin</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;presence_window&#39;</span><span class="p">],</span>
                                <span class="n">ybin</span><span class="o">=</span><span class="n">cluster_ids</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="p">[</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">r</span><span class="o">.</span><span class="n">presence_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">presence_ratio</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">presence_ratio</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">r</span><span class="o">.</span><span class="n">presence_ratio_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">presence_ratio</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">spike_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">presence_ratio</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">firing_rate</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">spike_count</span> <span class="o">/</span> <span class="p">(</span><span class="n">tmax</span> <span class="o">-</span> <span class="n">tmin</span><span class="p">)</span>

    <span class="c1"># computing amplitude statistical indicators by aggregating over cluster id</span>
    <span class="n">camp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">spike_amps</span><span class="p">,</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spike_amps</span><span class="p">),</span> <span class="n">spike_clusters</span><span class="p">],</span>
                        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;amps&#39;</span><span class="p">,</span> <span class="s1">&#39;log_amps&#39;</span><span class="p">,</span> <span class="s1">&#39;clusters&#39;</span><span class="p">])</span>
    <span class="n">camp</span> <span class="o">=</span> <span class="n">camp</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;clusters&#39;</span><span class="p">)</span>
    <span class="n">ir</span><span class="p">,</span> <span class="n">ib</span> <span class="o">=</span> <span class="n">ismember</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">cluster_id</span><span class="p">,</span> <span class="n">camp</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
    <span class="n">r</span><span class="o">.</span><span class="n">amp_min</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">camp</span><span class="p">[</span><span class="s1">&#39;amps&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="n">r</span><span class="o">.</span><span class="n">amp_max</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">camp</span><span class="p">[</span><span class="s1">&#39;amps&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="c1"># this is the geometric median</span>
    <span class="n">r</span><span class="o">.</span><span class="n">amp_median</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">camp</span><span class="p">[</span><span class="s1">&#39;log_amps&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span> <span class="o">/</span> <span class="mi">20</span><span class="p">))</span>
    <span class="n">r</span><span class="o">.</span><span class="n">amp_std_dB</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">camp</span><span class="p">[</span><span class="s1">&#39;log_amps&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>

    <span class="c1"># loop over each cluster to compute the rest of the metrics</span>
    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nclust</span><span class="p">):</span>
        <span class="c1"># slice the spike_times array</span>
        <span class="n">ispikes</span> <span class="o">=</span> <span class="n">spike_clusters</span> <span class="o">==</span> <span class="n">cluster_ids</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">~</span><span class="n">ispikes</span><span class="p">):</span>  <span class="c1"># if this cluster has no spikes, continue</span>
            <span class="k">continue</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">spike_times</span><span class="p">[</span><span class="n">ispikes</span><span class="p">]</span>
        <span class="n">amps</span> <span class="o">=</span> <span class="n">spike_amps</span><span class="p">[</span><span class="n">ispikes</span><span class="p">]</span>
        <span class="n">depths</span> <span class="o">=</span> <span class="n">spike_depths</span><span class="p">[</span><span class="n">ispikes</span><span class="p">]</span>

        <span class="c1"># compute metrics</span>
        <span class="n">r</span><span class="o">.</span><span class="n">contamination_alt</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="n">contamination_alt</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">rp</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;refractory_period&#39;</span><span class="p">])</span>
        <span class="n">r</span><span class="o">.</span><span class="n">contamination</span><span class="p">[</span><span class="n">ic</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">contamination</span><span class="p">(</span>
            <span class="n">ts</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">rp</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;refractory_period&#39;</span><span class="p">],</span> <span class="n">min_isi</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;min_isi&#39;</span><span class="p">])</span>
        <span class="n">r</span><span class="o">.</span><span class="n">slidingRP_viol</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="n">slidingRP_viol</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span>
                                              <span class="n">bin_size</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;bin_size&#39;</span><span class="p">],</span>
                                              <span class="n">thresh</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;RPslide_thresh&#39;</span><span class="p">],</span>
                                              <span class="n">acceptThresh</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;acceptable_contamination&#39;</span><span class="p">])</span>
        <span class="n">r</span><span class="o">.</span><span class="n">noise_cutoff</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="n">noise_cutoff</span><span class="p">(</span><span class="n">amps</span><span class="p">,</span>
                                          <span class="n">quartile_length</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;nc_quartile_length&#39;</span><span class="p">],</span>
                                          <span class="n">n_bins</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;nc_bins&#39;</span><span class="p">],</span>
                                          <span class="n">n_low_bins</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;nc_n_low_bins&#39;</span><span class="p">])</span>
        <span class="n">r</span><span class="o">.</span><span class="n">missed_spikes_est</span><span class="p">[</span><span class="n">ic</span><span class="p">],</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">missed_spikes_est</span><span class="p">(</span>
            <span class="n">amps</span><span class="p">,</span> <span class="n">spks_per_bin</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;spks_per_bin_for_missed_spks_est&#39;</span><span class="p">],</span>
            <span class="n">sigma</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;std_smoothing_kernel_for_missed_spks_est&#39;</span><span class="p">],</span>
            <span class="n">min_num_bins</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;min_num_bins_for_missed_spks_est&#39;</span><span class="p">])</span>

        <span class="c1"># wonder if there is a need to low-cut this</span>
        <span class="n">r</span><span class="o">.</span><span class="n">drift</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">depths</span><span class="p">)))</span> <span class="o">/</span> <span class="p">(</span><span class="n">tmax</span> <span class="o">-</span> <span class="n">tmin</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3600</span>

    <span class="n">r</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">compute_labels</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span></div>


<div class="viewcode-block" id="compute_labels"><a class="viewcode-back" href="../../../_autosummary/brainbox.metrics.single_units.html#brainbox.metrics.single_units.compute_labels">[docs]</a><span class="k">def</span> <span class="nf">compute_labels</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">METRICS_PARAMS</span><span class="p">,</span> <span class="n">return_details</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From a dataframe or a dictionary of unit metrics, compute a lablel</span>
<span class="sd">    :param r: dictionary or pandas dataframe containing unit qcs</span>
<span class="sd">    :param return_details: False (returns a full dictionary of metrics)</span>
<span class="sd">    :return: vector of proportion of qcs passed between 0 and 1, where 1 denotes an all pass</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># right now the score is a value between 0 and 1 denoting the proportion of passing qcs</span>
    <span class="c1"># we could eventually do a bitwise qc</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span>
        <span class="n">r</span><span class="o">.</span><span class="n">slidingRP_viol</span><span class="p">,</span>
        <span class="n">r</span><span class="o">.</span><span class="n">noise_cutoff</span> <span class="o">&lt;</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;nc_thresh&#39;</span><span class="p">],</span>
        <span class="n">r</span><span class="o">.</span><span class="n">amp_median</span> <span class="o">&gt;</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;med_amp_thresh_uv&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_details</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;slidingRP_viol&#39;</span><span class="p">,</span> <span class="s1">&#39;noise_cutoff&#39;</span><span class="p">,</span> <span class="s1">&#39;amp_median&#39;</span><span class="p">]</span>
    <span class="n">qcdict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">qcdict</span><span class="p">[</span><span class="n">column_names</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">qcdict</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, International Brain Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>