

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ibllib.io.extractors.ephys_fpga &mdash; IBL Library  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/style.css?v=17142d56" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../../_static/copybutton.js?v=f281be69"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            IBL Library
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">The Open Neurophysiology Environment</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/one_quickstart.html">ONE Quick Start</a></li>
<li class="toctree-l1"><a class="reference external" href="https://int-brain-lab.github.io/ONE/">Full documentation Website for ONE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../public_docs/public_introduction.html">Publicly Available IBL Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../public_docs/dataset_overview.html">What is available for download ?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Datasets - Collaboration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/2025_data_release_brainwidemap.html">2025 - Brain Wide Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/2024_data_release_repro_ephys.html">2024 - Reproducible Ephys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/2021_data_release_behavior.html">2021 - Behavior</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Datasets - Projects</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/2025_data_release_autism_noel.html">2025 - Autism</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/2025_data_release_autism_davatolhagh.html">2025 - Autism Widefield</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/2022_data_release_spikesorting_benchmarks.html">2022 - Spike sorting benchmark datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../public_docs/data_release_pilot.html">Data Release - Pilot Dataset</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exploring IBL Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../02_installation.html">Installation of IBL Unified Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/data_structure.html">Get to know the datasets and folder structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/data_download.html">Setting up credentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/data_download.html#Explore-and-download-data-using-the-ONE-api">Explore and download data using the ONE-api</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../loading_examples.html">Loading Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Miscellaneous</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../09_contribution.html">How to contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../public_docs/information_contact.html">Getting Help: Information and Troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples &amp; Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../atlas_examples.html">Atlas Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/docs_wheel_moves.html">Working with wheel data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/docs_wheel_screen_stimulus.html">Computing the stimulus position using the wheel</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../010_api_reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">IBL Library</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ibllib.io.extractors.ephys_fpga</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ibllib.io.extractors.ephys_fpga</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Data extraction from raw FPGA output.</span>

<span class="sd">The behaviour extraction happens in the following stages:</span>

<span class="sd">    1. The NI DAQ events are extracted into a map of event times and TTL polarities.</span>
<span class="sd">    2. The Bpod trial events are extracted from the raw Bpod data, depending on the task protocol.</span>
<span class="sd">    3. As protocols may be chained together within a given recording, the period of a given task</span>
<span class="sd">       protocol is determined using the &#39;spacer&#39; DAQ signal (see `get_protocol_period`).</span>
<span class="sd">    4. Physical behaviour events such as stim on and reward time are separated out by TTL length or</span>
<span class="sd">       sequence within the trial.</span>
<span class="sd">    5. The Bpod clock is sync&#39;d with the FPGA using one of the extracted trial events.</span>
<span class="sd">    6. The Bpod software events are then converted to FPGA time.</span>

<span class="sd">Examples</span>
<span class="sd">--------</span>
<span class="sd">For simple extraction, use the FPGATrials class:</span>

<span class="sd">&gt;&gt;&gt; extractor = FpgaTrials(session_path)</span>
<span class="sd">&gt;&gt;&gt; trials, _ = extractor.extract(update=False, save=False)</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">Sync extraction in this module only supports FPGA data acquired with an NI DAQ as part of a</span>
<span class="sd">Neuropixels recording system, however a sync and channel map extracted from a different DAQ format</span>
<span class="sd">can be passed to the FpgaTrials class.</span>

<span class="sd">See Also</span>
<span class="sd">--------</span>
<span class="sd">For dynamic pipeline sessions it is best to call the extractor via the BehaviorTask class.</span>

<span class="sd">TODO notes on subclassing various methods of FpgaTrials for custom hardware.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">cycle</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.colors</span><span class="w"> </span><span class="kn">import</span> <span class="n">TABLEAU_COLORS</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">packaging</span><span class="w"> </span><span class="kn">import</span> <span class="n">version</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">spikeglx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ibldsp.utils</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">one.alf.io</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">alfio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">one.alf.path</span><span class="w"> </span><span class="kn">import</span> <span class="n">filename_parts</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">iblutil.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">Bunch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">iblutil.spacer</span><span class="w"> </span><span class="kn">import</span> <span class="n">Spacer</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">ibllib.exceptions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">err</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ibllib.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">raw_data_loaders</span> <span class="k">as</span> <span class="n">raw</span><span class="p">,</span> <span class="n">session_params</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ibllib.io.extractors.bpod_trials</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_bpod_extractor</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ibllib.io.extractors.base</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">extractors_base</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ibllib.io.extractors.training_wheel</span><span class="w"> </span><span class="kn">import</span> <span class="n">extract_wheel_moves</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ibllib</span><span class="w"> </span><span class="kn">import</span> <span class="n">plots</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ibllib.io.extractors.default_channel_maps</span><span class="w"> </span><span class="kn">import</span> <span class="n">DEFAULT_MAPS</span>

<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">SYNC_BATCH_SIZE_SECS</span> <span class="o">=</span> <span class="mi">100</span>
<span class="sd">&quot;&quot;&quot;int: Number of samples to read at once in bin file for sync.&quot;&quot;&quot;</span>

<span class="n">WHEEL_RADIUS_CM</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># stay in radians</span>
<span class="sd">&quot;&quot;&quot;float: The radius of the wheel used in the task. A value of 1 ensures units remain in radians.&quot;&quot;&quot;</span>

<span class="n">WHEEL_TICKS</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="sd">&quot;&quot;&quot;int: The number of encoder pulses per channel for one complete rotation.&quot;&quot;&quot;</span>

<span class="n">BPOD_FPGA_DRIFT_THRESHOLD_PPM</span> <span class="o">=</span> <span class="mi">150</span>
<span class="sd">&quot;&quot;&quot;int: Logs a warning if Bpod to FPGA clock drift is higher than this value.&quot;&quot;&quot;</span>

<span class="n">CHMAPS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;3A&#39;</span><span class="p">:</span>
          <span class="p">{</span><span class="s1">&#39;ap&#39;</span><span class="p">:</span>
           <span class="p">{</span><span class="s1">&#39;left_camera&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s1">&#39;right_camera&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s1">&#39;body_camera&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
            <span class="s1">&#39;bpod&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
            <span class="s1">&#39;frame2ttl&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
            <span class="s1">&#39;rotary_encoder_0&#39;</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span>
            <span class="s1">&#39;rotary_encoder_1&#39;</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span>
            <span class="s1">&#39;audio&#39;</span><span class="p">:</span> <span class="mi">15</span>
            <span class="p">}</span>
           <span class="p">},</span>
          <span class="s1">&#39;3B&#39;</span><span class="p">:</span>
          <span class="p">{</span><span class="s1">&#39;nidq&#39;</span><span class="p">:</span>
           <span class="p">{</span><span class="s1">&#39;left_camera&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;right_camera&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s1">&#39;body_camera&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s1">&#39;imec_sync&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s1">&#39;frame2ttl&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
            <span class="s1">&#39;rotary_encoder_0&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rotary_encoder_1&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
            <span class="s1">&#39;audio&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
            <span class="s1">&#39;bpod&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span>
            <span class="s1">&#39;laser&#39;</span><span class="p">:</span> <span class="mi">17</span><span class="p">,</span>
            <span class="s1">&#39;laser_ttl&#39;</span><span class="p">:</span> <span class="mi">18</span><span class="p">},</span>
           <span class="s1">&#39;ap&#39;</span><span class="p">:</span>
           <span class="p">{</span><span class="s1">&#39;imec_sync&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">}</span>
           <span class="p">},</span>
          <span class="p">}</span>
<span class="sd">&quot;&quot;&quot;dict: The default channel indices corresponding to various devices for different recording systems.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="data_for_keys">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.data_for_keys">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">data_for_keys</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check keys exist in &#39;data&#39; dict and contain values other than None.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_ibl_sync_map">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.get_ibl_sync_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_ibl_sync_map</span><span class="p">(</span><span class="n">ef</span><span class="p">,</span> <span class="n">version</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets default channel map for the version/binary file type combination</span>
<span class="sd">    :param ef: ibllib.io.spikeglx.glob_ephys_file dictionary with field &#39;ap&#39; or &#39;nidq&#39;</span>
<span class="sd">    :return: channel map dictionary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine default channel map</span>
    <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;3A&#39;</span><span class="p">:</span>
        <span class="n">default_chmap</span> <span class="o">=</span> <span class="n">CHMAPS</span><span class="p">[</span><span class="s1">&#39;3A&#39;</span><span class="p">][</span><span class="s1">&#39;ap&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;3B&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ef</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nidq&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">default_chmap</span> <span class="o">=</span> <span class="n">CHMAPS</span><span class="p">[</span><span class="s1">&#39;3B&#39;</span><span class="p">][</span><span class="s1">&#39;nidq&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">ef</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ap&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">default_chmap</span> <span class="o">=</span> <span class="n">CHMAPS</span><span class="p">[</span><span class="s1">&#39;3B&#39;</span><span class="p">][</span><span class="s1">&#39;ap&#39;</span><span class="p">]</span>
    <span class="c1"># Try to load channel map from file</span>
    <span class="n">chmap</span> <span class="o">=</span> <span class="n">spikeglx</span><span class="o">.</span><span class="n">get_sync_map</span><span class="p">(</span><span class="n">ef</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">])</span>
    <span class="c1"># If chmap provided but not with all keys, fill up with default values</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">chmap</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default_chmap</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data_for_keys</span><span class="p">(</span><span class="n">default_chmap</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">chmap</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">chmap</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Keys missing from provided channel map, &quot;</span>
                            <span class="s2">&quot;setting missing keys from default channel map&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="o">**</span><span class="n">default_chmap</span><span class="p">,</span> <span class="o">**</span><span class="n">chmap</span><span class="p">}</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_sync_to_alf</span><span class="p">(</span><span class="n">raw_ephys_apfile</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts sync.times, sync.channels and sync.polarities from binary ephys dataset</span>

<span class="sd">    :param raw_ephys_apfile: bin file containing ephys data or spike</span>
<span class="sd">    :param output_path: output directory</span>
<span class="sd">    :param save: bool write to disk only if True</span>
<span class="sd">    :param parts: string or list of strings that will be appended to the filename before extension</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># handles input argument: support ibllib.io.spikeglx.Reader, str and pathlib.Path</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw_ephys_apfile</span><span class="p">,</span> <span class="n">spikeglx</span><span class="o">.</span><span class="n">Reader</span><span class="p">):</span>
        <span class="n">sr</span> <span class="o">=</span> <span class="n">raw_ephys_apfile</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">raw_ephys_apfile</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">raw_ephys_apfile</span><span class="p">)</span>
        <span class="n">sr</span> <span class="o">=</span> <span class="n">spikeglx</span><span class="o">.</span><span class="n">Reader</span><span class="p">(</span><span class="n">raw_ephys_apfile</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">opened</span> <span class="o">:=</span> <span class="n">sr</span><span class="o">.</span><span class="n">is_open</span><span class="p">):</span>
        <span class="n">sr</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
    <span class="c1"># if no output, need a temp folder to swap for big files</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">output_path</span><span class="p">:</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">raw_ephys_apfile</span><span class="o">.</span><span class="n">parent</span>
    <span class="n">file_ftcp</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;fronts_times_channel_polarity</span><span class="si">{</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span><span class="si">}</span><span class="s1">.bin&#39;</span><span class="p">)</span>

    <span class="c1"># loop over chunks of the raw ephys file</span>
    <span class="n">wg</span> <span class="o">=</span> <span class="n">ibldsp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">WindowGenerator</span><span class="p">(</span><span class="n">sr</span><span class="o">.</span><span class="n">ns</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">SYNC_BATCH_SIZE_SECS</span> <span class="o">*</span> <span class="n">sr</span><span class="o">.</span><span class="n">fs</span><span class="p">),</span> <span class="n">overlap</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">fid_ftcp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_ftcp</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">wg</span><span class="o">.</span><span class="n">slice</span><span class="p">:</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="n">sr</span><span class="o">.</span><span class="n">read_sync</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
        <span class="n">ind</span><span class="p">,</span> <span class="n">fronts</span> <span class="o">=</span> <span class="n">ibldsp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">fronts</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># a = sr.read_sync_analog(sl)</span>
        <span class="n">sav</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">sl</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">sr</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">fronts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)]</span>
        <span class="n">sav</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">fid_ftcp</span><span class="p">)</span>
    <span class="c1"># close temp file, read from it and delete</span>
    <span class="n">fid_ftcp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">tim_chan_pol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">file_ftcp</span><span class="p">))</span>
    <span class="n">tim_chan_pol</span> <span class="o">=</span> <span class="n">tim_chan_pol</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">tim_chan_pol</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">file_ftcp</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
    <span class="n">sync</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;times&#39;</span><span class="p">:</span> <span class="n">tim_chan_pol</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;channels&#39;</span><span class="p">:</span> <span class="n">tim_chan_pol</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="s1">&#39;polarities&#39;</span><span class="p">:</span> <span class="n">tim_chan_pol</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]}</span>
    <span class="c1"># If opened Reader was passed into function, leave open</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">opened</span><span class="p">:</span>
        <span class="n">sr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="n">out_files</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">save_object_npy</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="s1">&#39;sync&#39;</span><span class="p">,</span>
                                          <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;spikeglx&#39;</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="n">parts</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Bunch</span><span class="p">(</span><span class="n">sync</span><span class="p">),</span> <span class="n">out_files</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Bunch</span><span class="p">(</span><span class="n">sync</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_rotary_encoder_positions_from_fronts</span><span class="p">(</span><span class="n">ta</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">WHEEL_TICKS</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">WHEEL_RADIUS_CM</span><span class="p">,</span> <span class="n">coding</span><span class="o">=</span><span class="s1">&#39;x4&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts the rotary encoder absolute position as function of time from fronts detected</span>
<span class="sd">    on the 2 channels. Outputs in units of radius parameters, by default radians</span>
<span class="sd">    Coding options detailed here: http://www.ni.com/tutorial/7109/pt/</span>
<span class="sd">    Here output is clockwise from subject perspective</span>

<span class="sd">    :param ta: time of fronts on channel A</span>
<span class="sd">    :param pa: polarity of fronts on channel A</span>
<span class="sd">    :param tb: time of fronts on channel B</span>
<span class="sd">    :param pb: polarity of fronts on channel B</span>
<span class="sd">    :param ticks: number of ticks corresponding to a full revolution (1024 for IBL rotary encoder)</span>
<span class="sd">    :param radius: radius of the wheel. Defaults to 1 for an output in radians</span>
<span class="sd">    :param coding: x1, x2 or x4 coding (IBL default is x4)</span>
<span class="sd">    :return: indices vector (ta) and position vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">coding</span> <span class="o">==</span> <span class="s1">&#39;x1&#39;</span><span class="p">:</span>
        <span class="n">ia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">ta</span><span class="p">[</span><span class="n">pa</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ia</span> <span class="o">=</span> <span class="n">ia</span><span class="p">[</span><span class="n">ia</span> <span class="o">&lt;</span> <span class="n">ta</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
        <span class="n">ia</span> <span class="o">=</span> <span class="n">ia</span><span class="p">[</span><span class="n">pa</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">ib</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">ta</span><span class="p">,</span> <span class="n">tb</span><span class="p">[</span><span class="n">pb</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ib</span> <span class="o">=</span> <span class="n">ib</span><span class="p">[</span><span class="n">ib</span> <span class="o">&lt;</span> <span class="n">tb</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
        <span class="n">ib</span> <span class="o">=</span> <span class="n">ib</span><span class="p">[</span><span class="n">pb</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">ta</span><span class="p">[</span><span class="n">ia</span><span class="p">],</span> <span class="n">tb</span><span class="p">[</span><span class="n">ib</span><span class="p">]]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">ia</span> <span class="o">*</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ib</span> <span class="o">*</span> <span class="mi">0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">ordre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">ordre</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">ordre</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">ticks</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span>
    <span class="k">elif</span> <span class="n">coding</span> <span class="o">==</span> <span class="s1">&#39;x2&#39;</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">pb</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">ta</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pa</span>
        <span class="n">p</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">ticks</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">ta</span><span class="p">,</span> <span class="n">p</span>
    <span class="k">elif</span> <span class="n">coding</span> <span class="o">==</span> <span class="s1">&#39;x4&#39;</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">pb</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">ta</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pa</span><span class="p">,</span> <span class="o">-</span><span class="n">pa</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">ta</span><span class="p">,</span> <span class="n">tb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pb</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">ta</span><span class="p">,</span> <span class="n">tb</span><span class="p">]</span>
        <span class="n">ordre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">ordre</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">ordre</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">ticks</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">/</span> <span class="mi">4</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_assign_events_to_trial</span><span class="p">(</span><span class="n">t_trial_start</span><span class="p">,</span> <span class="n">t_event</span><span class="p">,</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">,</span> <span class="n">t_trial_end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign events to a trial given trial start times and event times.</span>

<span class="sd">    Trials without an event result in nan value in output time vector.</span>
<span class="sd">    The output has a consistent size with t_trial_start and ready to output to alf.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t_trial_start : numpy.array</span>
<span class="sd">        An array of start times, used to bin edges for assigning values from `t_event`.</span>
<span class="sd">    t_event : numpy.array</span>
<span class="sd">        An array of event times to assign to trials.</span>
<span class="sd">    take : str {&#39;first&#39;, &#39;last&#39;}, int</span>
<span class="sd">        &#39;first&#39; takes first event &gt; t_trial_start; &#39;last&#39; takes last event &lt; the next</span>
<span class="sd">        t_trial_start; an int defines the index to take for events within trial bounds. The index</span>
<span class="sd">        may be negative.</span>
<span class="sd">    t_trial_end : numpy.array</span>
<span class="sd">        Optional array of end times, used to bin edges for assigning values from `t_event`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.array</span>
<span class="sd">        An array the length of `t_trial_start` containing values from `t_event`. Unassigned values</span>
<span class="sd">        are replaced with np.nan.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    FpgaTrials._assign_events - Assign trial events based on TTL length.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure the events are sorted</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t_trial_start</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Trial starts vector not sorted&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t_event</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Events vector is not sorted&#39;</span><span class="p">)</span>

    <span class="c1"># remove events that happened before the first trial start</span>
    <span class="n">remove</span> <span class="o">=</span> <span class="n">t_event</span> <span class="o">&lt;</span> <span class="n">t_trial_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">t_trial_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t_trial_end</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Trial end vector not sorted&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">t_trial_end</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">t_trial_start</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Trial end times must not overlap with trial start times&#39;</span><span class="p">)</span>
        <span class="c1"># remove events between end and next start, and after last end</span>
        <span class="n">remove</span> <span class="o">|=</span> <span class="n">t_event</span> <span class="o">&gt;</span> <span class="n">t_trial_end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">t_trial_end</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t_trial_start</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">remove</span> <span class="o">|=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">t_event</span><span class="p">,</span> <span class="n">t_event</span> <span class="o">&gt;=</span> <span class="n">e</span><span class="p">)</span>
    <span class="n">t_event</span> <span class="o">=</span> <span class="n">t_event</span><span class="p">[</span><span class="o">~</span><span class="n">remove</span><span class="p">]</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t_trial_start</span><span class="p">,</span> <span class="n">t_event</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">t_event_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">t_trial_start</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="c1"># select first or last element matching each trial start</span>
    <span class="k">if</span> <span class="n">take</span> <span class="o">==</span> <span class="s1">&#39;last&#39;</span><span class="p">:</span>
        <span class="n">iall</span><span class="p">,</span> <span class="n">iu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">t_event_nans</span><span class="p">[</span><span class="n">iall</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_event</span><span class="p">[</span><span class="o">-</span> <span class="p">(</span><span class="n">iu</span> <span class="o">-</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">take</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
        <span class="n">iall</span><span class="p">,</span> <span class="n">iu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">t_event_nans</span><span class="p">[</span><span class="n">iall</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_event</span><span class="p">[</span><span class="n">iu</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># if the index is arbitrary, needs to be numeric (could be negative if from the end)</span>
        <span class="n">iall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="n">minsize</span> <span class="o">=</span> <span class="n">take</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">take</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span> <span class="n">take</span>
        <span class="c1"># for each trial, take the take nth element if there are enough values in trial</span>
        <span class="k">for</span> <span class="n">iu</span> <span class="ow">in</span> <span class="n">iall</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">t_event</span><span class="p">[</span><span class="n">iu</span> <span class="o">==</span> <span class="n">ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">minsize</span><span class="p">:</span>
                <span class="n">t_event_nans</span><span class="p">[</span><span class="n">iu</span><span class="p">]</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="n">take</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">t_event_nans</span>


<div class="viewcode-block" id="get_sync_fronts">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.get_sync_fronts">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_sync_fronts</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">channel_nb</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the sync front polarities and times for a given channel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sync : dict</span>
<span class="sd">        &#39;polarities&#39; of fronts detected on sync trace for all 16 channels and their &#39;times&#39;.</span>
<span class="sd">    channel_nb : int</span>
<span class="sd">        The integer corresponding to the desired sync channel.</span>
<span class="sd">    tmin : float</span>
<span class="sd">        The minimum time from which to extract the sync pulses.</span>
<span class="sd">    tmax : float</span>
<span class="sd">        The maximum time up to which we extract the sync pulses.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Bunch</span>
<span class="sd">        Channel times and polarities.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">selection</span> <span class="o">=</span> <span class="n">sync</span><span class="p">[</span><span class="s1">&#39;channels&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel_nb</span>
    <span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">sync</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">tmax</span><span class="p">)</span> <span class="k">if</span> <span class="n">tmax</span> <span class="k">else</span> <span class="n">selection</span>
    <span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">sync</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">tmin</span><span class="p">)</span> <span class="k">if</span> <span class="n">tmin</span> <span class="k">else</span> <span class="n">selection</span>
    <span class="k">return</span> <span class="n">Bunch</span><span class="p">({</span><span class="s1">&#39;times&#39;</span><span class="p">:</span> <span class="n">sync</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">][</span><span class="n">selection</span><span class="p">],</span>
                  <span class="s1">&#39;polarities&#39;</span><span class="p">:</span> <span class="n">sync</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">][</span><span class="n">selection</span><span class="p">]})</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_clean_audio</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    one guy wired the 150 Hz camera output onto the soundcard. The effect is to get 150 Hz periodic</span>
<span class="sd">    square pulses, 2ms up and 4.666 ms down. When this happens we remove all of the intermediate</span>
<span class="sd">    pulses to repair the audio trace</span>
<span class="sd">    Here is some helper code</span>
<span class="sd">        dd = np.diff(audio[&#39;times&#39;])</span>
<span class="sd">        1 / np.median(dd[::2]) # 2ms up</span>
<span class="sd">        1 / np.median(dd[1::2])  # 4.666 ms down</span>
<span class="sd">        1 / (np.median(dd[::2]) + np.median(dd[1::2])) # both sum to 150 Hz</span>
<span class="sd">    This only runs on sessions when the bug is detected and leaves others untouched</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DISCARD_THRESHOLD</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="n">average_150_hz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">audio</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">][</span><span class="n">audio</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">140</span><span class="p">)</span>
    <span class="n">naudio</span> <span class="o">=</span> <span class="n">audio</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">average_150_hz</span> <span class="o">&gt;</span> <span class="mf">0.7</span> <span class="ow">and</span> <span class="n">naudio</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Soundcard signal on FPGA seems to have been mixed with 150Hz camera&#39;</span><span class="p">)</span>
        <span class="n">keep_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">audio</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">DISCARD_THRESHOLD</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
        <span class="n">keep_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">keep_ind</span><span class="p">,</span> <span class="n">audio</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">keep_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">keep_ind</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">keep_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">keep_ind</span><span class="p">,</span> <span class="n">keep_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">naudio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">display</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">ibllib.plots</span><span class="w"> </span><span class="kn">import</span> <span class="n">squares</span>
            <span class="n">squares</span><span class="p">(</span><span class="n">audio</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="n">audio</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">yrange</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">squares</span><span class="p">(</span><span class="n">audio</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">][</span><span class="n">keep_ind</span><span class="p">],</span> <span class="n">audio</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">][</span><span class="n">keep_ind</span><span class="p">],</span> <span class="n">yrange</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">audio</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;times&#39;</span><span class="p">:</span> <span class="n">audio</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">][</span><span class="n">keep_ind</span><span class="p">],</span>
                 <span class="s1">&#39;polarities&#39;</span><span class="p">:</span> <span class="n">audio</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">][</span><span class="n">keep_ind</span><span class="p">]}</span>
    <span class="k">return</span> <span class="n">audio</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_clean_frame2ttl</span><span class="p">(</span><span class="n">frame2ttl</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Clean the frame2ttl events.</span>

<span class="sd">    Frame 2ttl calibration can be unstable and the fronts may be flickering at an unrealistic</span>
<span class="sd">    pace. This removes the consecutive frame2ttl pulses happening too fast, below a threshold</span>
<span class="sd">    of F2TTL_THRESH.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frame2ttl : dict</span>
<span class="sd">        A dictionary of frame2TTL events, with keys {&#39;times&#39;, &#39;polarities&#39;}.</span>
<span class="sd">    threshold : float</span>
<span class="sd">        Consecutive pulses occurring with this many seconds ignored.</span>
<span class="sd">    display : bool</span>
<span class="sd">        If true, plots the input TTLs and the cleaned output.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">])</span>
    <span class="n">iko</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">dt</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">iko</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">iko</span><span class="p">,</span> <span class="n">iko</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">frame2ttl_</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;times&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="n">iko</span><span class="p">),</span>
                  <span class="s1">&#39;polarities&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">],</span> <span class="n">iko</span><span class="p">)}</span>
    <span class="k">if</span> <span class="n">iko</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">iko</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">iko</span><span class="o">.</span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">frame2ttl</span><span class="p">[</span><span class="s2">&quot;times&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="si">:</span><span class="s1">.2%</span><span class="si">}</span><span class="s1">) &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;frame to TTL polarity switches below </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s1"> secs&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">display</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax0</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plots</span><span class="o">.</span><span class="n">squares</span><span class="p">(</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">],</span> <span class="n">yrange</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax0</span><span class="p">)</span>
        <span class="n">plots</span><span class="o">.</span><span class="n">squares</span><span class="p">(</span><span class="n">frame2ttl_</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">frame2ttl_</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">],</span> <span class="n">yrange</span><span class="o">=</span><span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">seaborn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sns</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">displot</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="n">dt</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">],</span> <span class="n">binwidth</span><span class="o">=</span><span class="mf">0.0005</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">frame2ttl_</span>


<div class="viewcode-block" id="extract_wheel_sync">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.extract_wheel_sync">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">extract_wheel_sync</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract wheel positions and times from sync fronts dictionary for all 16 channels.</span>
<span class="sd">    Output position is in radians, mathematical convention.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sync : dict</span>
<span class="sd">        &#39;polarities&#39; of fronts detected on sync trace for all 16 chans and their &#39;times&#39;</span>
<span class="sd">    chmap : dict</span>
<span class="sd">        Map of channel names and their corresponding index.  Default to constant.</span>
<span class="sd">    tmin : float</span>
<span class="sd">        The minimum time from which to extract the sync pulses.</span>
<span class="sd">    tmax : float</span>
<span class="sd">        The maximum time up to which we extract the sync pulses.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.array</span>
<span class="sd">        Wheel timestamps in seconds.</span>
<span class="sd">    numpy.array</span>
<span class="sd">        Wheel positions in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Assume two separate edge count channels</span>
    <span class="k">assert</span> <span class="n">chmap</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="p">{</span><span class="s1">&#39;rotary_encoder_0&#39;</span><span class="p">,</span> <span class="s1">&#39;rotary_encoder_1&#39;</span><span class="p">}</span>
    <span class="n">channela</span> <span class="o">=</span> <span class="n">get_sync_fronts</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">[</span><span class="s1">&#39;rotary_encoder_0&#39;</span><span class="p">],</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">)</span>
    <span class="n">channelb</span> <span class="o">=</span> <span class="n">get_sync_fronts</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">[</span><span class="s1">&#39;rotary_encoder_1&#39;</span><span class="p">],</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">)</span>
    <span class="n">re_ts</span><span class="p">,</span> <span class="n">re_pos</span> <span class="o">=</span> <span class="n">_rotary_encoder_positions_from_fronts</span><span class="p">(</span>
        <span class="n">channela</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="n">channela</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">],</span> <span class="n">channelb</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="n">channelb</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">],</span>
        <span class="n">ticks</span><span class="o">=</span><span class="n">WHEEL_TICKS</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">WHEEL_RADIUS_CM</span><span class="p">,</span> <span class="n">coding</span><span class="o">=</span><span class="s1">&#39;x4&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">re_ts</span><span class="p">,</span> <span class="n">re_pos</span></div>



<div class="viewcode-block" id="extract_sync">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.extract_sync">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">extract_sync</span><span class="p">(</span><span class="n">session_path</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ephys_files</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;spikeglx&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads ephys binary file (s) and extract sync within the binary file folder</span>
<span class="sd">    Assumes ephys data is within a `raw_ephys_data` folder</span>

<span class="sd">    :param session_path: &#39;/path/to/subject/yyyy-mm-dd/001&#39;</span>
<span class="sd">    :param overwrite: Bool on re-extraction, forces overwrite instead of loading existing files</span>
<span class="sd">    :return: list of sync dictionaries</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">session_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">session_path</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ephys_files</span><span class="p">:</span>
        <span class="n">ephys_files</span> <span class="o">=</span> <span class="n">spikeglx</span><span class="o">.</span><span class="n">glob_ephys_files</span><span class="p">(</span><span class="n">session_path</span><span class="p">)</span>
    <span class="n">syncs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">efi</span> <span class="ow">in</span> <span class="n">ephys_files</span><span class="p">:</span>
        <span class="n">bin_file</span> <span class="o">=</span> <span class="n">efi</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ap&#39;</span><span class="p">,</span> <span class="n">efi</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nidq&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bin_file</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">alfname</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">object</span><span class="o">=</span><span class="s1">&#39;sync&#39;</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">efi</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
            <span class="n">alfname</span><span class="p">[</span><span class="s1">&#39;extra&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">efi</span><span class="o">.</span><span class="n">label</span>
        <span class="n">file_exists</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">bin_file</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="o">**</span><span class="n">alfname</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="n">file_exists</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Skipping raw sync: SGLX sync found for </span><span class="si">{</span><span class="n">efi</span><span class="o">.</span><span class="n">label</span><span class="si">}</span><span class="s1">!&#39;</span><span class="p">)</span>
            <span class="n">sync</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">load_object</span><span class="p">(</span><span class="n">bin_file</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="o">**</span><span class="n">alfname</span><span class="p">)</span>
            <span class="n">out_files</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">_ls</span><span class="p">(</span><span class="n">bin_file</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="o">**</span><span class="n">alfname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sr</span> <span class="o">=</span> <span class="n">spikeglx</span><span class="o">.</span><span class="n">Reader</span><span class="p">(</span><span class="n">bin_file</span><span class="p">)</span>
            <span class="n">sync</span><span class="p">,</span> <span class="n">out_files</span> <span class="o">=</span> <span class="n">_sync_to_alf</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">bin_file</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="n">efi</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
            <span class="n">sr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">outputs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">out_files</span><span class="p">)</span>
        <span class="n">syncs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">sync</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">syncs</span><span class="p">,</span> <span class="n">outputs</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_get_all_probes_sync</span><span class="p">(</span><span class="n">session_path</span><span class="p">,</span> <span class="n">bin_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># round-up of all bin ephys files in the session, infer revision and get sync map</span>
    <span class="n">ephys_files</span> <span class="o">=</span> <span class="n">spikeglx</span><span class="o">.</span><span class="n">glob_ephys_files</span><span class="p">(</span><span class="n">session_path</span><span class="p">,</span> <span class="n">bin_exists</span><span class="o">=</span><span class="n">bin_exists</span><span class="p">)</span>
    <span class="n">version</span> <span class="o">=</span> <span class="n">spikeglx</span><span class="o">.</span><span class="n">get_neuropixel_version_from_files</span><span class="p">(</span><span class="n">ephys_files</span><span class="p">)</span>
    <span class="c1"># attach the sync information to each binary file found</span>
    <span class="k">for</span> <span class="n">ef</span> <span class="ow">in</span> <span class="n">ephys_files</span><span class="p">:</span>
        <span class="n">ef</span><span class="p">[</span><span class="s1">&#39;sync&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">load_object</span><span class="p">(</span><span class="n">ef</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;sync&#39;</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;spikeglx&#39;</span><span class="p">,</span> <span class="n">short_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ef</span><span class="p">[</span><span class="s1">&#39;sync_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_ibl_sync_map</span><span class="p">(</span><span class="n">ef</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ephys_files</span>


<div class="viewcode-block" id="get_wheel_positions">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.get_wheel_positions">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_wheel_positions</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the wheel position from synchronisation pulses</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sync : dict</span>
<span class="sd">        A dictionary with keys (&#39;times&#39;, &#39;polarities&#39;, &#39;channels&#39;), containing the sync pulses and</span>
<span class="sd">        the corresponding channel numbers.</span>
<span class="sd">    chmap : dict[str, int]</span>
<span class="sd">        A map of channel names and their corresponding indices.</span>
<span class="sd">    tmin : float</span>
<span class="sd">        The minimum time from which to extract the sync pulses.</span>
<span class="sd">    tmax : float</span>
<span class="sd">        The maximum time up to which we extract the sync pulses.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Bunch</span>
<span class="sd">        A dictionary with keys (&#39;timestamps&#39;, &#39;position&#39;), containing the wheel event timestamps and</span>
<span class="sd">        position in radians</span>
<span class="sd">    Bunch</span>
<span class="sd">        A dictionary of detected movement times with keys (&#39;intervals&#39;, &#39;peakAmplitude&#39;, &#39;peakVelocity_times&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ts</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">extract_wheel_sync</span><span class="p">(</span><span class="n">sync</span><span class="o">=</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="o">=</span><span class="n">chmap</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">)</span>
    <span class="n">moves</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="n">extract_wheel_moves</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
    <span class="n">wheel</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">({</span><span class="s1">&#39;timestamps&#39;</span><span class="p">:</span> <span class="n">ts</span><span class="p">,</span> <span class="s1">&#39;position&#39;</span><span class="p">:</span> <span class="n">pos</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">wheel</span><span class="p">,</span> <span class="n">moves</span></div>



<div class="viewcode-block" id="get_main_probe_sync">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.get_main_probe_sync">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_main_probe_sync</span><span class="p">(</span><span class="n">session_path</span><span class="p">,</span> <span class="n">bin_exists</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From 3A or 3B multiprobe session, returns the main probe (3A) or nidq sync pulses</span>
<span class="sd">    with the attached channel map (default chmap if none)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    session_path : str, pathlib.Path</span>
<span class="sd">        The absolute session path, i.e. &#39;/path/to/subject/yyyy-mm-dd/nnn&#39;.</span>
<span class="sd">    bin_exists : bool</span>
<span class="sd">        Whether there is a .bin file present.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    one.alf.io.AlfBunch</span>
<span class="sd">        A dictionary with keys (&#39;times&#39;, &#39;polarities&#39;, &#39;channels&#39;), containing the sync pulses and</span>
<span class="sd">        the corresponding channel numbers.</span>
<span class="sd">    dict</span>
<span class="sd">        A map of channel names and their corresponding indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ephys_files</span> <span class="o">=</span> <span class="n">_get_all_probes_sync</span><span class="p">(</span><span class="n">session_path</span><span class="p">,</span> <span class="n">bin_exists</span><span class="o">=</span><span class="n">bin_exists</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ephys_files</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No ephys files found in </span><span class="si">{</span><span class="n">session_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">version</span> <span class="o">=</span> <span class="n">spikeglx</span><span class="o">.</span><span class="n">get_neuropixel_version_from_files</span><span class="p">(</span><span class="n">ephys_files</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;3A&#39;</span><span class="p">:</span>
        <span class="c1"># the sync master is the probe with the most sync pulses</span>
        <span class="n">sync_box_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="n">ef</span><span class="o">.</span><span class="n">sync</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">ef</span> <span class="ow">in</span> <span class="n">ephys_files</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;3B&#39;</span><span class="p">:</span>
        <span class="c1"># the sync master is the nidq breakout box</span>
        <span class="n">sync_box_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="mi">1</span> <span class="k">if</span> <span class="n">ef</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nidq&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ef</span> <span class="ow">in</span> <span class="n">ephys_files</span><span class="p">])</span>
    <span class="n">sync</span> <span class="o">=</span> <span class="n">ephys_files</span><span class="p">[</span><span class="n">sync_box_ind</span><span class="p">]</span><span class="o">.</span><span class="n">sync</span>
    <span class="n">sync_chmap</span> <span class="o">=</span> <span class="n">ephys_files</span><span class="p">[</span><span class="n">sync_box_ind</span><span class="p">]</span><span class="o">.</span><span class="n">sync_map</span>
    <span class="k">return</span> <span class="n">sync</span><span class="p">,</span> <span class="n">sync_chmap</span></div>



<div class="viewcode-block" id="get_protocol_period">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.get_protocol_period">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_protocol_period</span><span class="p">(</span><span class="n">session_path</span><span class="p">,</span> <span class="n">protocol_number</span><span class="p">,</span> <span class="n">bpod_sync</span><span class="p">,</span> <span class="n">exclude_empty_periods</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the start and end time of the protocol number.</span>

<span class="sd">    Note that the start time is the start of the spacer pulses and the end time is either None</span>
<span class="sd">    if the protocol is the final one, or the start of the next spacer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    session_path : str, pathlib.Path</span>
<span class="sd">        The absolute session path, i.e. &#39;/path/to/subject/yyyy-mm-dd/nnn&#39;.</span>
<span class="sd">    protocol_number : int</span>
<span class="sd">        The order that the protocol was run in, counted from 0.</span>
<span class="sd">    bpod_sync : dict</span>
<span class="sd">        The sync times and polarities for Bpod BNC1.</span>
<span class="sd">    exclude_empty_periods : bool</span>
<span class="sd">        When true, spacers are ignored if no bpod pulses are detected between periods.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The time of the detected spacer for the protocol number.</span>
<span class="sd">    float, None</span>
<span class="sd">        The time of the next detected spacer or None if this is the last protocol run.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The spacers are TTLs generated by Bpod at the start of each protocol</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">Spacer</span><span class="p">()</span>
    <span class="n">spacer_times</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">find_spacers_from_fronts</span><span class="p">(</span><span class="n">bpod_sync</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exclude_empty_periods</span><span class="p">:</span>
        <span class="c1"># Drop dud protocol spacers (those without any bpod pulses after the spacer)</span>
        <span class="n">spacer_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">generate_template</span><span class="p">(</span><span class="n">fs</span><span class="o">=</span><span class="mi">1000</span><span class="p">))</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="n">periods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">spacer_times</span> <span class="o">+</span> <span class="n">spacer_length</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">spacer_times</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]]</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">bpod_sync</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bpod_sync</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pp</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">periods</span><span class="p">]</span>
        <span class="n">spacer_times</span> <span class="o">=</span> <span class="n">spacer_times</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
    <span class="c1"># Ensure that the number of detected spacers matched the number of expected tasks</span>
    <span class="k">if</span> <span class="n">acquisition_description</span> <span class="o">:=</span> <span class="n">session_params</span><span class="o">.</span><span class="n">read_params</span><span class="p">(</span><span class="n">session_path</span><span class="p">):</span>
        <span class="n">n_tasks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">acquisition_description</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tasks&#39;</span><span class="p">,</span> <span class="p">[]))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">spacer_times</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">protocol_number</span><span class="p">,</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;expected </span><span class="si">{</span><span class="n">n_tasks</span><span class="si">}</span><span class="s1"> spacers, found only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spacer_times</span><span class="p">)</span><span class="si">}</span><span class="s1"> - &#39;</span>
                                                      <span class="sa">f</span><span class="s1">&#39;can not return protocol number </span><span class="si">{</span><span class="n">protocol_number</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">n_tasks</span> <span class="o">&gt;</span> <span class="n">protocol_number</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;protocol number must be between 0 and </span><span class="si">{</span><span class="n">n_tasks</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">protocol_number</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">spacer_times</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">spacer_times</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">protocol_number</span><span class="p">)]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spacer_times</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">protocol_number</span> <span class="k">else</span> <span class="n">spacer_times</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">protocol_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span></div>



<div class="viewcode-block" id="FpgaTrials">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.FpgaTrials">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FpgaTrials</span><span class="p">(</span><span class="n">extractors_base</span><span class="o">.</span><span class="n">BaseExtractor</span><span class="p">):</span>
    <span class="n">save_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_ibl_trials.goCueTrigger_times.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;_ibl_trials.stimOnTrigger_times.npy&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;_ibl_trials.stimOffTrigger_times.npy&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="s1">&#39;_ibl_trials.stimOff_times.npy&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;_ibl_trials.quiescencePeriod.npy&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;_ibl_trials.table.pqt&#39;</span><span class="p">,</span> <span class="s1">&#39;_ibl_wheel.timestamps.npy&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;_ibl_wheel.position.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;_ibl_wheelMoves.intervals.npy&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;_ibl_wheelMoves.peakAmplitude.npy&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">var_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;goCueTrigger_times&#39;</span><span class="p">,</span> <span class="s1">&#39;stimOnTrigger_times&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;stimOffTrigger_times&#39;</span><span class="p">,</span> <span class="s1">&#39;stimFreezeTrigger_times&#39;</span><span class="p">,</span> <span class="s1">&#39;errorCueTrigger_times&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;errorCue_times&#39;</span><span class="p">,</span> <span class="s1">&#39;itiIn_times&#39;</span><span class="p">,</span> <span class="s1">&#39;stimFreeze_times&#39;</span><span class="p">,</span> <span class="s1">&#39;stimOff_times&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;valveOpen_times&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="s1">&#39;quiescence&#39;</span><span class="p">,</span> <span class="s1">&#39;table&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;wheel_timestamps&#39;</span><span class="p">,</span> <span class="s1">&#39;wheel_position&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;wheelMoves_intervals&#39;</span><span class="p">,</span> <span class="s1">&#39;wheelMoves_peakAmplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;wheelMoves_peakVelocity_times&#39;</span><span class="p">)</span>

    <span class="n">bpod_rsync_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;intervals&#39;</span><span class="p">,</span> <span class="s1">&#39;response_times&#39;</span><span class="p">,</span> <span class="s1">&#39;goCueTrigger_times&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;stimOnTrigger_times&#39;</span><span class="p">,</span> <span class="s1">&#39;stimOffTrigger_times&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;stimFreezeTrigger_times&#39;</span><span class="p">,</span> <span class="s1">&#39;errorCueTrigger_times&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;tuple of str: Fields from Bpod extractor that we want to re-sync to FPGA.&quot;&quot;&quot;</span>

    <span class="n">bpod_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;feedbackType&#39;</span><span class="p">,</span> <span class="s1">&#39;choice&#39;</span><span class="p">,</span> <span class="s1">&#39;rewardVolume&#39;</span><span class="p">,</span> <span class="s1">&#39;contrastLeft&#39;</span><span class="p">,</span> <span class="s1">&#39;contrastRight&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;probabilityLeft&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="s1">&#39;quiescence&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;tuple of str: Fields from bpod extractor that we want to save.&quot;&quot;&quot;</span>

    <span class="n">sync_field</span> <span class="o">=</span> <span class="s1">&#39;intervals_0&#39;</span>  <span class="c1"># trial start events</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;str: The trial event to synchronize (must be present in extracted trials).&quot;&quot;&quot;</span>

    <span class="n">bpod</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;dict of numpy.array: The Bpod out TTLs recorded on the DAQ. Used in the QC viewer plot.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">bpod_trials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bpod_extractor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An extractor for ephysChoiceWorld trials data, in FPGA time.</span>

<span class="sd">        This class may be subclassed to handle moderate variations in hardware and task protocol,</span>
<span class="sd">        however there is flexible</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bpod2fpga</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span> <span class="o">=</span> <span class="n">bpod_trials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">bpod_extractor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bpod_extractor</span> <span class="o">=</span> <span class="n">bpod_extractor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_var_names</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_var_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bpod_fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bpod_rsync_fields</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates this object&#39;s attributes based on the Bpod trials extractor.</span>

<span class="sd">        Fields updated: bpod_fields, bpod_rsync_fields, save_names, and var_names.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bpod_fields : tuple</span>
<span class="sd">            A set of Bpod trials fields to keep.</span>
<span class="sd">        bpod_rsync_fields : tuple</span>
<span class="sd">            A set of Bpod trials fields to sync to the DAQ times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_extractor</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">save_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_extractor</span><span class="o">.</span><span class="n">var_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_extractor</span><span class="o">.</span><span class="n">save_names</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">var_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_names</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">var_names</span> <span class="o">+=</span> <span class="p">(</span><span class="n">var_name</span><span class="p">,)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">save_names</span> <span class="o">+=</span> <span class="p">(</span><span class="n">save_name</span><span class="p">,)</span>

            <span class="c1"># self.var_names = self.bpod_extractor.var_names</span>
            <span class="c1"># self.save_names = self.bpod_extractor.save_names</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_extractor</span><span class="o">.</span><span class="n">settings</span>  <span class="c1"># This is used by the TaskQC</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bpod_rsync_fields</span> <span class="o">=</span> <span class="n">bpod_rsync_fields</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_rsync_fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bpod_rsync_fields</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_fields</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_extractor</span><span class="o">.</span><span class="n">var_names</span><span class="p">))</span>
                <span class="k">if</span> <span class="s1">&#39;table&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_extractor</span><span class="o">.</span><span class="n">var_names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_extractor</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">table_keys</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">AlfBunch</span><span class="o">.</span><span class="n">from_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bpod_rsync_fields</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_fields</span><span class="p">(</span><span class="n">table_keys</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">bpod_rsync_fields</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bpod_rsync_fields</span> <span class="o">=</span> <span class="n">bpod_rsync_fields</span>
        <span class="n">excluded</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_rsync_fields</span><span class="p">,</span> <span class="s1">&#39;table&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bpod_fields</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_fields</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">excluded</span><span class="p">),</span> <span class="s1">&#39;bpod_fields must not also be bpod_rsync_fields&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bpod_fields</span> <span class="o">=</span> <span class="n">bpod_fields</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_extractor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bpod_fields</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_extractor</span><span class="o">.</span><span class="n">var_names</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excluded</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;table&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_extractor</span><span class="o">.</span><span class="n">var_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_extractor</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">table_keys</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">AlfBunch</span><span class="o">.</span><span class="n">from_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bpod_fields</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">table_keys</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excluded</span><span class="p">])</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_time_fields</span><span class="p">(</span><span class="n">trials_attr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates over Bpod trials attributes returning those that correspond to times for syncing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trials_attr : iterable of str</span>
<span class="sd">            The Bpod field names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set</span>
<span class="sd">            The field names that contain timestamps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">FIELDS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;times&#39;</span><span class="p">,</span> <span class="s1">&#39;timestamps&#39;</span><span class="p">,</span> <span class="s1">&#39;intervals&#39;</span><span class="p">)</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">fr</span><span class="s1">&#39;^[_\w]*(</span><span class="si">{</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">FIELDS</span><span class="p">)</span><span class="si">}</span><span class="s1">)[_\w]*$&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">,</span> <span class="n">trials_attr</span><span class="p">))</span>

<div class="viewcode-block" id="FpgaTrials.load_sync">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.FpgaTrials.load_sync">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync_collection</span><span class="o">=</span><span class="s1">&#39;raw_ephys_data&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load the DAQ sync and channel map data.</span>

<span class="sd">        This method may be subclassed for novel DAQ systems. The sync must contain the following</span>
<span class="sd">        keys: &#39;times&#39; - an array timestamps in seconds; &#39;polarities&#39; - an array of {-1, 1}</span>
<span class="sd">        corresponding to TTL LOW and TTL HIGH, respectively; &#39;channels&#39; - an array of ints</span>
<span class="sd">        corresponding to channel number.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sync_collection : str</span>
<span class="sd">            The session subdirectory where the sync data are located.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Optional arguments used by subclass methods.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        one.alf.io.AlfBunch</span>
<span class="sd">            A dictionary with keys (&#39;times&#39;, &#39;polarities&#39;, &#39;channels&#39;), containing the sync pulses</span>
<span class="sd">            and the corresponding channel numbers.</span>
<span class="sd">        dict</span>
<span class="sd">            A map of channel names and their corresponding indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_sync_and_chn_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session_path</span><span class="p">,</span> <span class="n">sync_collection</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sync_collection</span><span class="o">=</span><span class="s1">&#39;raw_ephys_data&#39;</span><span class="p">,</span>
                 <span class="n">task_collection</span><span class="o">=</span><span class="s1">&#39;raw_behavior_data&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts ephys trials by combining Bpod and FPGA sync pulses.</span>

<span class="sd">        It is essential that the `var_names`, `bpod_rsync_fields`, `bpod_fields`, and `sync_field`</span>
<span class="sd">        attributes are all correct for the bpod protocol used.</span>

<span class="sd">        Below are the steps involved:</span>
<span class="sd">          0. Load sync and bpod trials, if required.</span>
<span class="sd">          1. Determine protocol period and discard sync events outside the task.</span>
<span class="sd">          2. Classify multiplexed TTL events based on length (see :meth:`FpgaTrials.build_trials`).</span>
<span class="sd">          3. Sync the Bpod clock to the DAQ clock using one of the assigned trial events.</span>
<span class="sd">          4. Assign classified TTL events to trial events based on order within the trial.</span>
<span class="sd">          4. Convert Bpod software event times to DAQ clock.</span>
<span class="sd">          5. Extract the wheel from the DAQ rotary encoder signal, if required.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sync : dict</span>
<span class="sd">            A dictionary with keys (&#39;times&#39;, &#39;polarities&#39;, &#39;channels&#39;), containing the sync pulses</span>
<span class="sd">            and the corresponding channel numbers. If None, the sync is loaded using the</span>
<span class="sd">            `load_sync` method.</span>
<span class="sd">        chmap : dict</span>
<span class="sd">            A map of channel names and their corresponding indices. If None, the channel map is</span>
<span class="sd">            loaded using the :meth:`FpgaTrials.load_sync` method.</span>
<span class="sd">        sync_collection : str</span>
<span class="sd">            The session subdirectory where the sync data are located. This is only used if the</span>
<span class="sd">            sync or channel maps are not provided.</span>
<span class="sd">        task_collection : str</span>
<span class="sd">            The session subdirectory where the raw Bpod data are located. This is used for loading</span>
<span class="sd">            the task settings and extracting the bpod trials, if not already done.</span>
<span class="sd">        protocol_number : int</span>
<span class="sd">            The protocol number if multiple protocols were run during the session. If provided, a</span>
<span class="sd">            spacer signal must be present in order to determine the correct period.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Optional arguments for subclass methods to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary of numpy arrays with `FpgaTrials.var_names` as keys.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sync</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">chmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_sync</span><span class="p">,</span> <span class="n">_chmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_sync</span><span class="p">(</span><span class="n">sync_collection</span><span class="p">)</span>
            <span class="n">sync</span> <span class="o">=</span> <span class="n">sync</span> <span class="ow">or</span> <span class="n">_sync</span>
            <span class="n">chmap</span> <span class="o">=</span> <span class="n">chmap</span> <span class="ow">or</span> <span class="n">_chmap</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">:</span>  <span class="c1"># extract the behaviour data from bpod</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extractor</span> <span class="o">=</span> <span class="n">get_bpod_extractor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session_path</span><span class="p">,</span> <span class="n">task_collection</span><span class="o">=</span><span class="n">task_collection</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Bpod trials extractor: </span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extractor</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extractor</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extractor</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">task_collection</span><span class="o">=</span><span class="n">task_collection</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Explode trials table df</span>
        <span class="k">if</span> <span class="s1">&#39;table&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_names</span><span class="p">:</span>
            <span class="n">trials_table</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">AlfBunch</span><span class="o">.</span><span class="n">from_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;table&#39;</span><span class="p">))</span>
            <span class="n">table_columns</span> <span class="o">=</span> <span class="n">trials_table</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">trials_table</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;table&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s1">&#39;&quot;table&quot; found in Bpod trials but missing from `var_names` attribute and will&#39;</span>
                    <span class="s1">&#39;therefore not be extracted. This is likely in error.&#39;</span><span class="p">)</span>
            <span class="n">table_columns</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">bpod</span> <span class="o">=</span> <span class="n">get_sync_fronts</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">[</span><span class="s1">&#39;bpod&#39;</span><span class="p">])</span>
        <span class="c1"># Get the spacer times for this protocol</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">arg</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;tmin&#39;</span><span class="p">,</span> <span class="s1">&#39;tmax&#39;</span><span class="p">)):</span>
            <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tmin&#39;</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tmax&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">protocol_number</span> <span class="o">:=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;protocol_number&#39;</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># look for spacer</span>
            <span class="c1"># The spacers are TTLs generated by Bpod at the start of each protocol</span>
            <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="n">get_protocol_period</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session_path</span><span class="p">,</span> <span class="n">protocol_number</span><span class="p">,</span> <span class="n">bpod</span><span class="p">)</span>
            <span class="n">tmin</span> <span class="o">+=</span> <span class="p">(</span><span class="n">Spacer</span><span class="p">()</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">Spacer</span><span class="p">()</span><span class="o">.</span><span class="n">tup</span> <span class="o">+</span> <span class="mf">0.05</span><span class="p">)</span>  <span class="c1"># exclude spacer itself</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Older sessions don&#39;t have protocol spacers so we sync the Bpod intervals here to</span>
            <span class="c1"># find the approximate end time of the protocol (this will exclude the passive signals</span>
            <span class="c1"># in ephysChoiceWorld that tend to ruin the final trial extraction).</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">trial_ints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bpod_event_times</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">t_trial_start</span> <span class="o">=</span> <span class="n">trial_ints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;trial_start&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]]))[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">bpod_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="s1">&#39;intervals&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_trial_start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">bpod_start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># if least half the trial start TTLs detected</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Attempting to get protocol period from aligning trial start TTLs&#39;</span><span class="p">)</span>
                <span class="n">fcn</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">ibldsp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">sync_timestamps</span><span class="p">(</span><span class="n">bpod_start</span><span class="p">,</span> <span class="n">t_trial_start</span><span class="p">)</span>
                <span class="n">buffer</span> <span class="o">=</span> <span class="mf">2.5</span>  <span class="c1"># the number of seconds to include before/after task</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">fcn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="s1">&#39;intervals&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">flat</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                <span class="c1"># NB: The following was added by k1o0 in commit b31d14e5113180b50621c985b2f230ba84da1dd3</span>
                <span class="c1"># however it is not clear why this was necessary and it appears to defeat the purpose of</span>
                <span class="c1"># removing the passive protocol part from the final trial extraction in ephysChoiceWorld.</span>
                <span class="c1">#   tmin = min(sync[&#39;times&#39;][0], start - buffer)</span>
                <span class="c1">#   tmax = max(sync[&#39;times&#39;][-1], end + buffer)</span>
                <span class="n">tmin</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">buffer</span>
                <span class="n">tmax</span> <span class="o">=</span> <span class="n">end</span> <span class="o">+</span> <span class="n">buffer</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># This type of alignment fails for some sessions, e.g. mesoscope</span>
                <span class="n">tmin</span> <span class="o">=</span> <span class="n">tmax</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Remove unnecessary data from sync</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">sync</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">tmax</span> <span class="k">if</span> <span class="n">tmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sync</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">sync</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">tmin</span> <span class="k">if</span> <span class="n">tmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sync</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="n">sync</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">AlfBunch</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sync</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Protocol period from </span><span class="si">%.2f</span><span class="s1">s to </span><span class="si">%.2f</span><span class="s1">s (~</span><span class="si">%.0f</span><span class="s1"> min duration)&#39;</span><span class="p">,</span>
                      <span class="o">*</span><span class="n">sync</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">][[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sync</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">][[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="o">/</span> <span class="mi">60</span><span class="p">)</span>

        <span class="c1"># Get the trial events from the DAQ sync TTLs, sync clocks and build final trials datasets</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_trials</span><span class="p">(</span><span class="n">sync</span><span class="o">=</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="o">=</span><span class="n">chmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># extract the wheel data</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;wheel&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
            <span class="n">wheel</span><span class="p">,</span> <span class="n">moves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_wheel_positions</span><span class="p">(</span><span class="n">sync</span><span class="o">=</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="o">=</span><span class="n">chmap</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">)</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">ibllib.io.extractors.training_wheel</span><span class="w"> </span><span class="kn">import</span> <span class="n">extract_first_movement_times</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">load_settings</span><span class="p">(</span><span class="n">session_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">session_path</span><span class="p">,</span> <span class="n">task_collection</span><span class="o">=</span><span class="n">task_collection</span><span class="p">)</span>
            <span class="n">min_qt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;QUIESCENT_PERIOD&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">first_move_onsets</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">extract_first_movement_times</span><span class="p">(</span><span class="n">moves</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">min_qt</span><span class="o">=</span><span class="n">min_qt</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;firstMovement_times&#39;</span><span class="p">:</span> <span class="n">first_move_onsets</span><span class="p">})</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s1">&#39;wheel_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">wheel</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s1">&#39;wheelMoves_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">moves</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>

        <span class="c1"># Re-create trials table</span>
        <span class="k">if</span> <span class="n">table_columns</span><span class="p">:</span>
            <span class="n">trials_table</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">AlfBunch</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">table_columns</span><span class="p">})</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trials_table</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">AlfBunch</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_names</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">out</span><span class="p">})</span>  <span class="c1"># Reorder output</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_names</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_is_trials_object_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">variable_length_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if variable name is expected to have the same length as trials.intervals.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var_name : str</span>
<span class="sd">            The variable name to check.</span>
<span class="sd">        variable_length_vars : list</span>
<span class="sd">            Set of variable names that are not expected to have the same length as trials.intervals.</span>
<span class="sd">            This list may be passed by superclasses.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if variable is a trials dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; assert self._is_trials_object_attribute(&#39;stimOnTrigger_times&#39;) is True</span>
<span class="sd">        &gt;&gt;&gt; assert self._is_trials_object_attribute(&#39;wheel_position&#39;) is False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">save_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">var_name</span><span class="p">)]</span> <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_names</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">save_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">filename_parts</span><span class="p">(</span><span class="n">save_name</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;trials&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">var_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">variable_length_vars</span> <span class="ow">or</span> <span class="p">[])</span>

<div class="viewcode-block" id="FpgaTrials.build_trials">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.FpgaTrials.build_trials">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_trials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract task related event times from the sync.</span>

<span class="sd">        The trial start times are the shortest Bpod TTLs and occur at the start of the trial. The</span>
<span class="sd">        first trial start TTL of the session is longer and must be handled differently. The trial</span>
<span class="sd">        start TTL is used to assign the other trial events to each trial.</span>

<span class="sd">        The trial end is the end of the so-called &#39;ITI&#39; Bpod event TTL (classified as the longest</span>
<span class="sd">        of the three Bpod event TTLs). Go cue audio TTLs are the shorter of the two expected audio</span>
<span class="sd">        tones. The first of these after each trial start is taken to be the go cue time. Error</span>
<span class="sd">        tones are longer audio TTLs and assigned as the last of such occurrence after each trial</span>
<span class="sd">        start. The valve open Bpod TTLs are medium-length, the last of which is used for each trial.</span>
<span class="sd">        The feedback times are times of either valve open or error tone as there should be only one</span>
<span class="sd">        such event per trial.</span>

<span class="sd">        The stimulus times are taken from the frame2ttl events (with improbably high frequency TTLs</span>
<span class="sd">        removed): the first TTL after each trial start is assumed to be the stim onset time; the</span>
<span class="sd">        second to last and last are taken as the stimulus freeze and offset times, respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sync : dict</span>
<span class="sd">            &#39;polarities&#39; of fronts detected on sync trace for all 16 chans and their &#39;times&#39;</span>
<span class="sd">        chmap : dict</span>
<span class="sd">            Map of channel names and their corresponding index.  Default to constant.</span>
<span class="sd">        display : bool, matplotlib.pyplot.Axes</span>
<span class="sd">            Show the full session sync pulses display.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A map of trial event timestamps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the events from the sync.</span>
        <span class="c1"># Store the cleaned frame2ttl, audio, and bpod pulses as this will be used for QC</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stimulus_update_times</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">audio</span><span class="p">,</span> <span class="n">audio_event_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_audio_event_times</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">audio_event_intervals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="p">{</span><span class="s1">&#39;ready_tone&#39;</span><span class="p">,</span> <span class="s1">&#39;error_tone&#39;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Expected at least &quot;ready_tone&quot; and &quot;error_tone&quot; audio events.&#39;</span>
                <span class="s1">&#39;`audio_event_ttls` kwarg may be incorrect.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bpod</span><span class="p">,</span> <span class="n">bpod_event_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bpod_event_times</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">bpod_event_intervals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="p">{</span><span class="s1">&#39;trial_start&#39;</span><span class="p">,</span> <span class="s1">&#39;valve_open&#39;</span><span class="p">,</span> <span class="s1">&#39;trial_end&#39;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Expected at least &quot;trial_start&quot;, &quot;trial_end&quot;, and &quot;valve_open&quot; audio events. &#39;</span>
                <span class="s1">&#39;`bpod_event_ttls` kwarg may be incorrect.&#39;</span><span class="p">)</span>

        <span class="n">t_iti_in</span><span class="p">,</span> <span class="n">t_trial_end</span> <span class="o">=</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">fpga_events</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">AlfBunch</span><span class="p">({</span>
            <span class="s1">&#39;goCue_times&#39;</span><span class="p">:</span> <span class="n">audio_event_intervals</span><span class="p">[</span><span class="s1">&#39;ready_tone&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;errorCue_times&#39;</span><span class="p">:</span> <span class="n">audio_event_intervals</span><span class="p">[</span><span class="s1">&#39;error_tone&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;valveOpen_times&#39;</span><span class="p">:</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;valve_open&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;valveClose_times&#39;</span><span class="p">:</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;valve_open&#39;</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="s1">&#39;itiIn_times&#39;</span><span class="p">:</span> <span class="n">t_iti_in</span><span class="p">,</span>
            <span class="s1">&#39;intervals_0&#39;</span><span class="p">:</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_start&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;intervals_1&#39;</span><span class="p">:</span> <span class="n">t_trial_end</span>
        <span class="p">})</span>

        <span class="c1"># Sync the Bpod clock to the DAQ.</span>
        <span class="c1"># NB: The Bpod extractor typically drops the final, incomplete, trial. Hence there is</span>
        <span class="c1"># usually at least one extra FPGA event. This shouldn&#39;t affect the sync. The final trial is</span>
        <span class="c1"># dropped after assigning the FPGA events, using the `ibpod` index. Doing this after</span>
        <span class="c1"># assigning the FPGA trial events ensures the last trial has the correct timestamps.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bpod2fpga</span><span class="p">,</span> <span class="n">drift_ppm</span><span class="p">,</span> <span class="n">ibpod</span><span class="p">,</span> <span class="n">ifpga</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_bpod_clock</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">,</span> <span class="n">fpga_events</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_field</span><span class="p">)</span>

        <span class="n">bpod_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod2fpga</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="s1">&#39;intervals&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">missing_bpod_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setxor1d</span><span class="p">(</span><span class="n">ibpod</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bpod_start</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">missing_bpod_idx</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_field</span> <span class="o">==</span> <span class="s1">&#39;intervals_0&#39;</span><span class="p">:</span>
            <span class="c1"># One issue is that sometimes pulses may not have been detected, in this case</span>
            <span class="c1"># add the events that have not been detected and re-extract the behaviour sync.</span>
            <span class="c1"># This is only really relevant for the Bpod interval events as the other TTLs are</span>
            <span class="c1"># from devices where a missing TTL likely means the Bpod event was truly absent.</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Missing Bpod TTLs; reassigning events using aligned Bpod start times&#39;</span><span class="p">)</span>
            <span class="n">missing_bpod</span> <span class="o">=</span> <span class="n">bpod_start</span><span class="p">[</span><span class="n">missing_bpod_idx</span><span class="p">]</span>
            <span class="c1"># Another complication: if the first trial start is missing on the FPGA, the second</span>
            <span class="c1"># trial start is assumed to be the first and is mis-assigned to another trial event</span>
            <span class="c1"># (i.e. valve open). This is done because the first Bpod pulse is irregularly long.</span>
            <span class="c1"># See `FpgaTrials.get_bpod_event_times` for details.</span>

            <span class="c1"># If first trial start is missing first detected FPGA event doesn&#39;t match any Bpod</span>
            <span class="c1"># starts then it&#39;s probably a mis-assigned valve or trial end event.</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_delay_initiation</span><span class="p">()</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">missing_bpod_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                  <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;intervals_0&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bpod_start</span><span class="p">)))</span>
            <span class="c1"># skip mis-assigned first FPGA trial start</span>
            <span class="n">t_trial_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;intervals_0&#39;</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">i1</span><span class="p">):],</span> <span class="n">missing_bpod</span><span class="p">])</span>
            <span class="n">ibpod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">ibpod</span><span class="p">,</span> <span class="n">missing_bpod_idx</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">i1</span><span class="p">:</span>
                <span class="c1"># The first trial start is actually the first valve open here</span>
                <span class="n">first_on</span><span class="p">,</span> <span class="n">first_off</span> <span class="o">=</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_start&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">bpod_valve_open</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod2fpga</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="s1">&#39;feedback_times&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="s1">&#39;feedbackType&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">first_on</span><span class="p">,</span> <span class="n">bpod_valve_open</span><span class="p">)):</span>
                    <span class="c1"># Probably assigned to the valve open</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Re-reassigning first valve open event. TTL length = </span><span class="si">%.3g</span><span class="s1"> ms&#39;</span><span class="p">,</span> <span class="n">first_off</span> <span class="o">-</span> <span class="n">first_on</span><span class="p">)</span>
                    <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;valveOpen_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">first_on</span><span class="p">,</span> <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;valveOpen_times&#39;</span><span class="p">]])</span>
                    <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;valveClose_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">first_off</span><span class="p">,</span> <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;valveClose_times&#39;</span><span class="p">]])</span>
                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">first_on</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod2fpga</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="s1">&#39;itiIn_times&#39;</span><span class="p">]))):</span>
                    <span class="c1"># Probably assigned to the trial end</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Re-reassigning first trial end event. TTL length = </span><span class="si">%.3g</span><span class="s1"> ms&#39;</span><span class="p">,</span> <span class="n">first_off</span> <span class="o">-</span> <span class="n">first_on</span><span class="p">)</span>
                    <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;itiIn_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">first_on</span><span class="p">,</span> <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;itiIn_times&#39;</span><span class="p">]])</span>
                    <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;intervals_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">first_off</span><span class="p">,</span> <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;intervals_1&#39;</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Unable to reassign first trial start event. TTL length = </span><span class="si">%.3g</span><span class="s1"> ms&#39;</span><span class="p">,</span> <span class="n">first_off</span> <span class="o">-</span> <span class="n">first_on</span><span class="p">)</span>
                <span class="c1"># Bpod trial_start event intervals are not used but for consistency we&#39;ll update them here anyway</span>
                <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_start&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t_trial_start</span> <span class="o">=</span> <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;intervals_0&#39;</span><span class="p">]</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">AlfBunch</span><span class="p">()</span>
        <span class="c1"># Add the Bpod trial events, converting the timestamp fields to FPGA time.</span>
        <span class="c1"># NB: The trial intervals are by default a Bpod rsync field.</span>
        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">ibpod</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_fields</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_rsync_fields</span><span class="p">:</span>
            <span class="c1"># Some personal projects may extract non-trials object datasets that may not have 1 event per trial</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">ibpod</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_trials_object_attribute</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod2fpga</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>

        <span class="n">f2ttl_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span>
        <span class="c1"># Assign the FPGA events to individual trials</span>
        <span class="n">fpga_trials</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;goCue_times&#39;</span><span class="p">:</span> <span class="n">_assign_events_to_trial</span><span class="p">(</span><span class="n">t_trial_start</span><span class="p">,</span> <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;goCue_times&#39;</span><span class="p">],</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">),</span>
            <span class="s1">&#39;errorCue_times&#39;</span><span class="p">:</span> <span class="n">_assign_events_to_trial</span><span class="p">(</span><span class="n">t_trial_start</span><span class="p">,</span> <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;errorCue_times&#39;</span><span class="p">]),</span>
            <span class="s1">&#39;valveOpen_times&#39;</span><span class="p">:</span> <span class="n">_assign_events_to_trial</span><span class="p">(</span><span class="n">t_trial_start</span><span class="p">,</span> <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;valveOpen_times&#39;</span><span class="p">]),</span>
            <span class="s1">&#39;itiIn_times&#39;</span><span class="p">:</span> <span class="n">_assign_events_to_trial</span><span class="p">(</span><span class="n">t_trial_start</span><span class="p">,</span> <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;itiIn_times&#39;</span><span class="p">]),</span>
            <span class="s1">&#39;stimOn_times&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">t_trial_start</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
            <span class="s1">&#39;stimOff_times&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">t_trial_start</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
            <span class="s1">&#39;stimFreeze_times&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">t_trial_start</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1"># f2ttl times are unreliable owing to calibration and Bonsai sync square update issues.</span>
        <span class="c1"># Take the first event after the FPGA aligned stimulus trigger time.</span>
        <span class="n">fpga_trials</span><span class="p">[</span><span class="s1">&#39;stimOn_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_assign_events_to_trial</span><span class="p">(</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOnTrigger_times&#39;</span><span class="p">],</span> <span class="n">f2ttl_t</span><span class="p">,</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="n">t_trial_end</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOffTrigger_times&#39;</span><span class="p">])</span>
        <span class="n">fpga_trials</span><span class="p">[</span><span class="s1">&#39;stimOff_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_assign_events_to_trial</span><span class="p">(</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOffTrigger_times&#39;</span><span class="p">],</span> <span class="n">f2ttl_t</span><span class="p">,</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="n">t_trial_end</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;intervals&#39;</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1"># For stim freeze we take the last event before the stim off trigger time.</span>
        <span class="c1"># To avoid assigning early events (e.g. for sessions where there are few flips due to</span>
        <span class="c1"># mis-calibration), we discount events before stim freeze trigger times (or stim on trigger</span>
        <span class="c1"># times for versions below 6.2.5). We take the last event rather than the first after stim</span>
        <span class="c1"># freeze trigger because often there are multiple flips after the trigger, presumably</span>
        <span class="c1"># before the stim actually stops.</span>
        <span class="n">stim_freeze</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimFreezeTrigger_times&#39;</span><span class="p">])</span>
        <span class="n">go_trials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;choice&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># NB: versions below 6.2.5 have no trigger times so use stim on trigger times</span>
        <span class="n">lims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOnTrigger_times&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">stim_freeze</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="c1"># Stim freeze times are NaN for nogo trials, but for all others use stim freeze trigger</span>
            <span class="c1"># times. _assign_events_to_trial requires ascending timestamps so no NaNs allowed.</span>
            <span class="n">lims</span><span class="p">[</span><span class="n">go_trials</span><span class="p">]</span> <span class="o">=</span> <span class="n">stim_freeze</span><span class="p">[</span><span class="n">go_trials</span><span class="p">]</span>
        <span class="c1"># take last event after freeze/stim on trigger, before stim off trigger</span>
        <span class="n">stim_freeze</span> <span class="o">=</span> <span class="n">_assign_events_to_trial</span><span class="p">(</span><span class="n">lims</span><span class="p">,</span> <span class="n">f2ttl_t</span><span class="p">,</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">,</span> <span class="n">t_trial_end</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOffTrigger_times&#39;</span><span class="p">])</span>
        <span class="n">fpga_trials</span><span class="p">[</span><span class="s1">&#39;stimFreeze_times&#39;</span><span class="p">][</span><span class="n">go_trials</span><span class="p">]</span> <span class="o">=</span> <span class="n">stim_freeze</span><span class="p">[</span><span class="n">go_trials</span><span class="p">]</span>
        <span class="c1"># Feedback times are valve open on correct trials and error tone in on incorrect trials</span>
        <span class="n">fpga_trials</span><span class="p">[</span><span class="s1">&#39;feedback_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">fpga_trials</span><span class="p">[</span><span class="s1">&#39;valveOpen_times&#39;</span><span class="p">])</span>
        <span class="n">ind_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fpga_trials</span><span class="p">[</span><span class="s1">&#39;valveOpen_times&#39;</span><span class="p">])</span>
        <span class="n">fpga_trials</span><span class="p">[</span><span class="s1">&#39;feedback_times&#39;</span><span class="p">][</span><span class="n">ind_err</span><span class="p">]</span> <span class="o">=</span> <span class="n">fpga_trials</span><span class="p">[</span><span class="s1">&#39;errorCue_times&#39;</span><span class="p">][</span><span class="n">ind_err</span><span class="p">]</span>

        <span class="c1"># Use ibpod to discard the final trial if it is incomplete</span>
        <span class="c1"># ibpod should be indices of all Bpod trials, even those that were not detected on the FPGA</span>
        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">fpga_trials</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">ibpod</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fpga_trials</span><span class="o">.</span><span class="n">keys</span><span class="p">()})</span>

        <span class="k">if</span> <span class="n">display</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">width</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">ymax</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;Bpod FPGA Sync&#39;</span><span class="p">)</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">display</span>
            <span class="n">plots</span><span class="o">.</span><span class="n">squares</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">plots</span><span class="o">.</span><span class="n">squares</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">plots</span><span class="o">.</span><span class="n">squares</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">audio</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">audio</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.4</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">color_map</span> <span class="o">=</span> <span class="n">TABLEAU_COLORS</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">event_name</span><span class="p">,</span> <span class="n">event_times</span><span class="p">),</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fpga_events</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">cycle</span><span class="p">(</span><span class="n">color_map</span><span class="p">)):</span>
                <span class="n">plots</span><span class="o">.</span><span class="n">vertical_lines</span><span class="p">(</span><span class="n">event_times</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">ymax</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">event_name</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>
            <span class="c1"># Plot the stimulus events along with the trigger times</span>
            <span class="n">stim_events</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="s1">&#39;stim&#39;</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fpga_trials</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">event_name</span><span class="p">,</span> <span class="n">event_times</span><span class="p">),</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stim_events</span><span class="p">,</span> <span class="n">cycle</span><span class="p">(</span><span class="n">color_map</span><span class="p">)):</span>
                <span class="n">plots</span><span class="o">.</span><span class="n">vertical_lines</span><span class="p">(</span>
                    <span class="n">event_times</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">ymax</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">event_name</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
                <span class="n">nm</span> <span class="o">=</span> <span class="n">event_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_times&#39;</span><span class="p">,</span> <span class="s1">&#39;Trigger_times&#39;</span><span class="p">)</span>
                <span class="n">plots</span><span class="o">.</span><span class="n">vertical_lines</span><span class="p">(</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">nm</span><span class="p">],</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">ymax</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">nm</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;bpod&#39;</span><span class="p">,</span> <span class="s1">&#39;f2ttl&#39;</span><span class="p">,</span> <span class="s1">&#39;audio&#39;</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="FpgaTrials.get_wheel_positions">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.FpgaTrials.get_wheel_positions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_wheel_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract wheel and wheelMoves objects.</span>

<span class="sd">        This method is called by the main extract method and may be overloaded by subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_wheel_positions</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="FpgaTrials.get_stimulus_update_times">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.FpgaTrials.get_stimulus_update_times">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_stimulus_update_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract stimulus update times from sync.</span>

<span class="sd">        Gets the stimulus times from the frame2ttl channel and cleans the signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sync : dict</span>
<span class="sd">            A dictionary with keys (&#39;times&#39;, &#39;polarities&#39;, &#39;channels&#39;), containing the sync pulses</span>
<span class="sd">            and the corresponding channel numbers.</span>
<span class="sd">        chmap : dict</span>
<span class="sd">            A map of channel names and their corresponding indices. Must contain a &#39;frame2ttl&#39; key.</span>
<span class="sd">        display : bool</span>
<span class="sd">            If true, plots the input TTLs and the cleaned output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary with keys {&#39;times&#39;, &#39;polarities&#39;} containing stimulus TTL fronts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frame2ttl</span> <span class="o">=</span> <span class="n">get_sync_fronts</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">[</span><span class="s1">&#39;frame2ttl&#39;</span><span class="p">])</span>
        <span class="n">frame2ttl</span> <span class="o">=</span> <span class="n">_clean_frame2ttl</span><span class="p">(</span><span class="n">frame2ttl</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">frame2ttl</span></div>


<div class="viewcode-block" id="FpgaTrials.get_audio_event_times">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.FpgaTrials.get_audio_event_times">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_audio_event_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="n">audio_event_ttls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract audio times from sync.</span>

<span class="sd">        Gets the TTL times from the &#39;audio&#39; channel, cleans the signal, and classifies each TTL</span>
<span class="sd">        event by length.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sync : dict</span>
<span class="sd">            A dictionary with keys (&#39;times&#39;, &#39;polarities&#39;, &#39;channels&#39;), containing the sync pulses</span>
<span class="sd">            and the corresponding channel numbers.</span>
<span class="sd">        chmap : dict</span>
<span class="sd">            A map of channel names and their corresponding indices. Must contain an &#39;audio&#39; key.</span>
<span class="sd">        audio_event_ttls : dict</span>
<span class="sd">            A map of event names to (min, max) TTL length.</span>
<span class="sd">        display : bool</span>
<span class="sd">            If true, plots the input TTLs and the cleaned output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary with keys {&#39;times&#39;, &#39;polarities&#39;} containing audio TTL fronts.</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary of events (from `audio_event_ttls`) and their intervals as an Nx2 array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">audio</span> <span class="o">=</span> <span class="n">get_sync_fronts</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">[</span><span class="s1">&#39;audio&#39;</span><span class="p">])</span>
        <span class="n">audio</span> <span class="o">=</span> <span class="n">_clean_audio</span><span class="p">(</span><span class="n">audio</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">audio</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;No audio sync fronts found.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">audio_event_ttls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># For training/biased/ephys protocols, the ready tone should be below 110 ms. The error</span>
            <span class="c1"># tone should be between 400ms and 1200ms</span>
            <span class="n">audio_event_ttls</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ready_tone&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1101</span><span class="p">),</span> <span class="s1">&#39;error_tone&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)}</span>
        <span class="n">audio_event_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assign_events</span><span class="p">(</span><span class="n">audio</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="n">audio</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">],</span> <span class="n">audio_event_ttls</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">audio</span><span class="p">,</span> <span class="n">audio_event_intervals</span></div>


<div class="viewcode-block" id="FpgaTrials.get_bpod_event_times">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.FpgaTrials.get_bpod_event_times">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_bpod_event_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="n">bpod_event_ttls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract Bpod times from sync.</span>

<span class="sd">        Gets the Bpod TTL times from the sync &#39;bpod&#39; channel and classifies each TTL event by</span>
<span class="sd">        length. NB: The first trial has an abnormal trial_start TTL that is usually mis-assigned.</span>
<span class="sd">        This method accounts for this.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sync : dict</span>
<span class="sd">            A dictionary with keys (&#39;times&#39;, &#39;polarities&#39;, &#39;channels&#39;), containing the sync pulses</span>
<span class="sd">            and the corresponding channel numbers. Must contain a &#39;bpod&#39; key.</span>
<span class="sd">        chmap : dict</span>
<span class="sd">            A map of channel names and their corresponding indices.</span>
<span class="sd">        bpod_event_ttls : dict of tuple</span>
<span class="sd">            A map of event names to (min, max) TTL length.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary with keys {&#39;times&#39;, &#39;polarities&#39;} containing Bpod TTL fronts.</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary of events (from `bpod_event_ttls`) and their intervals as an Nx2 array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bpod</span> <span class="o">=</span> <span class="n">get_sync_fronts</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">[</span><span class="s1">&#39;bpod&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">bpod</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">err</span><span class="o">.</span><span class="n">SyncBpodFpgaException</span><span class="p">(</span><span class="s1">&#39;No Bpod event found in FPGA. No behaviour extraction. &#39;</span>
                                            <span class="s1">&#39;Check channel maps.&#39;</span><span class="p">)</span>
        <span class="c1"># Assign the Bpod BNC2 events based on TTL length. The defaults are below, however these</span>
        <span class="c1"># lengths are defined by the state machine of the task protocol and therefore vary.</span>
        <span class="k">if</span> <span class="n">bpod_event_ttls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># For training/biased/ephys protocols, the trial start TTL length is 0.1ms but this has</span>
            <span class="c1"># proven to drift on some Bpods and this is the highest possible value that</span>
            <span class="c1"># discriminates trial start from valve. Valve open events are between 50ms to 300 ms.</span>
            <span class="c1"># ITI events are above 400 ms.</span>
            <span class="n">bpod_event_ttls</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;trial_start&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.33e-4</span><span class="p">),</span> <span class="s1">&#39;valve_open&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">2.33e-4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">),</span> <span class="s1">&#39;trial_end&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)}</span>
        <span class="n">bpod_event_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assign_events</span><span class="p">(</span>
            <span class="n">bpod</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="n">bpod</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">],</span> <span class="n">bpod_event_ttls</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;trial_start&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bpod_event_intervals</span> <span class="ow">or</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_delay_initiation</span><span class="p">()):</span>
            <span class="k">return</span> <span class="n">bpod</span><span class="p">,</span> <span class="n">bpod_event_intervals</span>

        <span class="c1"># The first trial pulse is longer and often assigned to another event.</span>
        <span class="c1"># Here we move the earliest non-trial_start event to the trial_start array.</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_start&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># expect 1st event to be trial_start</span>
        <span class="n">pretrial</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">bpod_event_intervals</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">t0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pretrial</span><span class="p">:</span>
            <span class="p">(</span><span class="n">pretrial</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pretrial</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># take the earliest event</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bpod_event_intervals</span><span class="p">[</span><span class="n">pretrial</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="mf">1e3</span>  <span class="c1"># record TTL length to log</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Reassigning first </span><span class="si">%s</span><span class="s1"> to trial_start. TTL length = </span><span class="si">%.3g</span><span class="s1"> ms&#39;</span><span class="p">,</span> <span class="n">pretrial</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
            <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span>
                <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="n">pretrial</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_start&#39;</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="n">pretrial</span><span class="p">]</span> <span class="o">=</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="n">pretrial</span><span class="p">][</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">bpod</span><span class="p">,</span> <span class="n">bpod_event_intervals</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_assign_events</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">polarities</span><span class="p">,</span> <span class="n">event_lengths</span><span class="p">,</span> <span class="n">precedence</span><span class="o">=</span><span class="s1">&#39;shortest&#39;</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classify TTL events by length.</span>

<span class="sd">        Outputs the synchronisation events such as trial intervals, valve opening, and audio.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ts : numpy.array</span>
<span class="sd">            Numpy vector containing times of TTL fronts.</span>
<span class="sd">        polarities : numpy.array</span>
<span class="sd">            Numpy vector containing polarity of TTL fronts (1 rise, -1 fall).</span>
<span class="sd">        event_lengths : dict of tuple</span>
<span class="sd">            A map of TTL events and the range of permissible lengths, where l0 &lt; ttl &lt;= l1.</span>
<span class="sd">        precedence : str {&#39;shortest&#39;, &#39;longest&#39;, &#39;dict order&#39;}</span>
<span class="sd">            In the case of overlapping event TTL lengths, assign shortest/longest first or go by</span>
<span class="sd">            the `event_lengths` dict order.</span>
<span class="sd">        display : bool</span>
<span class="sd">            If true, plots the TTLs with coloured lines delineating the assigned events.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict[str, numpy.array]</span>
<span class="sd">            A dictionary of events and their intervals as an Nx2 array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        _assign_events_to_trial - classify TTLs by event order within a given trial period.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">event_intervals</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">event_lengths</span><span class="p">)</span>
        <span class="k">assert</span> <span class="s1">&#39;unassigned&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">event_lengths</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[],</span> <span class="p">[]])</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="o">*</span><span class="n">event_lengths</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="s1">&#39;unassigned&#39;</span><span class="p">)}</span>

        <span class="c1"># make sure that there are no 2 consecutive fall or consecutive rise events</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">polarities</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">polarities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">polarities</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if the final TTL is left HIGH, insert a NaN</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">ts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
        <span class="c1"># take only even time differences: i.e. from rising to falling fronts</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">)[::</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Assign events from shortest TTL to largest</span>
        <span class="n">assigned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">precedence</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;shortest&#39;</span><span class="p">:</span>
            <span class="n">event_items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">event_lengths</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">precedence</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;longest&#39;</span><span class="p">:</span>
            <span class="n">event_items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">event_lengths</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">precedence</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;dict order&#39;</span><span class="p">:</span>
            <span class="n">event_items</span> <span class="o">=</span> <span class="n">event_lengths</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Precedence must be one of &quot;shortest&quot;, &quot;longest&quot;, &quot;dict order&quot;, got &quot;</span><span class="si">{</span><span class="n">precedence</span><span class="si">}</span><span class="s1">&quot;.&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="p">(</span><span class="n">min_len</span><span class="p">,</span> <span class="n">max_len</span><span class="p">)</span> <span class="ow">in</span> <span class="n">event_items</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%.4G</span><span class="s1"> &lt; ttl &lt;= </span><span class="si">%.4G</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">min_len</span><span class="p">,</span> <span class="n">max_len</span><span class="p">)</span>
            <span class="n">i_event</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">dt</span> <span class="o">&gt;</span> <span class="n">min_len</span><span class="p">,</span> <span class="n">dt</span> <span class="o">&lt;=</span> <span class="n">max_len</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="n">i_event</span> <span class="o">=</span> <span class="n">i_event</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">assigned</span><span class="p">[</span><span class="n">i_event</span><span class="p">])[</span><span class="mi">0</span><span class="p">]]</span>  <span class="c1"># remove those already assigned</span>
            <span class="n">event_intervals</span><span class="p">[</span><span class="n">event</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">ts</span><span class="p">[</span><span class="n">i_event</span><span class="p">],</span> <span class="n">ts</span><span class="p">[</span><span class="n">i_event</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">assigned</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">i_event</span><span class="p">,</span> <span class="n">i_event</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Include the unassigned events for convenience and debugging</span>
        <span class="n">event_intervals</span><span class="p">[</span><span class="s1">&#39;unassigned&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="o">~</span><span class="n">assigned</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Assert that event TTLs mutually exclusive</span>
        <span class="n">all_assigned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">event_intervals</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">all_assigned</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_assigned</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;TTLs assigned to multiple events&#39;</span>

        <span class="c1"># some debug plots when needed</span>
        <span class="k">if</span> <span class="n">display</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plots</span><span class="o">.</span><span class="n">squares</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">polarities</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;raw fronts&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="n">intervals</span> <span class="ow">in</span> <span class="n">event_intervals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">plots</span><span class="o">.</span><span class="n">vertical_lines</span><span class="p">(</span><span class="n">intervals</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">ymin</span><span class="o">=-</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">event</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

        <span class="c1"># Return map of event intervals in the same order as `event_lengths` dict</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">event_intervals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="o">*</span><span class="n">event_lengths</span><span class="p">,</span> <span class="s1">&#39;unassigned&#39;</span><span class="p">)}</span>

<div class="viewcode-block" id="FpgaTrials.sync_bpod_clock">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.FpgaTrials.sync_bpod_clock">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sync_bpod_clock</span><span class="p">(</span><span class="n">bpod_trials</span><span class="p">,</span> <span class="n">fpga_trials</span><span class="p">,</span> <span class="n">sync_field</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sync the Bpod clock to FPGA one using the provided trial event.</span>

<span class="sd">        It assumes that `sync_field` is in both `fpga_trials` and `bpod_trials`. Syncing on both</span>
<span class="sd">        intervals is not supported so to sync on trial start times, `sync_field` should be</span>
<span class="sd">        &#39;intervals_0&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bpod_trials : dict</span>
<span class="sd">            A dictionary of extracted Bpod trial events.</span>
<span class="sd">        fpga_trials : dict</span>
<span class="sd">            A dictionary of TTL events extracted from FPGA sync (see `extract_behaviour_sync`</span>
<span class="sd">            method).</span>
<span class="sd">        sync_field : str</span>
<span class="sd">            The trials key to use for syncing clocks. For intervals (i.e. Nx2 arrays) append the</span>
<span class="sd">            column index, e.g. &#39;intervals_0&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        function</span>
<span class="sd">            Interpolation function such that f(timestamps_bpod) = timestamps_fpga.</span>
<span class="sd">        float</span>
<span class="sd">            The clock drift in parts per million.</span>
<span class="sd">        numpy.array of int</span>
<span class="sd">            The indices of the Bpod trial events in the FPGA trial events array.</span>
<span class="sd">        numpy.array of int</span>
<span class="sd">            The indices of the FPGA trial events in the Bpod trial events array.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            The key `sync_field` was not found in either the `bpod_trials` or `fpga_trials` dicts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Attempting to align Bpod clock to DAQ using trial event &quot;</span><span class="si">{</span><span class="n">sync_field</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
        <span class="n">bpod_fpga_timestamps</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">trials</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">bpod_trials</span><span class="p">,</span> <span class="n">fpga_trials</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">sync_field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">trials</span><span class="p">:</span>
                <span class="c1"># handle syncing on intervals</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">m</span> <span class="o">:=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.*)_(\d)&#39;</span><span class="p">,</span> <span class="n">sync_field</span><span class="p">)):</span>
                    <span class="c1"># If missing from bpod trials, either the sync field is incorrect,</span>
                    <span class="c1"># or the Bpod extractor is incorrect. If missing from the fpga events, check</span>
                    <span class="c1"># the sync field and the `extract_behaviour_sync` method.</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Sync field &quot;</span><span class="si">{</span><span class="n">sync_field</span><span class="si">}</span><span class="s1">&quot; not in extracted </span><span class="si">{</span><span class="s2">&quot;fpga&quot;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s2">&quot;bpod&quot;</span><span class="si">}</span><span class="s1"> events&#39;</span><span class="p">)</span>
                <span class="n">_sync_field</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
                <span class="n">bpod_fpga_timestamps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">trials</span><span class="p">[</span><span class="n">_sync_field</span><span class="p">][:,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bpod_fpga_timestamps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">trials</span><span class="p">[</span><span class="n">sync_field</span><span class="p">]</span>

        <span class="c1"># Sync the two timestamps</span>
        <span class="n">fcn</span><span class="p">,</span> <span class="n">drift</span><span class="p">,</span> <span class="n">ibpod</span><span class="p">,</span> <span class="n">ifpga</span> <span class="o">=</span> <span class="n">ibldsp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">sync_timestamps</span><span class="p">(</span><span class="o">*</span><span class="n">bpod_fpga_timestamps</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># If it&#39;s drifting too much throw warning or error</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;N trials: </span><span class="si">%i</span><span class="s1"> bpod, </span><span class="si">%i</span><span class="s1"> FPGA, </span><span class="si">%i</span><span class="s1"> merged, sync </span><span class="si">%.5f</span><span class="s1"> ppm&#39;</span><span class="p">,</span>
                     <span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">bpod_fpga_timestamps</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ibpod</span><span class="p">),</span> <span class="n">drift</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drift</span> <span class="o">&gt;</span> <span class="mi">200</span> <span class="ow">and</span> <span class="n">bpod_fpga_timestamps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">bpod_fpga_timestamps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">err</span><span class="o">.</span><span class="n">SyncBpodFpgaException</span><span class="p">(</span><span class="s1">&#39;sync cluster f*ck&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">drift</span> <span class="o">&gt;</span> <span class="n">BPOD_FPGA_DRIFT_THRESHOLD_PPM</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;BPOD/FPGA synchronization shows values greater than </span><span class="si">%.2f</span><span class="s1"> ppm&#39;</span><span class="p">,</span>
                            <span class="n">BPOD_FPGA_DRIFT_THRESHOLD_PPM</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fcn</span><span class="p">,</span> <span class="n">drift</span><span class="p">,</span> <span class="n">ibpod</span><span class="p">,</span> <span class="n">ifpga</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_has_delay_initiation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the first trial has a `delay_initiation` state.</span>

<span class="sd">        Prior to iblrig v8.28.0, the first trial was used to handle, both, the detection of camera pulses and the</span>
<span class="sd">        handling of the initial delay. This may cause issues with the extraction of events during the first trial.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if iblrig version &lt; 8.28.0 or the first trial has a `delay_initiation` state, False otherwise.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method only returns valid results if, both, `self.settings` and `self.bpod_extractor` are set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">iblrig_version</span> <span class="o">=</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;IBLRIG_VERSION&quot;</span><span class="p">,</span> <span class="s2">&quot;0.0.0&quot;</span><span class="p">))</span>
        <span class="n">has_delay_init</span> <span class="o">=</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;bpod_extractor&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;delay_initiation&#39;</span> <span class="ow">in</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">bpod_extractor</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;behavior_data&#39;</span><span class="p">][</span><span class="s1">&#39;States timestamps&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">iblrig_version</span> <span class="o">&lt;</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;8.28.0&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">has_delay_init</span></div>



<div class="viewcode-block" id="FpgaTrialsHabituation">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.FpgaTrialsHabituation">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FpgaTrialsHabituation</span><span class="p">(</span><span class="n">FpgaTrials</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract habituationChoiceWorld trial events from an NI DAQ.&quot;&quot;&quot;</span>

    <span class="n">save_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_ibl_trials.stimCenter_times.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;_ibl_trials.feedbackType.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;_ibl_trials.rewardVolume.npy&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;_ibl_trials.stimOff_times.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;_ibl_trials.contrastLeft.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;_ibl_trials.contrastRight.npy&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;_ibl_trials.feedback_times.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;_ibl_trials.stimOn_times.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;_ibl_trials.stimOnTrigger_times.npy&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;_ibl_trials.intervals.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;_ibl_trials.goCue_times.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;_ibl_trials.goCueTrigger_times.npy&#39;</span><span class="p">,</span>
                  <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;tuple of str: The filenames of each extracted dataset, or None if array should not be saved.&quot;&quot;&quot;</span>

    <span class="n">var_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;stimCenter_times&#39;</span><span class="p">,</span> <span class="s1">&#39;feedbackType&#39;</span><span class="p">,</span> <span class="s1">&#39;rewardVolume&#39;</span><span class="p">,</span> <span class="s1">&#39;stimOff_times&#39;</span><span class="p">,</span> <span class="s1">&#39;contrastLeft&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;contrastRight&#39;</span><span class="p">,</span> <span class="s1">&#39;feedback_times&#39;</span><span class="p">,</span> <span class="s1">&#39;stimOn_times&#39;</span><span class="p">,</span> <span class="s1">&#39;stimOnTrigger_times&#39;</span><span class="p">,</span> <span class="s1">&#39;intervals&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;goCue_times&#39;</span><span class="p">,</span> <span class="s1">&#39;goCueTrigger_times&#39;</span><span class="p">,</span> <span class="s1">&#39;itiIn_times&#39;</span><span class="p">,</span> <span class="s1">&#39;stimOffTrigger_times&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;stimCenterTrigger_times&#39;</span><span class="p">,</span> <span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;tuple of str: A list of names for the extracted variables. These become the returned output keys.&quot;&quot;&quot;</span>

    <span class="n">bpod_rsync_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;intervals&#39;</span><span class="p">,</span> <span class="s1">&#39;stimOn_times&#39;</span><span class="p">,</span> <span class="s1">&#39;feedback_times&#39;</span><span class="p">,</span> <span class="s1">&#39;stimCenterTrigger_times&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;goCue_times&#39;</span><span class="p">,</span> <span class="s1">&#39;itiIn_times&#39;</span><span class="p">,</span> <span class="s1">&#39;stimOffTrigger_times&#39;</span><span class="p">,</span> <span class="s1">&#39;stimOff_times&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;stimCenter_times&#39;</span><span class="p">,</span> <span class="s1">&#39;stimOnTrigger_times&#39;</span><span class="p">,</span> <span class="s1">&#39;goCueTrigger_times&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;tuple of str: Fields from Bpod extractor that we want to re-sync to FPGA.&quot;&quot;&quot;</span>

    <span class="n">bpod_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;feedbackType&#39;</span><span class="p">,</span> <span class="s1">&#39;rewardVolume&#39;</span><span class="p">,</span> <span class="s1">&#39;contrastLeft&#39;</span><span class="p">,</span> <span class="s1">&#39;contrastRight&#39;</span><span class="p">,</span> <span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;tuple of str: Fields from Bpod extractor that we want to save.&quot;&quot;&quot;</span>

    <span class="n">sync_field</span> <span class="o">=</span> <span class="s1">&#39;feedback_times&#39;</span>  <span class="c1"># valve open events</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;str: The trial event to synchronize (must be present in extracted trials).&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sync_collection</span><span class="o">=</span><span class="s1">&#39;raw_ephys_data&#39;</span><span class="p">,</span>
                 <span class="n">task_collection</span><span class="o">=</span><span class="s1">&#39;raw_behavior_data&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract habituationChoiceWorld trial events from an NI DAQ.</span>

<span class="sd">        It is essential that the `var_names`, `bpod_rsync_fields`, `bpod_fields`, and `sync_field`</span>
<span class="sd">        attributes are all correct for the bpod protocol used.</span>

<span class="sd">        Unlike FpgaTrials, this class assumes different Bpod TTL events and syncs the Bpod clock</span>
<span class="sd">        using the valve open times, instead of the trial start times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sync : dict</span>
<span class="sd">            A dictionary with keys (&#39;times&#39;, &#39;polarities&#39;, &#39;channels&#39;), containing the sync pulses</span>
<span class="sd">            and the corresponding channel numbers. If None, the sync is loaded using the</span>
<span class="sd">            `load_sync` method.</span>
<span class="sd">        dict</span>
<span class="sd">            A map of channel names and their corresponding indices. If None, the channel map is</span>
<span class="sd">            loaded using the `load_sync` method.</span>
<span class="sd">        sync_collection : str</span>
<span class="sd">            The session subdirectory where the sync data are located. This is only used if the</span>
<span class="sd">            sync or channel maps are not provided.</span>
<span class="sd">        task_collection : str</span>
<span class="sd">            The session subdirectory where the raw Bpod data are located. This is used for loading</span>
<span class="sd">            the task settings and extracting the bpod trials, if not already done.</span>
<span class="sd">        protocol_number : int</span>
<span class="sd">            The protocol number if multiple protocols were run during the session. If provided, a</span>
<span class="sd">            spacer signal must be present in order to determine the correct period.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Optional arguments for class methods, e.g. &#39;display&#39;, &#39;bpod_event_ttls&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary of numpy arrays with `FpgaTrialsHabituation.var_names` as keys.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Version check: the ITI in TTL was added in a later version</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">load_settings</span><span class="p">(</span><span class="n">session_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">session_path</span><span class="p">,</span> <span class="n">task_collection</span><span class="o">=</span><span class="n">task_collection</span><span class="p">)</span>
        <span class="n">iblrig_version</span> <span class="o">=</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;IBL_VERSION&#39;</span><span class="p">,</span> <span class="s1">&#39;0.0.0&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;8.9.3&#39;</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">iblrig_version</span> <span class="o">&lt;</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;8.12.6&#39;</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;A second 1s TTL was added in this version during the &#39;iti&#39; state, however this is</span>
<span class="sd">            unrelated to the trial ITI and is unfortunately the same length as the trial start TTL.&quot;&quot;&quot;</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Ambiguous TTLs in 8.9.3 &gt;= version &lt; 8.12.6&#39;</span><span class="p">)</span>

        <span class="n">trials</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="n">sync</span><span class="o">=</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="o">=</span><span class="n">chmap</span><span class="p">,</span> <span class="n">sync_collection</span><span class="o">=</span><span class="n">sync_collection</span><span class="p">,</span>
                                  <span class="n">task_collection</span><span class="o">=</span><span class="n">task_collection</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">trials</span>

<div class="viewcode-block" id="FpgaTrialsHabituation.get_bpod_event_times">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.FpgaTrialsHabituation.get_bpod_event_times">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_bpod_event_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="n">bpod_event_ttls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract Bpod times from sync.</span>

<span class="sd">        Currently (at least v8.12 and below) there is no trial start or end TTL, only an ITI pulse.</span>
<span class="sd">        Also the first trial pulse is incorrectly assigned due to its abnormal length.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sync : dict</span>
<span class="sd">            A dictionary with keys (&#39;times&#39;, &#39;polarities&#39;, &#39;channels&#39;), containing the sync pulses</span>
<span class="sd">            and the corresponding channel numbers. Must contain a &#39;bpod&#39; key.</span>
<span class="sd">        chmap : dict</span>
<span class="sd">            A map of channel names and their corresponding indices.</span>
<span class="sd">        bpod_event_ttls : dict of tuple</span>
<span class="sd">            A map of event names to (min, max) TTL length.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary with keys {&#39;times&#39;, &#39;polarities&#39;} containing Bpod TTL fronts.</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary of events (from `bpod_event_ttls`) and their intervals as an Nx2 array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bpod</span> <span class="o">=</span> <span class="n">get_sync_fronts</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">[</span><span class="s1">&#39;bpod&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">bpod</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">err</span><span class="o">.</span><span class="n">SyncBpodFpgaException</span><span class="p">(</span><span class="s1">&#39;No Bpod event found in FPGA. No behaviour extraction. &#39;</span>
                                            <span class="s1">&#39;Check channel maps.&#39;</span><span class="p">)</span>
        <span class="c1"># Assign the Bpod BNC2 events based on TTL length. The defaults are below, however these</span>
        <span class="c1"># lengths are defined by the state machine of the task protocol and therefore vary.</span>
        <span class="k">if</span> <span class="n">bpod_event_ttls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Currently (at least v8.12 and below) there is no trial start or end TTL, only an ITI pulse</span>
            <span class="n">bpod_event_ttls</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;trial_iti&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">.999</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">),</span> <span class="s1">&#39;valve_open&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)}</span>
        <span class="n">bpod_event_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assign_events</span><span class="p">(</span>
            <span class="n">bpod</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="n">bpod</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">],</span> <span class="n">bpod_event_ttls</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">)</span>

        <span class="c1"># The first trial pulse is shorter and assigned to valve_open. Here we remove the first</span>
        <span class="c1"># valve event, prepend a 0 to the trial_start events, and drop the last trial if it was</span>
        <span class="c1"># incomplete in Bpod.</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_iti&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># expect 1st event to be trial_start</span>
        <span class="n">pretrial</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">bpod_event_intervals</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">t0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pretrial</span><span class="p">:</span>
            <span class="p">(</span><span class="n">pretrial</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pretrial</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># take the earliest event</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bpod_event_intervals</span><span class="p">[</span><span class="n">pretrial</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="mf">1e3</span>  <span class="c1"># record TTL length to log</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Reassigning first </span><span class="si">%s</span><span class="s1"> to trial_start. TTL length = </span><span class="si">%.3g</span><span class="s1"> ms&#39;</span><span class="p">,</span> <span class="n">pretrial</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
            <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_iti&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span>
                <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="n">pretrial</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_iti&#39;</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="n">pretrial</span><span class="p">]</span> <span class="o">=</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="n">pretrial</span><span class="p">][</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">bpod</span><span class="p">,</span> <span class="n">bpod_event_intervals</span></div>


<div class="viewcode-block" id="FpgaTrialsHabituation.build_trials">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.FpgaTrialsHabituation.build_trials">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_trials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract task related event times from the sync.</span>

<span class="sd">        This is called by the superclass `_extract` method.  The key difference here is that the</span>
<span class="sd">        `trial_start` LOW-&gt;HIGH is the trial end, and HIGH-&gt;LOW is trial start.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sync : dict</span>
<span class="sd">            &#39;polarities&#39; of fronts detected on sync trace for all 16 chans and their &#39;times&#39;</span>
<span class="sd">        chmap : dict</span>
<span class="sd">            Map of channel names and their corresponding index.  Default to constant.</span>
<span class="sd">        display : bool, matplotlib.pyplot.Axes</span>
<span class="sd">            Show the full session sync pulses display.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A map of trial event timestamps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the events from the sync.</span>
        <span class="c1"># Store the cleaned frame2ttl, audio, and bpod pulses as this will be used for QC</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stimulus_update_times</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">audio</span><span class="p">,</span> <span class="n">audio_event_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_audio_event_times</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bpod</span><span class="p">,</span> <span class="n">bpod_event_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bpod_event_times</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">bpod_event_intervals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="p">{</span><span class="s1">&#39;valve_open&#39;</span><span class="p">,</span> <span class="s1">&#39;trial_iti&#39;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Expected at least &quot;trial_iti&quot; and &quot;valve_open&quot; Bpod events. `bpod_event_ttls` kwarg may be incorrect.&#39;</span><span class="p">)</span>

        <span class="n">fpga_events</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">AlfBunch</span><span class="p">({</span>
            <span class="s1">&#39;feedback_times&#39;</span><span class="p">:</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;valve_open&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;valveClose_times&#39;</span><span class="p">:</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;valve_open&#39;</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="s1">&#39;intervals_0&#39;</span><span class="p">:</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_iti&#39;</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="s1">&#39;intervals_1&#39;</span><span class="p">:</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_iti&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;goCue_times&#39;</span><span class="p">:</span> <span class="n">audio_event_intervals</span><span class="p">[</span><span class="s1">&#39;ready_tone&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">})</span>

        <span class="c1"># Sync the Bpod clock to the DAQ.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bpod2fpga</span><span class="p">,</span> <span class="n">drift_ppm</span><span class="p">,</span> <span class="n">ibpod</span><span class="p">,</span> <span class="n">ifpga</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_bpod_clock</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">,</span> <span class="n">fpga_events</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_field</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">AlfBunch</span><span class="p">()</span>
        <span class="c1"># Add the Bpod trial events, converting the timestamp fields to FPGA time.</span>
        <span class="c1"># NB: The trial intervals are by default a Bpod rsync field.</span>
        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">ibpod</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_fields</span><span class="p">})</span>
        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod2fpga</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">ibpod</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_rsync_fields</span><span class="p">})</span>

        <span class="c1"># Assigning each event to a trial ensures exactly one event per trial (missing events are NaN)</span>
        <span class="n">trials</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">AlfBunch</span><span class="p">({</span>
            <span class="s1">&#39;goCue_times&#39;</span><span class="p">:</span> <span class="n">_assign_events_to_trial</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;goCueTrigger_times&#39;</span><span class="p">],</span> <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;goCue_times&#39;</span><span class="p">],</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">),</span>
            <span class="s1">&#39;feedback_times&#39;</span><span class="p">:</span> <span class="n">_assign_events_to_trial</span><span class="p">(</span><span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;intervals_0&#39;</span><span class="p">],</span> <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;feedback_times&#39;</span><span class="p">]),</span>
            <span class="s1">&#39;stimCenter_times&#39;</span><span class="p">:</span> <span class="n">_assign_events_to_trial</span><span class="p">(</span>
                <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimCenterTrigger_times&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="n">t_trial_end</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOffTrigger_times&#39;</span><span class="p">]),</span>
            <span class="s1">&#39;stimOn_times&#39;</span><span class="p">:</span> <span class="n">_assign_events_to_trial</span><span class="p">(</span>
                <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOnTrigger_times&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="n">t_trial_end</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimCenterTrigger_times&#39;</span><span class="p">]),</span>
            <span class="s1">&#39;stimOff_times&#39;</span><span class="p">:</span> <span class="n">_assign_events_to_trial</span><span class="p">(</span>
                <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOffTrigger_times&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span>
                <span class="n">take</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="n">t_trial_end</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;intervals&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
        <span class="p">})</span>
        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">trials</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">ifpga</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">trials</span><span class="o">.</span><span class="n">keys</span><span class="p">()})</span>

        <span class="c1"># If stim on occurs before trial end, use stim on time. Likewise for trial end and stim off</span>
        <span class="n">to_correct</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOn_times&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOn_times&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;intervals&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">to_correct</span><span class="p">):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1">/</span><span class="si">%i</span><span class="s1"> stim on events occurring outside trial intervals&#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">to_correct</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_correct</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;intervals&#39;</span><span class="p">][</span><span class="n">to_correct</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOn_times&#39;</span><span class="p">][</span><span class="n">to_correct</span><span class="p">]</span>
        <span class="n">to_correct</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOff_times&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOff_times&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;intervals&#39;</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">to_correct</span><span class="p">):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">%i</span><span class="s1">/</span><span class="si">%i</span><span class="s1"> stim off events occurring outside trial intervals; using stim off times as trial end&#39;</span><span class="p">,</span>
                <span class="nb">sum</span><span class="p">(</span><span class="n">to_correct</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_correct</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;intervals&#39;</span><span class="p">][</span><span class="n">to_correct</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOff_times&#39;</span><span class="p">][</span><span class="n">to_correct</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">display</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">width</span> <span class="o">=</span> <span class="mf">0.5</span>
            <span class="n">ymax</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;Bpod FPGA Sync&#39;</span><span class="p">)</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">display</span>
            <span class="n">plots</span><span class="o">.</span><span class="n">squares</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">plots</span><span class="o">.</span><span class="n">squares</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">plots</span><span class="o">.</span><span class="n">squares</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">audio</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">audio</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.4</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">color_map</span> <span class="o">=</span> <span class="n">TABLEAU_COLORS</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">event_name</span><span class="p">,</span> <span class="n">event_times</span><span class="p">),</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">trials</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">cycle</span><span class="p">(</span><span class="n">color_map</span><span class="p">)):</span>
                <span class="n">plots</span><span class="o">.</span><span class="n">vertical_lines</span><span class="p">(</span><span class="n">event_times</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">ymax</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">event_name</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;bpod&#39;</span><span class="p">,</span> <span class="s1">&#39;f2ttl&#39;</span><span class="p">,</span> <span class="s1">&#39;audio&#39;</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="get_sync_and_chn_map">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.get_sync_and_chn_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_sync_and_chn_map</span><span class="p">(</span><span class="n">session_path</span><span class="p">,</span> <span class="n">sync_collection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return sync and channel map for session based on collection where main sync is stored.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    session_path : str, pathlib.Path</span>
<span class="sd">        The absolute session path, i.e. &#39;/path/to/subject/yyyy-mm-dd/nnn&#39;.</span>
<span class="sd">    sync_collection : str</span>
<span class="sd">        The session subdirectory where the sync data are located.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    one.alf.io.AlfBunch</span>
<span class="sd">        A dictionary with keys (&#39;times&#39;, &#39;polarities&#39;, &#39;channels&#39;), containing the sync pulses and</span>
<span class="sd">        the corresponding channel numbers.</span>
<span class="sd">    dict</span>
<span class="sd">        A map of channel names and their corresponding indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sync_collection</span> <span class="o">==</span> <span class="s1">&#39;raw_ephys_data&#39;</span><span class="p">:</span>
        <span class="c1"># Check to see if we have nidq files, if we do just go with this otherwise go into other function that deals with</span>
        <span class="c1"># 3A probes</span>
        <span class="n">nidq_meta</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">session_path</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">sync_collection</span><span class="p">)</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*nidq.meta&#39;</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nidq_meta</span><span class="p">:</span>
            <span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span> <span class="o">=</span> <span class="n">get_main_probe_sync</span><span class="p">(</span><span class="n">session_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sync</span> <span class="o">=</span> <span class="n">load_sync</span><span class="p">(</span><span class="n">session_path</span><span class="p">,</span> <span class="n">sync_collection</span><span class="p">)</span>
            <span class="n">ef</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">()</span>
            <span class="n">ef</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">session_path</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">sync_collection</span><span class="p">)</span>
            <span class="n">ef</span><span class="p">[</span><span class="s1">&#39;nidq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nidq_meta</span>
            <span class="n">chmap</span> <span class="o">=</span> <span class="n">get_ibl_sync_map</span><span class="p">(</span><span class="n">ef</span><span class="p">,</span> <span class="s1">&#39;3B&#39;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">sync</span> <span class="o">=</span> <span class="n">load_sync</span><span class="p">(</span><span class="n">session_path</span><span class="p">,</span> <span class="n">sync_collection</span><span class="p">)</span>
        <span class="n">chmap</span> <span class="o">=</span> <span class="n">load_channel_map</span><span class="p">(</span><span class="n">session_path</span><span class="p">,</span> <span class="n">sync_collection</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span></div>



<div class="viewcode-block" id="load_channel_map">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.load_channel_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">load_channel_map</span><span class="p">(</span><span class="n">session_path</span><span class="p">,</span> <span class="n">sync_collection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load syncing channel map for session path and collection</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    session_path : str, pathlib.Path</span>
<span class="sd">        The absolute session path, i.e. &#39;/path/to/subject/yyyy-mm-dd/nnn&#39;.</span>
<span class="sd">    sync_collection : str</span>
<span class="sd">        The session subdirectory where the sync data are located.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A map of channel names and their corresponding indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">device</span> <span class="o">=</span> <span class="n">sync_collection</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">default_chmap</span> <span class="o">=</span> <span class="n">DEFAULT_MAPS</span><span class="p">[</span><span class="n">device</span><span class="p">][</span><span class="s1">&#39;nidq&#39;</span><span class="p">]</span>

    <span class="c1"># Try to load channel map from file</span>
    <span class="n">chmap</span> <span class="o">=</span> <span class="n">spikeglx</span><span class="o">.</span><span class="n">get_sync_map</span><span class="p">(</span><span class="n">session_path</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">sync_collection</span><span class="p">))</span>
    <span class="c1"># If chmap provided but not with all keys, fill up with default values</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">chmap</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default_chmap</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data_for_keys</span><span class="p">(</span><span class="n">default_chmap</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">chmap</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">chmap</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Keys missing from provided channel map, &#39;</span>
                            <span class="s1">&#39;setting missing keys from default channel map&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="o">**</span><span class="n">default_chmap</span><span class="p">,</span> <span class="o">**</span><span class="n">chmap</span><span class="p">}</span></div>



<div class="viewcode-block" id="load_sync">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.ephys_fpga.html#ibllib.io.extractors.ephys_fpga.load_sync">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">load_sync</span><span class="p">(</span><span class="n">session_path</span><span class="p">,</span> <span class="n">sync_collection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load sync files from session path and collection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    session_path : str, pathlib.Path</span>
<span class="sd">        The absolute session path, i.e. &#39;/path/to/subject/yyyy-mm-dd/nnn&#39;.</span>
<span class="sd">    sync_collection : str</span>
<span class="sd">        The session subdirectory where the sync data are located.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    one.alf.io.AlfBunch</span>
<span class="sd">        A dictionary with keys (&#39;times&#39;, &#39;polarities&#39;, &#39;channels&#39;), containing the sync pulses and</span>
<span class="sd">        the corresponding channel numbers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sync</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">load_object</span><span class="p">(</span><span class="n">session_path</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">sync_collection</span><span class="p">),</span> <span class="s1">&#39;sync&#39;</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;spikeglx&#39;</span><span class="p">,</span> <span class="n">short_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sync</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, International Brain Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>