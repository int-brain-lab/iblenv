

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ibllib.io.extractors.mesoscope &mdash; IBL Library  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/style.css?v=17142d56" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../../_static/copybutton.js?v=f281be69"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            IBL Library
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">The Open Neurophysiology Environment</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/one_quickstart.html">ONE Quick Start</a></li>
<li class="toctree-l1"><a class="reference external" href="https://int-brain-lab.github.io/ONE/">Full documentation Website for ONE</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Public</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../public_docs/public_introduction.html">Publicly available IBL data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/data_release_behavior.html">Data Release - Behavior</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../public_docs/data_release_pilot.html">Data Release - Pilot Dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/data_release_repro_ephys.html">Data Release - Reproducible Ephys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/data_release_brainwidemap.html">Data Release - Brain Wide Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/data_release_spikesorting_benchmarks.html">Data Release - Spike sorting benchmark datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../public_docs/information_contact.html">Information and troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exploring IBL Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/data_structure.html">Get to know the datasets and folder structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/data_download.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/data_download.html#Explore-and-download-data-using-the-ONE-api">Explore and download data using the ONE-api</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../loading_examples.html">Loading Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Miscellaneous</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../02_installation.html">Unified Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../09_contribution.html">How to contribute</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples &amp; Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../atlas_examples.html">Atlas Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/docs_wheel_moves.html">Working with wheel data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks_external/docs_wheel_screen_stimulus.html">Computing the stimulus position using the wheel</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../010_api_reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">IBL Library</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ibllib.io.extractors.mesoscope</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ibllib.io.extractors.mesoscope</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Mesoscope (timeline) data extraction.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">find_peaks</span>
<span class="kn">import</span> <span class="nn">one.alf.io</span> <span class="k">as</span> <span class="nn">alfio</span>
<span class="kn">from</span> <span class="nn">one.alf.path</span> <span class="kn">import</span> <span class="n">session_path_parts</span>
<span class="kn">from</span> <span class="nn">iblutil.util</span> <span class="kn">import</span> <span class="n">ensure_list</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">packaging</span> <span class="kn">import</span> <span class="n">version</span>

<span class="kn">from</span> <span class="nn">ibllib.plots.misc</span> <span class="kn">import</span> <span class="n">squares</span><span class="p">,</span> <span class="n">vertical_lines</span>
<span class="kn">from</span> <span class="nn">ibllib.io.raw_daq_loaders</span> <span class="kn">import</span> <span class="p">(</span><span class="n">extract_sync_timeline</span><span class="p">,</span> <span class="n">timeline_get_channel</span><span class="p">,</span>
                                       <span class="n">correct_counter_discontinuities</span><span class="p">,</span> <span class="n">load_timeline_sync_and_chmap</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">ibllib.io.extractors.base</span> <span class="k">as</span> <span class="nn">extractors_base</span>
<span class="kn">from</span> <span class="nn">ibllib.io.extractors.ephys_fpga</span> <span class="kn">import</span> <span class="n">FpgaTrials</span><span class="p">,</span> <span class="n">WHEEL_TICKS</span><span class="p">,</span> <span class="n">WHEEL_RADIUS_CM</span><span class="p">,</span> <span class="n">_assign_events_to_trial</span>
<span class="kn">from</span> <span class="nn">ibllib.io.extractors.training_wheel</span> <span class="kn">import</span> <span class="n">extract_wheel_moves</span>
<span class="kn">from</span> <span class="nn">ibllib.io.extractors.camera</span> <span class="kn">import</span> <span class="n">attribute_times</span>
<span class="kn">from</span> <span class="nn">brainbox.behavior.wheel</span> <span class="kn">import</span> <span class="n">velocity_filtered</span>

<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="patch_imaging_meta">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.mesoscope.html#ibllib.io.extractors.mesoscope.patch_imaging_meta">[docs]</a>
<span class="k">def</span> <span class="nf">patch_imaging_meta</span><span class="p">(</span><span class="n">meta</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Patch imaging metadata for compatibility across versions.</span>

<span class="sd">    A copy of the dict is NOT returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    meta : dict</span>
<span class="sd">        A folder path that contains a rawImagingData.meta file.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        The loaded metadata file, updated to the most recent version.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 2023-05-17 (unversioned) adds nFrames, channelSaved keys, MM and Deg keys</span>
    <span class="n">ver</span> <span class="o">=</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;version&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;0.0.0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ver</span> <span class="o">&lt;=</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;0.0.0&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;channelSaved&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">meta</span><span class="p">:</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;channelSaved&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;channelIdx&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;FOV&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;channelIdx&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">),</span> <span class="p">[])</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;topLeft&#39;</span><span class="p">,</span> <span class="s1">&#39;topRight&#39;</span><span class="p">,</span> <span class="s1">&#39;bottomLeft&#39;</span><span class="p">,</span> <span class="s1">&#39;bottomRight&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fov</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;FOV&#39;</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Deg&#39;</span><span class="p">,</span> <span class="s1">&#39;MM&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fov</span><span class="p">:</span>  <span class="c1"># topLeftDeg, etc. -&gt; Deg[topLeft]</span>
                    <span class="n">fov</span><span class="p">[</span><span class="n">unit</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">fov</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">f</span> <span class="o">+</span> <span class="n">unit</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">}</span>
    <span class="k">elif</span> <span class="n">ver</span> <span class="o">==</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;0.1.0&#39;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">fov</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;FOV&#39;</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="s1">&#39;roiUuid&#39;</span> <span class="ow">in</span> <span class="n">fov</span><span class="p">:</span>
                <span class="n">fov</span><span class="p">[</span><span class="s1">&#39;roiUUID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fov</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;roiUuid&#39;</span><span class="p">)</span>
    <span class="c1"># 2024-09-17 Modified the 2 unit vectors for the positive ML axis and the positive AP axis,</span>
    <span class="c1"># which then transform [X,Y] coordinates (in degrees) to [ML,AP] coordinates (in MM).</span>
    <span class="k">if</span> <span class="n">ver</span> <span class="o">&lt;</span> <span class="n">version</span><span class="o">.</span><span class="n">Version</span><span class="p">(</span><span class="s1">&#39;0.1.5&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;imageOrientation&#39;</span> <span class="ow">in</span> <span class="n">meta</span><span class="p">:</span>
        <span class="n">pos_ml</span><span class="p">,</span> <span class="n">pos_ap</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;imageOrientation&#39;</span><span class="p">][</span><span class="s1">&#39;positiveML&#39;</span><span class="p">],</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;imageOrientation&#39;</span><span class="p">][</span><span class="s1">&#39;positiveAP&#39;</span><span class="p">]</span>
        <span class="n">center_ml</span><span class="p">,</span> <span class="n">center_ap</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;centerMM&#39;</span><span class="p">][</span><span class="s1">&#39;ML&#39;</span><span class="p">],</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;centerMM&#39;</span><span class="p">][</span><span class="s1">&#39;AP&#39;</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;scanImageParams&#39;</span><span class="p">][</span><span class="s1">&#39;objectiveResolution&#39;</span><span class="p">]</span>
        <span class="c1"># previously [[0, res/1000], [-res/1000, 0], [0, 0]]</span>
        <span class="n">TF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">pos_ml</span><span class="p">,</span> <span class="n">pos_ap</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span> <span class="o">@</span> \
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">res</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">res</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">center_ml</span><span class="p">,</span> <span class="n">center_ap</span><span class="p">]))</span>
        <span class="n">TF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">TF</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># handle floating-point error by rounding</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">TF</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;coordsTF&#39;</span><span class="p">]):</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;coordsTF&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">TF</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">centerDegXY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;centerDeg&#39;</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;centerDeg&#39;</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">fov</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;FOV&#39;</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">fov</span><span class="p">[</span><span class="s1">&#39;MM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="n">centerDegXY</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">TF</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fov</span><span class="p">[</span><span class="s1">&#39;Deg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">assert</span> <span class="s1">&#39;nFrames&#39;</span> <span class="ow">in</span> <span class="n">meta</span><span class="p">,</span> <span class="s1">&#39;&quot;nFrames&quot; key missing from meta data; rawImagingData.meta.json likely an old version&#39;</span>
    <span class="k">return</span> <span class="n">meta</span></div>



<div class="viewcode-block" id="plot_timeline">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.mesoscope.html#ibllib.io.extractors.mesoscope.plot_timeline">[docs]</a>
<span class="k">def</span> <span class="nf">plot_timeline</span><span class="p">(</span><span class="n">timeline</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the timeline data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    timeline : one.alf.io.AlfBunch</span>
<span class="sd">        The timeline data object.</span>
<span class="sd">    channels : list of str</span>
<span class="sd">        An iterable of channel names to plot.</span>
<span class="sd">    raw : bool</span>
<span class="sd">        If true, plot the raw DAQ samples; if false, apply TTL thresholds and plot changes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    matplotlib.pyplot.Figure</span>
<span class="sd">        The figure containing timeline subplots.</span>
<span class="sd">    list of matplotlib.pyplot.Axes</span>
<span class="sd">        The axes for each timeline channel plotted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">):</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">timeline</span><span class="p">[</span><span class="s1">&#39;meta&#39;</span><span class="p">][</span><span class="s1">&#39;inputs&#39;</span><span class="p">]}</span>
    <span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span> <span class="ow">or</span> <span class="n">meta</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">ensure_list</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">raw</span><span class="p">:</span>
        <span class="n">chmap</span> <span class="o">=</span> <span class="p">{</span><span class="n">ch</span><span class="p">:</span> <span class="n">meta</span><span class="p">[</span><span class="n">ch</span><span class="p">][</span><span class="s1">&#39;arrayColumn&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">}</span>
        <span class="n">sync</span> <span class="o">=</span> <span class="n">extract_sync_timeline</span><span class="p">(</span><span class="n">timeline</span><span class="p">,</span> <span class="n">chmap</span><span class="o">=</span><span class="n">chmap</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">channels</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">raw</span><span class="p">:</span>
            <span class="c1"># axesScale controls vertical scaling of each trace (multiplicative)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">timeline</span><span class="p">[</span><span class="s1">&#39;raw&#39;</span><span class="p">][:,</span> <span class="n">meta</span><span class="p">[</span><span class="n">ch</span><span class="p">][</span><span class="s1">&#39;arrayColumn&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">meta</span><span class="p">[</span><span class="n">ch</span><span class="p">][</span><span class="s1">&#39;axesScale&#39;</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">timeline</span><span class="p">[</span><span class="s1">&#39;timestamps&#39;</span><span class="p">],</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">:=</span> <span class="n">sync</span><span class="p">[</span><span class="s1">&#39;channels&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chmap</span><span class="p">[</span><span class="n">ch</span><span class="p">]):</span>
            <span class="n">squares</span><span class="p">(</span><span class="n">sync</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span> <span class="n">sync</span><span class="p">[</span><span class="s1">&#39;polarities&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">),</span> <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="c1"># Add back x-axis ticks to the last plot</span>
    <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">get_current_fig_manager</span><span class="p">()</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">showMaximized</span><span class="p">()</span>  <span class="c1"># full screen</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">h_pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span></div>



<div class="viewcode-block" id="TimelineTrials">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.mesoscope.html#ibllib.io.extractors.mesoscope.TimelineTrials">[docs]</a>
<span class="k">class</span> <span class="nc">TimelineTrials</span><span class="p">(</span><span class="n">FpgaTrials</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Similar extraction to the FPGA, however counter and position channels are treated differently.&quot;&quot;&quot;</span>

    <span class="n">timeline</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;one.alf.io.AlfBunch: The timeline data object.&quot;&quot;&quot;</span>

    <span class="n">sync_field</span> <span class="o">=</span> <span class="s1">&#39;itiIn_times&#39;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;str: The trial event to synchronize (must be present in extracted trials).&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">sync_collection</span><span class="o">=</span><span class="s1">&#39;raw_sync_data&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An extractor for all ephys trial data, in Timeline time&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeline</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">load_object</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session_path</span> <span class="o">/</span> <span class="n">sync_collection</span><span class="p">,</span> <span class="s1">&#39;DAQdata&#39;</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;timeline&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="TimelineTrials.load_sync">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.mesoscope.html#ibllib.io.extractors.mesoscope.TimelineTrials.load_sync">[docs]</a>
    <span class="k">def</span> <span class="nf">load_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync_collection</span><span class="o">=</span><span class="s1">&#39;raw_sync_data&#39;</span><span class="p">,</span> <span class="n">chmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load the DAQ sync and channel map data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sync_collection : str</span>
<span class="sd">            The session subdirectory where the sync data are located.</span>
<span class="sd">        chmap : dict</span>
<span class="sd">            A map of channel names and their corresponding indices. If None, the channel map is</span>
<span class="sd">            loaded using the :func:`ibllib.io.raw_daq_loaders.timeline_meta2chmap` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        one.alf.io.AlfBunch</span>
<span class="sd">            A dictionary with keys (&#39;times&#39;, &#39;polarities&#39;, &#39;channels&#39;), containing the sync pulses</span>
<span class="sd">            and the corresponding channel numbers.</span>
<span class="sd">        dict</span>
<span class="sd">            A map of channel names and their corresponding indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeline</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeline</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">load_object</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session_path</span> <span class="o">/</span> <span class="n">sync_collection</span><span class="p">,</span> <span class="s1">&#39;DAQdata&#39;</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;timeline&#39;</span><span class="p">)</span>
        <span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span> <span class="o">=</span> <span class="n">load_timeline_sync_and_chmap</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session_path</span> <span class="o">/</span> <span class="n">sync_collection</span><span class="p">,</span> <span class="n">timeline</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeline</span><span class="p">,</span> <span class="n">chmap</span><span class="o">=</span><span class="n">chmap</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span></div>


    <span class="k">def</span> <span class="nf">_extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sync_collection</span><span class="o">=</span><span class="s1">&#39;raw_sync_data&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">trials</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="n">sync_collection</span><span class="o">=</span><span class="s1">&#39;raw_sync_data&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;display&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">plot_timeline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeline</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="n">chmap</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trials</span>

<div class="viewcode-block" id="TimelineTrials.get_bpod_event_times">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.mesoscope.html#ibllib.io.extractors.mesoscope.TimelineTrials.get_bpod_event_times">[docs]</a>
    <span class="k">def</span> <span class="nf">get_bpod_event_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="n">bpod_event_ttls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract Bpod times from sync.</span>

<span class="sd">        Unlike the superclass method. This one doesn&#39;t reassign the first trial pulse.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sync : dict</span>
<span class="sd">            A dictionary with keys (&#39;times&#39;, &#39;polarities&#39;, &#39;channels&#39;), containing the sync pulses</span>
<span class="sd">            and the corresponding channel numbers. Must contain a &#39;bpod&#39; key.</span>
<span class="sd">        chmap : dict</span>
<span class="sd">            A map of channel names and their corresponding indices.</span>
<span class="sd">        bpod_event_ttls : dict of tuple</span>
<span class="sd">            A map of event names to (min, max) TTL length.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary with keys {&#39;times&#39;, &#39;polarities&#39;} containing Bpod TTL fronts.</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary of events (from `bpod_event_ttls`) and their intervals as an Nx2 array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assign the Bpod BNC2 events based on TTL length. The defaults are below, however these</span>
        <span class="c1"># lengths are defined by the state machine of the task protocol and therefore vary.</span>
        <span class="k">if</span> <span class="n">bpod_event_ttls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The trial start TTLs are often too short for the low sampling rate of the DAQ and are</span>
            <span class="c1"># therefore not used in extraction</span>
            <span class="n">bpod_event_ttls</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;valve_open&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">2.33e-4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">),</span> <span class="s1">&#39;trial_end&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)}</span>
        <span class="n">bpod</span><span class="p">,</span> <span class="n">bpod_event_intervals</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_bpod_event_times</span><span class="p">(</span>
            <span class="n">sync</span><span class="o">=</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="o">=</span><span class="n">chmap</span><span class="p">,</span> <span class="n">bpod_event_ttls</span><span class="o">=</span><span class="n">bpod_event_ttls</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># TODO Here we can make use of the &#39;bpod_rising_edge&#39; channel, if available</span>
        <span class="k">return</span> <span class="n">bpod</span><span class="p">,</span> <span class="n">bpod_event_intervals</span></div>


<div class="viewcode-block" id="TimelineTrials.build_trials">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.mesoscope.html#ibllib.io.extractors.mesoscope.TimelineTrials.build_trials">[docs]</a>
    <span class="k">def</span> <span class="nf">build_trials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract task related event times from the sync.</span>

<span class="sd">        The two major differences are that the sampling rate is lower for imaging so the short Bpod</span>
<span class="sd">        trial start TTLs are often absent. For this reason, the sync happens using the ITI_in TTL.</span>

<span class="sd">        Second, the valve used at the mesoscope has a way to record the raw voltage across the</span>
<span class="sd">        solenoid, giving a more accurate readout of the valve&#39;s activity. If the reward_valve</span>
<span class="sd">        channel is present on the DAQ, this is used to extract the valve open times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sync : dict</span>
<span class="sd">            &#39;polarities&#39; of fronts detected on sync trace for all 16 chans and their &#39;times&#39;</span>
<span class="sd">        chmap : dict</span>
<span class="sd">            Map of channel names and their corresponding index.  Default to constant.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A map of trial event timestamps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the events from the sync.</span>
        <span class="c1"># Store the cleaned frame2ttl, audio, and bpod pulses as this will be used for QC</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stimulus_update_times</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">audio</span><span class="p">,</span> <span class="n">audio_event_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_audio_event_times</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">audio_event_intervals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="p">{</span><span class="s1">&#39;ready_tone&#39;</span><span class="p">,</span> <span class="s1">&#39;error_tone&#39;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Expected at least &quot;ready_tone&quot; and &quot;error_tone&quot; audio events.&#39;</span>
                <span class="s1">&#39;`audio_event_ttls` kwarg may be incorrect.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bpod</span><span class="p">,</span> <span class="n">bpod_event_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bpod_event_times</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">chmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">bpod_event_intervals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="p">{</span><span class="s1">&#39;valve_open&#39;</span><span class="p">,</span> <span class="s1">&#39;trial_end&#39;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Expected at least &quot;trial_end&quot; and &quot;valve_open&quot; audio events. &#39;</span>
                <span class="s1">&#39;`bpod_event_ttls` kwarg may be incorrect.&#39;</span><span class="p">)</span>

        <span class="n">t_iti_in</span><span class="p">,</span> <span class="n">t_trial_end</span> <span class="o">=</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;trial_end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">fpga_events</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">AlfBunch</span><span class="p">({</span>
            <span class="s1">&#39;itiIn_times&#39;</span><span class="p">:</span> <span class="n">t_iti_in</span><span class="p">,</span>
            <span class="s1">&#39;intervals_1&#39;</span><span class="p">:</span> <span class="n">t_trial_end</span><span class="p">,</span>
            <span class="s1">&#39;goCue_times&#39;</span><span class="p">:</span> <span class="n">audio_event_intervals</span><span class="p">[</span><span class="s1">&#39;ready_tone&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;errorTone_times&#39;</span><span class="p">:</span> <span class="n">audio_event_intervals</span><span class="p">[</span><span class="s1">&#39;error_tone&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">})</span>

        <span class="c1"># Sync the Bpod clock to the DAQ</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bpod2fpga</span><span class="p">,</span> <span class="n">drift_ppm</span><span class="p">,</span> <span class="n">ibpod</span><span class="p">,</span> <span class="n">ifpga</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_bpod_clock</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">,</span> <span class="n">fpga_events</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_field</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">ibpod</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_fields</span><span class="p">})</span>
        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod2fpga</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">ibpod</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_rsync_fields</span><span class="p">})</span>

        <span class="n">start_times</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;intervals&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">last_trial_end</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;intervals&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">assign_to_trial</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">,</span> <span class="n">starts</span><span class="o">=</span><span class="n">start_times</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Assign DAQ events to trials.</span>

<span class="sd">            Because we may not have trial start TTLs on the DAQ (because of the low sampling rate),</span>
<span class="sd">            there may be an extra last trial that&#39;s not in the Bpod intervals as the extractor</span>
<span class="sd">            ignores the last trial. This function trims the input array before assigning so that</span>
<span class="sd">            the last trial&#39;s events are correctly assigned.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">_assign_events_to_trial</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">events</span><span class="p">[</span><span class="n">events</span> <span class="o">&lt;=</span> <span class="n">last_trial_end</span><span class="p">],</span> <span class="n">take</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;itiIn_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign_to_trial</span><span class="p">(</span><span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;itiIn_times&#39;</span><span class="p">][</span><span class="n">ifpga</span><span class="p">])</span>

        <span class="c1"># Extract valve open times from the DAQ</span>
        <span class="n">valve_driver_ttls</span> <span class="o">=</span> <span class="n">bpod_event_intervals</span><span class="p">[</span><span class="s1">&#39;valve_open&#39;</span><span class="p">]</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="s1">&#39;feedbackType&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="c1"># If there is a reward_valve channel, the valve has</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;reward_valve&#39;</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeline</span><span class="p">[</span><span class="s1">&#39;meta&#39;</span><span class="p">][</span><span class="s1">&#39;inputs&#39;</span><span class="p">]):</span>
            <span class="c1"># TODO Let&#39;s look at the expected open length based on calibration and reward volume</span>
            <span class="c1"># import scipy.interpolate</span>
            <span class="c1"># # FIXME support v7 settings?</span>
            <span class="c1"># fcn_vol2time = scipy.interpolate.pchip(</span>
            <span class="c1">#     self.bpod_extractor.settings[&#39;device_valve&#39;][&#39;WATER_CALIBRATION_WEIGHT_PERDROP&#39;],</span>
            <span class="c1">#     self.bpod_extractor.settings[&#39;device_valve&#39;][&#39;WATER_CALIBRATION_OPEN_TIMES&#39;]</span>
            <span class="c1"># )</span>
            <span class="c1"># reward_time = fcn_vol2time(self.bpod_extractor.settings.get(&#39;REWARD_AMOUNT_UL&#39;)) / 1e3</span>

            <span class="c1"># Use the driver TTLs to find the valve open times that correspond to the valve opening</span>
            <span class="n">valve_intervals</span><span class="p">,</span> <span class="n">valve_open_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_valve_open_times</span><span class="p">(</span><span class="n">driver_ttls</span><span class="o">=</span><span class="n">valve_driver_ttls</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">valve_open_times</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">correct</span><span class="p">):</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s1">&#39;Number of valve open times does not equal number of correct trials (</span><span class="si">%i</span><span class="s1"> != </span><span class="si">%i</span><span class="s1">)&#39;</span><span class="p">,</span>
                    <span class="n">valve_open_times</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">correct</span><span class="p">))</span>

            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;valveOpen_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign_to_trial</span><span class="p">(</span><span class="n">valve_open_times</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use the valve controller TTLs recorded on the Bpod channel as the reward time</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;valveOpen_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign_to_trial</span><span class="p">(</span><span class="n">valve_driver_ttls</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Stimulus times extracted based on trigger times</span>
        <span class="c1"># When assigning events all start times must not be NaN so here we substitute freeze</span>
        <span class="c1"># trigger times on nogo trials for stim on trigger times, then replace with NaN again</span>
        <span class="n">go_trials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;choice&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOnTrigger_times&#39;</span><span class="p">])</span>
        <span class="n">lims</span><span class="p">[</span><span class="n">go_trials</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimFreezeTrigger_times&#39;</span><span class="p">][</span><span class="n">go_trials</span><span class="p">]</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimFreeze_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign_to_trial</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="s1">&#39;last&#39;</span><span class="p">,</span>
            <span class="n">starts</span><span class="o">=</span><span class="n">lims</span><span class="p">,</span> <span class="n">t_trial_end</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOffTrigger_times&#39;</span><span class="p">])</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimFreeze_times&#39;</span><span class="p">][</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;choice&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Here we do the same but use stim off trigger times</span>
        <span class="n">lims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOffTrigger_times&#39;</span><span class="p">])</span>
        <span class="n">lims</span><span class="p">[</span><span class="n">go_trials</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimFreezeTrigger_times&#39;</span><span class="p">][</span><span class="n">go_trials</span><span class="p">]</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOn_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign_to_trial</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="s1">&#39;first&#39;</span><span class="p">,</span>
            <span class="n">starts</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOnTrigger_times&#39;</span><span class="p">],</span> <span class="n">t_trial_end</span><span class="o">=</span><span class="n">lims</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOff_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign_to_trial</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frame2ttl</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">],</span> <span class="s1">&#39;first&#39;</span><span class="p">,</span>
            <span class="n">starts</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;stimOffTrigger_times&#39;</span><span class="p">],</span> <span class="n">t_trial_end</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;intervals&#39;</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Audio times</span>
        <span class="n">error_cue</span> <span class="o">=</span> <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;errorTone_times&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">error_cue</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">correct</span><span class="p">):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s1">&#39;N detected error tones does not match number of incorrect trials (</span><span class="si">%i</span><span class="s1"> != </span><span class="si">%i</span><span class="s1">)&#39;</span><span class="p">,</span>
                <span class="n">error_cue</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">correct</span><span class="p">))</span>
        <span class="n">go_cue</span> <span class="o">=</span> <span class="n">fpga_events</span><span class="p">[</span><span class="s1">&#39;goCue_times&#39;</span><span class="p">]</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;goCue_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign_to_trial</span><span class="p">(</span><span class="n">go_cue</span><span class="p">,</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;errorCue_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign_to_trial</span><span class="p">(</span><span class="n">error_cue</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">go_cue</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">start_times</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s1">&#39;More go cue tones detected than trials! (</span><span class="si">%i</span><span class="s1"> vs </span><span class="si">%i</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">go_cue</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">start_times</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">go_cue</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">start_times</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            If the error cues are all assigned and some go cues are missed it may be that some</span>
<span class="sd">            responses were so fast that the go cue and error tone merged, or the go cue TTL was too</span>
<span class="sd">            long.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> go cue tones missed&#39;</span><span class="p">,</span> <span class="n">start_times</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">go_cue</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">err_trig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod2fpga</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="s1">&#39;errorCueTrigger_times&#39;</span><span class="p">])</span>
            <span class="n">go_trig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod2fpga</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="s1">&#39;goCueTrigger_times&#39;</span><span class="p">])</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">go_trig</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">err_trig</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">go_trig</span><span class="o">.</span><span class="n">size</span>  <span class="c1"># should be length of n trials with NaNs</span>

            <span class="c1"># Find which trials are missing a go cue</span>
            <span class="n">_go_cue</span> <span class="o">=</span> <span class="n">assign_to_trial</span><span class="p">(</span><span class="n">go_cue</span><span class="p">,</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
            <span class="n">error_cue</span> <span class="o">=</span> <span class="n">assign_to_trial</span><span class="p">(</span><span class="n">error_cue</span><span class="p">)</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">_go_cue</span><span class="p">)</span>

            <span class="c1"># Get all the DAQ timestamps where audio channel was HIGH</span>
            <span class="n">raw</span> <span class="o">=</span> <span class="n">timeline_get_channel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeline</span><span class="p">,</span> <span class="s1">&#39;audio&#39;</span><span class="p">)</span>
            <span class="n">raw</span> <span class="o">=</span> <span class="p">(</span><span class="n">raw</span> <span class="o">-</span> <span class="n">raw</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">raw</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>  <span class="c1"># min-max normalize</span>
            <span class="n">ups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeline</span><span class="o">.</span><span class="n">timestamps</span><span class="p">[</span><span class="n">raw</span> <span class="o">&gt;</span> <span class="mf">.5</span><span class="p">]</span>  <span class="c1"># timestamps where input HIGH</span>

            <span class="c1"># Get the timestamps of the first HIGH after the trigger times (allow up to 200ms after).</span>
            <span class="c1"># Indices of ups directly following a go trigger, or -1 if none found (or trigger NaN)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">attribute_times</span><span class="p">(</span><span class="n">ups</span><span class="p">,</span> <span class="n">go_trig</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;after&#39;</span><span class="p">)</span>
            <span class="c1"># Trial indices that didn&#39;t have detected goCue and now has been assigned an `ups` index</span>
            <span class="n">assigned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;</span> <span class="n">missing</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># ignore unassigned</span>
            <span class="n">_go_cue</span><span class="p">[</span><span class="n">assigned</span><span class="p">]</span> <span class="o">=</span> <span class="n">ups</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">assigned</span><span class="p">]]</span>

            <span class="c1"># Remove mis-assigned error tone times (i.e. those that have now been assigned to goCue)</span>
            <span class="n">error_cue_without_trig</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">error_cue</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">err_trig</span><span class="p">))</span>
            <span class="n">i_to_remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">assigned</span><span class="p">,</span> <span class="n">error_cue_without_trig</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">error_cue</span><span class="p">[</span><span class="n">i_to_remove</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="c1"># For those trials where go cue was merged with the error cue and therefore mis-assigned,</span>
            <span class="c1"># we must re-assign the error cue times as the first HIGH after the error trigger.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">attribute_times</span><span class="p">(</span><span class="n">ups</span><span class="p">,</span> <span class="n">err_trig</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;after&#39;</span><span class="p">)</span>
            <span class="n">assigned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;</span> <span class="n">missing</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># ignore unassigned</span>
            <span class="n">error_cue</span><span class="p">[</span><span class="n">assigned</span><span class="p">]</span> <span class="o">=</span> <span class="n">ups</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">assigned</span><span class="p">]]</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;goCue_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_go_cue</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;errorCue_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">error_cue</span>

        <span class="c1"># Because we&#39;re not</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;goCue_times&#39;</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;errorCue_times&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> \
            <span class="s1">&#39;audio tones not assigned correctly; tones likely missed&#39;</span>

        <span class="c1"># Feedback times</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;feedback_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;valveOpen_times&#39;</span><span class="p">])</span>
        <span class="n">ind_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;valveOpen_times&#39;</span><span class="p">])</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;feedback_times&#39;</span><span class="p">][</span><span class="n">ind_err</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;errorCue_times&#39;</span><span class="p">][</span><span class="n">ind_err</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="TimelineTrials.extract_wheel_sync">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.mesoscope.html#ibllib.io.extractors.mesoscope.TimelineTrials.extract_wheel_sync">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_wheel_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">WHEEL_TICKS</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">WHEEL_RADIUS_CM</span><span class="p">,</span> <span class="n">coding</span><span class="o">=</span><span class="s1">&#39;x4&#39;</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the wheel position from Timeline counter channel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ticks : int</span>
<span class="sd">            Number of ticks corresponding to a full revolution (1024 for IBL rotary encoder).</span>
<span class="sd">        radius : float</span>
<span class="sd">            Radius of the wheel. Defaults to 1 for an output in radians.</span>
<span class="sd">        coding : str {&#39;x1&#39;, &#39;x2&#39;, &#39;x4&#39;}</span>
<span class="sd">            Rotary encoder encoding (IBL default is x4).</span>
<span class="sd">        tmin : float</span>
<span class="sd">            The minimum time from which to extract the sync pulses.</span>
<span class="sd">        tmax : float</span>
<span class="sd">            The maximum time up to which we extract the sync pulses.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array</span>
<span class="sd">            Wheel timestamps in seconds.</span>
<span class="sd">        np.array</span>
<span class="sd">            Wheel positions in radians.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ibllib.io.extractors.ephys_fpga.extract_wheel_sync</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coding</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="s1">&#39;x2&#39;</span><span class="p">,</span> <span class="s1">&#39;x4&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unsupported coding; must be one of x1, x2 or x4&#39;</span><span class="p">)</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="n">correct_counter_discontinuities</span><span class="p">(</span><span class="n">timeline_get_channel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeline</span><span class="p">,</span> <span class="s1">&#39;rotary_encoder&#39;</span><span class="p">))</span>

        <span class="c1"># Timeline evenly samples counter so we extract only change points</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
        <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">pos</span> <span class="o">-=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Start from zero</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">/</span> <span class="n">ticks</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="n">coding</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Convert to radians</span>

        <span class="c1"># Get timestamps of changes and trim based on protocol spacers</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeline</span><span class="p">[</span><span class="s1">&#39;timestamps&#39;</span><span class="p">][</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">tmin</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">if</span> <span class="n">tmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tmin</span>
        <span class="n">tmax</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">if</span> <span class="n">tmax</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tmax</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ts</span> <span class="o">&gt;=</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">tmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span></div>


<div class="viewcode-block" id="TimelineTrials.get_wheel_positions">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.mesoscope.html#ibllib.io.extractors.mesoscope.TimelineTrials.get_wheel_positions">[docs]</a>
    <span class="k">def</span> <span class="nf">get_wheel_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">WHEEL_TICKS</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">WHEEL_RADIUS_CM</span><span class="p">,</span> <span class="n">coding</span><span class="o">=</span><span class="s1">&#39;x4&#39;</span><span class="p">,</span>
                            <span class="n">tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the wheel position and detected movements from Timeline counter channel.</span>

<span class="sd">        Called by the super class extractor (FPGATrials._extract).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ticks : int</span>
<span class="sd">            Number of ticks corresponding to a full revolution (1024 for IBL rotary encoder).</span>
<span class="sd">        radius : float</span>
<span class="sd">            Radius of the wheel. Defaults to 1 for an output in radians.</span>
<span class="sd">        coding : str {&#39;x1&#39;, &#39;x2&#39;, &#39;x4&#39;}</span>
<span class="sd">            Rotary encoder encoding (IBL default is x4).</span>
<span class="sd">        tmin : float</span>
<span class="sd">            The minimum time from which to extract the sync pulses.</span>
<span class="sd">        tmax : float</span>
<span class="sd">            The maximum time up to which we extract the sync pulses.</span>
<span class="sd">        display : bool</span>
<span class="sd">            If true, plot the wheel positions from bpod and the DAQ.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            wheel object with keys (&#39;timestamps&#39;, &#39;position&#39;).</span>
<span class="sd">        dict</span>
<span class="sd">            wheelMoves object with keys (&#39;intervals&#39; &#39;peakAmplitude&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wheel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_wheel_sync</span><span class="p">(</span><span class="n">ticks</span><span class="o">=</span><span class="n">ticks</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">coding</span><span class="o">=</span><span class="n">coding</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">)</span>
        <span class="n">wheel</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">((</span><span class="s1">&#39;timestamps&#39;</span><span class="p">,</span> <span class="s1">&#39;position&#39;</span><span class="p">),</span> <span class="n">wheel</span><span class="p">))</span>
        <span class="n">moves</span> <span class="o">=</span> <span class="n">extract_wheel_moves</span><span class="p">(</span><span class="n">wheel</span><span class="p">[</span><span class="s1">&#39;timestamps&#39;</span><span class="p">],</span> <span class="n">wheel</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">display</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">,</span> <span class="s1">&#39;no bpod trials to compare&#39;</span>
            <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax0</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">bpod_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="s1">&#39;wheel_timestamps&#39;</span><span class="p">]</span>
            <span class="n">bpod_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpod_trials</span><span class="p">[</span><span class="s1">&#39;wheel_position&#39;</span><span class="p">]</span>
            <span class="n">ax0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpod2fpga</span><span class="p">(</span><span class="n">bpod_ts</span><span class="p">),</span> <span class="n">bpod_pos</span><span class="p">)</span>
            <span class="n">ax0</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Bpod wheel position / rad&#39;</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wheel</span><span class="p">[</span><span class="s1">&#39;timestamps&#39;</span><span class="p">],</span> <span class="n">wheel</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">])</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;DAQ wheel position / rad&#39;</span><span class="p">),</span> <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time / s&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wheel</span><span class="p">,</span> <span class="n">moves</span></div>


<div class="viewcode-block" id="TimelineTrials.get_valve_open_times">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.mesoscope.html#ibllib.io.extractors.mesoscope.TimelineTrials.get_valve_open_times">[docs]</a>
    <span class="k">def</span> <span class="nf">get_valve_open_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">driver_ttls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the valve open times from the raw timeline voltage trace.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        display : bool</span>
<span class="sd">            Plot detected times on the raw voltage trace.</span>
<span class="sd">        threshold : float</span>
<span class="sd">            The threshold of voltage change to apply. The default was set by eye; units should be</span>
<span class="sd">            Volts per sample but doesn&#39;t appear to be.</span>
<span class="sd">        driver_ttls : numpy.array</span>
<span class="sd">            An optional array of driver TTLs to use for assigning with the valve times.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            The detected valve open intervals.</span>
<span class="sd">        numpy.array</span>
<span class="sd">            If driver_ttls is not None, returns an array of open times that occurred directly after</span>
<span class="sd">            the driver TTLs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">WARN_THRESH</span> <span class="o">=</span> <span class="mf">10e-3</span>  <span class="c1"># open time threshold below which to log warning</span>
        <span class="n">tl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeline</span>
        <span class="n">info</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tl</span><span class="p">[</span><span class="s1">&#39;meta&#39;</span><span class="p">][</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;reward_valve&#39;</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">tl</span><span class="p">[</span><span class="s1">&#39;raw&#39;</span><span class="p">][:,</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;arrayColumn&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># Timeline indices start from 1</span>

        <span class="c1"># The voltage changes over ~1ms and can therefore occur over two DAQ samples at 2kHz</span>
        <span class="c1"># making simple thresholding an issue.  For this reason we convolve the signal with a</span>
        <span class="c1"># window and detect the peaks and troughs.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Fs</span> <span class="o">:=</span> <span class="n">tl</span><span class="p">[</span><span class="s1">&#39;meta&#39;</span><span class="p">][</span><span class="s1">&#39;daqSampleRate&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">2000</span><span class="p">:</span>  <span class="c1"># e.g. 2kHz</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Reward valve detection not tested with a DAQ sample rate of </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Fs</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mf">1e-3</span>  <span class="c1"># change in voltage takes ~1ms when changing valve open state</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">Fs</span><span class="p">)</span>  <span class="c1"># this means voltage change occurs over N samples</span>
        <span class="n">vel</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">velocity_filtered</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">Fs</span> <span class="o">/</span> <span class="n">N</span><span class="p">))</span>  <span class="c1"># filtered voltage change over time</span>
        <span class="n">ups</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">vel</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>  <span class="c1"># valve closes (-5V -&gt; 0V)</span>
        <span class="n">downs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">vel</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>  <span class="c1"># valve opens (0V -&gt; -5V)</span>

        <span class="c1"># Convert these times into intervals</span>
        <span class="n">ixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">downs</span><span class="p">,</span> <span class="n">ups</span><span class="p">])</span>  <span class="c1"># sort indices</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">tl</span><span class="p">[</span><span class="s1">&#39;timestamps&#39;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">downs</span><span class="p">,</span> <span class="n">ups</span><span class="p">]][</span><span class="n">ixs</span><span class="p">]</span>  <span class="c1"># ordered valve event times</span>
        <span class="n">polarities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">downs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ups</span><span class="p">)][</span><span class="n">ixs</span><span class="p">]</span>  <span class="c1"># polarity sorted</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">polarities</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># if some changes were missed insert NaN</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">missing</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">polarities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">polarities</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># ensure ends with a valve close</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">times</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">polarities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># ensure starts with a valve open</span>
            <span class="c1"># It seems it can start out at -5V (open), then when the reward happens it closes and</span>
            <span class="c1"># immediately opens. In this case we insert discard the first open time.</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">times</span><span class="p">]</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Log warning of improbably short intervals</span>
        <span class="n">short</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">WARN_THRESH</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">short</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> valve open intervals shorter than </span><span class="si">%i</span><span class="s1"> ms&#39;</span><span class="p">,</span> <span class="n">short</span><span class="p">,</span> <span class="n">WARN_THRESH</span><span class="p">)</span>

        <span class="c1"># The closing of the valve is noisy. Keep only the falls that occur immediately after a Bpod TTL</span>
        <span class="k">if</span> <span class="n">driver_ttls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Returns an array of open_times indices, one for each driver TTL</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">attribute_times</span><span class="p">(</span><span class="n">intervals</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">driver_ttls</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="mf">.1</span><span class="p">,</span> <span class="n">take</span><span class="o">=</span><span class="s1">&#39;after&#39;</span><span class="p">)</span>
            <span class="n">open_times</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">ind</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span>
            <span class="c1"># TODO Log any &gt; 40ms? Difficult to report missing valve times because of calibration</span>

        <span class="k">if</span> <span class="n">display</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax0</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tl</span><span class="p">[</span><span class="s1">&#39;timestamps&#39;</span><span class="p">],</span> <span class="n">timeline_get_channel</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="s1">&#39;bpod&#39;</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">driver_ttls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">driver_ttls</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">driver_ttls</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">driver_ttls</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span>
                <span class="n">squares</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax0</span><span class="p">,</span> <span class="n">yrange</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
                <span class="c1"># vertical_lines(driver_ttls, ymax=5, ax=ax0, linestyle=&#39;--&#39;, color=&#39;b&#39;)</span>
                <span class="n">ax0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">open_times</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">open_times</span><span class="p">)</span> <span class="o">*</span> <span class="mf">4.5</span><span class="p">,</span> <span class="s1">&#39;g*&#39;</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tl</span><span class="p">[</span><span class="s1">&#39;timestamps&#39;</span><span class="p">],</span> <span class="n">values</span><span class="p">,</span> <span class="s1">&#39;k-o&#39;</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Voltage / V&#39;</span><span class="p">),</span> <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time / s&#39;</span><span class="p">)</span>

            <span class="n">ax2</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;dV&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tl</span><span class="p">[</span><span class="s1">&#39;timestamps&#39;</span><span class="p">],</span> <span class="n">vel</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">intervals</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">))</span> <span class="o">*</span> <span class="n">threshold</span><span class="p">,</span> <span class="s1">&#39;r*&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;close&#39;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">intervals</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">))</span> <span class="o">*</span> <span class="n">threshold</span><span class="p">,</span> <span class="s1">&#39;g*&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;open&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">intervals</span> <span class="k">if</span> <span class="n">driver_ttls</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">open_times</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_assign_events_audio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">audio_times</span><span class="p">,</span> <span class="n">audio_polarities</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is identical to ephys_fpga._assign_events_audio, except for the ready tone threshold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        audio_times : numpy.array</span>
<span class="sd">            An array of audio TTL front times.</span>
<span class="sd">        audio_polarities : numpy.array</span>
<span class="sd">            An array of audio TTL front polarities (1 for rises, -1 for falls).</span>
<span class="sd">        display : bool</span>
<span class="sd">            If true, display audio pulses and the assigned onsets.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            The times of the go cue onsets.</span>
<span class="sd">        numpy.array</span>
<span class="sd">            The times of the error tone onsets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure that there are no 2 consecutive fall or consecutive rise events</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">audio_polarities</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># take only even time differences: i.e. from rising to falling fronts</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">audio_times</span><span class="p">)</span>
        <span class="n">onsets</span> <span class="o">=</span> <span class="n">audio_polarities</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="c1"># error tones are events lasting from 400ms to 1200ms</span>
        <span class="n">i_error_tone_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="mf">0.4</span> <span class="o">&lt;</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dt</span> <span class="o">&lt;</span> <span class="mf">1.2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">onsets</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_error_tone_in</span> <span class="o">=</span> <span class="n">audio_times</span><span class="p">[</span><span class="n">i_error_tone_in</span><span class="p">]</span>

        <span class="c1"># detect ready tone by length below 300 ms</span>
        <span class="n">i_ready_tone_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">dt</span> <span class="o">&lt;=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">onsets</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_ready_tone_in</span> <span class="o">=</span> <span class="n">audio_times</span><span class="p">[</span><span class="n">i_ready_tone_in</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">display</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeline</span><span class="o">.</span><span class="n">timestamps</span><span class="p">,</span> <span class="n">timeline_get_channel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeline</span><span class="p">,</span> <span class="s1">&#39;audio&#39;</span><span class="p">),</span> <span class="s1">&#39;k-o&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Voltage / V&#39;</span><span class="p">)</span>
            <span class="n">squares</span><span class="p">(</span><span class="n">audio_times</span><span class="p">,</span> <span class="n">audio_polarities</span><span class="p">,</span> <span class="n">yrange</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">vertical_lines</span><span class="p">(</span><span class="n">t_ready_tone_in</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=-</span><span class="mf">.8</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mf">.8</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;go cue&#39;</span><span class="p">)</span>
            <span class="n">vertical_lines</span><span class="p">(</span><span class="n">t_error_tone_in</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=-</span><span class="mf">.8</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mf">.8</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;error tone&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time / s&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">t_ready_tone_in</span><span class="p">,</span> <span class="n">t_error_tone_in</span></div>



<div class="viewcode-block" id="MesoscopeSyncTimeline">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.mesoscope.html#ibllib.io.extractors.mesoscope.MesoscopeSyncTimeline">[docs]</a>
<span class="k">class</span> <span class="nc">MesoscopeSyncTimeline</span><span class="p">(</span><span class="n">extractors_base</span><span class="o">.</span><span class="n">BaseExtractor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extraction of mesoscope imaging times.&quot;&quot;&quot;</span>

    <span class="n">var_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;mpci_times&#39;</span><span class="p">,</span> <span class="s1">&#39;mpciStack_timeshift&#39;</span><span class="p">)</span>
    <span class="n">save_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;mpci.times.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;mpciStack.timeshift.npy&#39;</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;one.alf.io.AlfBunch: The raw imaging meta data and frame times&quot;&quot;&quot;</span>
    <span class="n">rawImagingData</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session_path</span><span class="p">,</span> <span class="n">n_FOVs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the mesoscope frame times from DAQ data acquired through Timeline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        session_path : str, pathlib.Path</span>
<span class="sd">            The session path to extract times from.</span>
<span class="sd">        n_FOVs : int</span>
<span class="sd">            The number of fields of view acquired.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">session_path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_FOVs</span> <span class="o">=</span> <span class="n">n_FOVs</span>
        <span class="n">fov</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;FOV_</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s1">02</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_FOVs</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_names</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">fov</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_names</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">fov</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device_collection</span><span class="o">=</span><span class="s1">&#39;raw_imaging_data&#39;</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the frame timestamps for each individual field of view (FOV) and the time offsets</span>
<span class="sd">        for each line scan.</span>

<span class="sd">        The detected frame times from the &#39;neural_frames&#39; channel of the DAQ are split into bouts</span>
<span class="sd">        corresponding to the number of raw_imaging_data folders. These timestamps should match the</span>
<span class="sd">        number of frame timestamps extracted from the image file headers (found in the</span>
<span class="sd">        rawImagingData.times file).  The field of view (FOV) shifts are then applied to these</span>
<span class="sd">        timestamps for each field of view and provided together with the line shifts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sync : one.alf.io.AlfBunch</span>
<span class="sd">            A dictionary with keys (&#39;times&#39;, &#39;polarities&#39;, &#39;channels&#39;), containing the sync pulses</span>
<span class="sd">            and the corresponding channel numbers.</span>
<span class="sd">        chmap : dict</span>
<span class="sd">            A map of channel names and their corresponding indices. Only the &#39;neural_frames&#39;</span>
<span class="sd">            channel is required.</span>
<span class="sd">        device_collection : str, iterable of str</span>
<span class="sd">            The location of the raw imaging data.</span>
<span class="sd">        events : pandas.DataFrame</span>
<span class="sd">            A table of software events, with columns {&#39;time_timeline&#39; &#39;name_timeline&#39;,</span>
<span class="sd">            &#39;event_timeline&#39;}.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of numpy.array</span>
<span class="sd">            A list of timestamps for each FOV and the time offsets for each line scan.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frame_times</span> <span class="o">=</span> <span class="n">sync</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">][</span><span class="n">sync</span><span class="p">[</span><span class="s1">&#39;channels&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chmap</span><span class="p">[</span><span class="s1">&#39;neural_frames&#39;</span><span class="p">]]</span>

        <span class="c1"># imaging_start_time = datetime.datetime(*map(round, self.rawImagingData.meta[&#39;acquisitionStartTime&#39;]))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device_collection</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">device_collection</span> <span class="o">=</span> <span class="p">[</span><span class="n">device_collection</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">events</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;mpepUDP&#39;</span><span class="p">]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bout_edges</span><span class="p">(</span><span class="n">frame_times</span><span class="p">,</span> <span class="n">device_collection</span><span class="p">,</span> <span class="n">events</span><span class="p">)</span>
        <span class="n">fov_times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">line_shifts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">),</span> <span class="n">collection</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">device_collection</span><span class="p">)):</span>
            <span class="n">imaging_data</span> <span class="o">=</span> <span class="n">alfio</span><span class="o">.</span><span class="n">load_object</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session_path</span> <span class="o">/</span> <span class="n">collection</span><span class="p">,</span> <span class="s1">&#39;rawImagingData&#39;</span><span class="p">)</span>
            <span class="n">imaging_data</span><span class="p">[</span><span class="s1">&#39;meta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">patch_imaging_meta</span><span class="p">(</span><span class="n">imaging_data</span><span class="p">[</span><span class="s1">&#39;meta&#39;</span><span class="p">])</span>
            <span class="c1"># Calculate line shifts</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">fov_time_shifts</span><span class="p">,</span> <span class="n">line_time_shifts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_timeshifts</span><span class="p">(</span><span class="n">imaging_data</span><span class="p">[</span><span class="s1">&#39;meta&#39;</span><span class="p">])</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fov_time_shifts</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_FOVs</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;unexpected number of FOVs for </span><span class="si">{</span><span class="n">collection</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">frame_times</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">frame_times</span> <span class="o">&gt;=</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">frame_times</span> <span class="o">&lt;=</span> <span class="n">tmax</span><span class="p">)]</span>
            <span class="k">assert</span> <span class="n">ts</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">imaging_data</span><span class="p">[</span><span class="s1">&#39;times_scanImage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;fewer DAQ timestamps for </span><span class="si">{</span><span class="n">collection</span><span class="si">}</span><span class="s1"> than expected&#39;</span>
            <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">imaging_data</span><span class="p">[</span><span class="s1">&#39;times_scanImage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s1">&#39;More DAQ frame times detected for </span><span class="si">%s</span><span class="s1"> than were found in the raw image data.</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;N DAQ frame times:</span><span class="se">\t</span><span class="si">%i</span><span class="se">\n</span><span class="s1">N raw image data times:</span><span class="se">\t</span><span class="si">%i</span><span class="s1">.</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;This may occur if the bout detection fails (e.g. UDPs recorded late), &#39;</span>
                    <span class="s1">&#39;when image data is corrupt, or when frames are not written to file.&#39;</span><span class="p">,</span>
                    <span class="n">collection</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">imaging_data</span><span class="p">[</span><span class="s1">&#39;times_scanImage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Dropping last </span><span class="si">%i</span><span class="s1"> frame times for </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">imaging_data</span><span class="p">[</span><span class="s1">&#39;times_scanImage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">collection</span><span class="p">)</span>
                <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[:</span><span class="n">imaging_data</span><span class="p">[</span><span class="s1">&#39;times_scanImage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
            <span class="n">fov_times</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ts</span> <span class="o">+</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">fov_time_shifts</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">line_shifts</span><span class="p">:</span>
                <span class="n">line_shifts</span> <span class="o">=</span> <span class="n">line_time_shifts</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># The line shifts should be the same across all imaging bouts</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">line_time_shifts</span><span class="p">,</span> <span class="n">line_shifts</span><span class="p">)]</span>

        <span class="c1"># Concatenate imaging timestamps across all bouts for each field of view</span>
        <span class="n">fov_times</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">fov_times</span><span class="p">)))</span>
        <span class="n">n_fov_times</span><span class="p">,</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">fov_times</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">n_fov_times</span> <span class="o">!=</span> <span class="n">frame_times</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="c1"># This may happen if an experimenter deletes a raw_imaging_data folder</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;FOV timestamps length does not match neural frame count; imaging bout(s) likely missing&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fov_times</span> <span class="o">+</span> <span class="n">line_shifts</span>

<div class="viewcode-block" id="MesoscopeSyncTimeline.get_bout_edges">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.mesoscope.html#ibllib.io.extractors.mesoscope.MesoscopeSyncTimeline.get_bout_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">get_bout_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame_times</span><span class="p">,</span> <span class="n">collections</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_gap</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array of edge times for each imaging bout corresponding to a raw_imaging_data</span>
<span class="sd">        collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frame_times : numpy.array</span>
<span class="sd">            An array of all neural frame count times.</span>
<span class="sd">        collections : iterable of str</span>
<span class="sd">            A set of raw_imaging_data collections, used to extract selected imaging periods.</span>
<span class="sd">        events : pandas.DataFrame</span>
<span class="sd">            A table of UDP event times, corresponding to times when recordings start and end.</span>
<span class="sd">        min_gap : float</span>
<span class="sd">            If start or end events not present, split bouts by finding gaps larger than this value.</span>
<span class="sd">        display : bool</span>
<span class="sd">            If true, plot the detected bout edges and raw frame times.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            An array of imaging bout intervals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">events</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="c1"># No UDP events to mark blocks so separate based on gaps in frame rate</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">frame_times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_gap</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">frame_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">frame_times</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">frame_times</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">frame_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Split using Exp/BlockStart and Exp/BlockEnd times</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">session_path_parts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session_path</span><span class="p">)</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="sa">rf</span><span class="s1">&#39;(Exp|Block)%s\s</span><span class="si">{</span><span class="n">subject</span><span class="si">}</span><span class="s1">\s</span><span class="si">{</span><span class="n">date</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1">\s\d+&#39;</span>

            <span class="c1"># Get start times</span>
            <span class="n">UDP_start</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span> <span class="o">%</span> <span class="s1">&#39;Start&#39;</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">UDP_start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">UDP_start</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;info&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Exp&#39;</span><span class="p">):</span>
                <span class="c1"># Use ExpStart instead of first bout start</span>
                <span class="n">UDP_start</span> <span class="o">=</span> <span class="n">UDP_start</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Use ExpStart/End instead of first/last BlockStart/End</span>
            <span class="n">starts</span> <span class="o">=</span> <span class="n">frame_times</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">frame_times</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">UDP_start</span><span class="o">.</span><span class="n">time</span><span class="p">]]</span>

            <span class="c1"># Get end times</span>
            <span class="n">UDP_end</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span> <span class="o">%</span> <span class="s1">&#39;End&#39;</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">UDP_end</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">UDP_end</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Exp&#39;</span><span class="p">):</span>
                <span class="c1"># Use last BlockEnd instead of ExpEnd</span>
                <span class="n">UDP_end</span> <span class="o">=</span> <span class="n">UDP_end</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">UDP_end</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">UDP_end</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">ends</span> <span class="o">=</span> <span class="n">frame_times</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">frame_times</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">UDP_end</span><span class="o">.</span><span class="n">time</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Get index of last frame to occur within a second of the previous frame</span>
                <span class="n">consec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">frame_times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_gap</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">frame_times</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">,</span> <span class="n">consec</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">starts</span><span class="p">]</span>
                <span class="n">ends</span> <span class="o">=</span> <span class="n">frame_times</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># Remove any missing imaging bout collections</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">collections</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">collections</span><span class="p">):</span>
                <span class="c1"># Remove any bouts that correspond to a skipped collection</span>
                <span class="c1"># e.g. if {raw_imaging_data_00, raw_imaging_data_02}, remove middle bout</span>
                <span class="n">include</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">collections</span><span class="p">)</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">include</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">elif</span> <span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">collections</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;More raw imaging folders than detected bouts&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">display</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">frame_times</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">frame_times</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;frame times&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="p">)</span>
            <span class="n">vertical_lines</span><span class="p">(</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">frame_times</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;bout start&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
            <span class="n">vertical_lines</span><span class="p">(</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">frame_times</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;bout end&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">starts</span><span class="p">):</span>
                <span class="n">vertical_lines</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">frame_times</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                               <span class="n">label</span><span class="o">=</span><span class="s1">&#39;missing bout start&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
                <span class="n">vertical_lines</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">ends</span><span class="p">,</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">frame_times</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                               <span class="n">label</span><span class="o">=</span><span class="s1">&#39;missing bout end&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time / s&#39;</span><span class="p">),</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frame #&#39;</span><span class="p">),</span> <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">edges</span></div>


<div class="viewcode-block" id="MesoscopeSyncTimeline.get_timeshifts">
<a class="viewcode-back" href="../../../../_autosummary/ibllib.io.extractors.mesoscope.html#ibllib.io.extractors.mesoscope.MesoscopeSyncTimeline.get_timeshifts">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_timeshifts</span><span class="p">(</span><span class="n">raw_imaging_meta</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the time shifts for each field of view (FOV) and the relative offsets for each</span>
<span class="sd">        scan line.</span>

<span class="sd">        For a 2 scan field, 2 depth recording (so 4 FOVs):</span>

<span class="sd">        Frame 1, lines 1-512 correspond to FOV_00</span>
<span class="sd">        Frame 1, lines 551-1062 correspond to FOV_01</span>
<span class="sd">        Frame 2, lines 1-512 correspond to FOV_02</span>
<span class="sd">        Frame 2, lines 551-1062 correspond to FOV_03</span>
<span class="sd">        Frame 3, lines 1-512 correspond to FOV_00</span>
<span class="sd">        ...</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        raw_imaging_meta : dict</span>
<span class="sd">            Extracted ScanImage meta data (_ibl_rawImagingData.meta.json).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of numpy.array</span>
<span class="sd">            A list of arrays, one per FOV, containing indices of each image scan line.</span>
<span class="sd">        numpy.array</span>
<span class="sd">            An array of FOV time offsets (one value per FOV) relative to each frame acquisition</span>
<span class="sd">            time.</span>
<span class="sd">        list of numpy.array</span>
<span class="sd">            A list of arrays, one per FOV, containing the time offsets for each scan line, relative</span>
<span class="sd">            to each FOV offset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">FOVs</span> <span class="o">=</span> <span class="n">raw_imaging_meta</span><span class="p">[</span><span class="s1">&#39;FOV&#39;</span><span class="p">]</span>

        <span class="c1"># Double-check meta extracted properly</span>
        <span class="c1"># assert meta.FOV.Zs is ascending but use slice_id field. This may not be necessary but is expected.</span>
        <span class="n">slice_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fov</span><span class="p">[</span><span class="s1">&#39;slice_id&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">fov</span> <span class="ow">in</span> <span class="n">FOVs</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;Zs&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">FOVs</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;FOV depths not in ascending order&#39;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">slice_ids</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;slice IDs not ordered&#39;</span>
        <span class="c1"># Number of scan lines per FOV, i.e. number of Y pixels / image height</span>
        <span class="n">n_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;nXnYnZ&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">FOVs</span><span class="p">])</span>

        <span class="c1"># We get indices from MATLAB extracted metadata so below two lines are no longer needed</span>
        <span class="c1"># n_valid_lines = np.sum(n_lines)  # Number of lines imaged excluding flybacks</span>
        <span class="c1"># n_lines_per_gap = int((raw_meta[&#39;Height&#39;] - n_valid_lines) / (len(FOVs) - 1))  # N lines during flyback</span>
        <span class="n">line_period</span> <span class="o">=</span> <span class="n">raw_imaging_meta</span><span class="p">[</span><span class="s1">&#39;scanImageParams&#39;</span><span class="p">][</span><span class="s1">&#39;hRoiManager&#39;</span><span class="p">][</span><span class="s1">&#39;linePeriod&#39;</span><span class="p">]</span>
        <span class="n">frame_time_shifts</span> <span class="o">=</span> <span class="n">slice_ids</span> <span class="o">/</span> <span class="n">raw_imaging_meta</span><span class="p">[</span><span class="s1">&#39;scanImageParams&#39;</span><span class="p">][</span><span class="s1">&#39;hRoiManager&#39;</span><span class="p">][</span><span class="s1">&#39;scanFrameRate&#39;</span><span class="p">]</span>

        <span class="c1"># Line indices are now extracted by the MATLAB function mesoscopeMetadataExtraction.m</span>
        <span class="c1"># They are indexed from 1 so we subtract 1 to convert to zero-indexed</span>
        <span class="n">line_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fov</span><span class="p">[</span><span class="s1">&#39;lineIdx&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">fov</span> <span class="ow">in</span> <span class="n">FOVs</span><span class="p">]</span>  <span class="c1"># Convert to zero-indexed from MATLAB 1-indexed</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">lns</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">n</span> <span class="k">for</span> <span class="n">lns</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">line_indices</span><span class="p">,</span> <span class="n">n_lines</span><span class="p">)),</span> <span class="s1">&#39;unexpected number of scan lines&#39;</span>
        <span class="c1"># The start indices of each FOV in the raw images</span>
        <span class="n">fov_start_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">lns</span> <span class="ow">in</span> <span class="n">line_indices</span><span class="p">])</span>
        <span class="n">roi_time_shifts</span> <span class="o">=</span> <span class="n">fov_start_idx</span> <span class="o">*</span> <span class="n">line_period</span>   <span class="c1"># The time offset for each FOV</span>
        <span class="n">fov_time_shifts</span> <span class="o">=</span> <span class="n">roi_time_shifts</span> <span class="o">+</span> <span class="n">frame_time_shifts</span>
        <span class="n">line_time_shifts</span> <span class="o">=</span> <span class="p">[(</span><span class="n">lns</span> <span class="o">-</span> <span class="n">ln0</span><span class="p">)</span> <span class="o">*</span> <span class="n">line_period</span> <span class="k">for</span> <span class="n">lns</span><span class="p">,</span> <span class="n">ln0</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">line_indices</span><span class="p">,</span> <span class="n">fov_start_idx</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">line_indices</span><span class="p">,</span> <span class="n">fov_time_shifts</span><span class="p">,</span> <span class="n">line_time_shifts</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, International Brain Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>