<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ibllib.atlas.atlas &mdash; IBL Library  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/style.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> IBL Library
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">The Open Neurophysiology Environment</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks_external/one_quickstart.html">ONE Quick Start</a></li>
<li class="toctree-l1"><a class="reference external" href="https://int-brain-lab.github.io/ONE/">Full documentation Website for ONE</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">DataJoint</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dj_docs/dj_introduction.html">Introduction to DataJoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dj_docs/dj_public.html">Publicly available IBL data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dj_docs/dj_credentials.html">DataJoint credentials for internal IBL users</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Public</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../public_docs/public_introduction.html">Publicly available IBL data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exploring IBL Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../loading_examples.html">Loading Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Miscellaneous</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../02_installation.html">Unified Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../09_contribution.html">How to contribute</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples &amp; Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../06_examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/dj_intro/dj_intro.html">Datajoint Introductory Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/dj_basics/dj_basics.html">Exploring the IBL Data Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks_external/docs_wheel_moves.html">Working with wheel data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../010_api_reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Detailed Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">IBL Library</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>ibllib.atlas.atlas</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ibllib.atlas.atlas</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span><span class="p">,</span> <span class="n">PurePosixPath</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">nrrd</span>

<span class="kn">from</span> <span class="nn">iblutil.numerical</span> <span class="kn">import</span> <span class="n">ismember</span>
<span class="kn">from</span> <span class="nn">ibllib.atlas.regions</span> <span class="kn">import</span> <span class="n">BrainRegions</span>
<span class="kn">from</span> <span class="nn">one.webclient</span> <span class="kn">import</span> <span class="n">http_download_file</span>
<span class="kn">import</span> <span class="nn">one.params</span>

<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;ibllib&#39;</span><span class="p">)</span>
<span class="n">ALLEN_CCF_LANDMARKS_MLAPDV_UM</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bregma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5739</span><span class="p">,</span> <span class="mi">5400</span><span class="p">,</span> <span class="mi">332</span><span class="p">])}</span>


<div class="viewcode-block" id="cart2sph"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.cart2sph">[docs]</a><span class="k">def</span> <span class="nf">cart2sph</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts cartesian to spherical Coordinates</span>
<span class="sd">    theta: polar angle, phi: azimuth</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">z</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">iok</span> <span class="o">=</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">theta</span><span class="p">[</span><span class="n">iok</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">iok</span><span class="p">]</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="n">iok</span><span class="p">])</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span></div>


<div class="viewcode-block" id="sph2cart"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.sph2cart">[docs]</a><span class="k">def</span> <span class="nf">sph2cart</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts Spherical to Cartesian coordinates</span>
<span class="sd">    theta: polar angle, phi: azimuth</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span></div>


<div class="viewcode-block" id="BrainCoordinates"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates">[docs]</a><span class="k">class</span> <span class="nc">BrainCoordinates</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for mapping and indexing a 3D array to real-world coordinates</span>
<span class="sd">    x = ml, right positive</span>
<span class="sd">    y = ap, anterior positive</span>
<span class="sd">    z = dv, dorsal positive</span>

<span class="sd">    The layout of the Atlas dimension is done according to the most used sections so they lay</span>
<span class="sd">    contiguous on disk assuming C-ordering: V[iap, iml, idv]</span>

<span class="sd">    nxyz: number of elements along each cartesian axis (nx, ny, nz) = (nml, nap, ndv)</span>
<span class="sd">    xyz0: coordinates of the element volume[0, 0, 0]] in the coordinate space</span>
<span class="sd">    dxyz: spatial interval of the volume along the 3 dimensions</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nxyz</span><span class="p">,</span> <span class="n">xyz0</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dxyz</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dxyz</span><span class="p">):</span>
            <span class="n">dxyz</span> <span class="o">=</span> <span class="p">[</span><span class="n">dxyz</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xyz0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dxyz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nxyz</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dxyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nxyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">])</span>

    <span class="sd">&quot;&quot;&quot;Methods ratios to indice&quot;&quot;&quot;</span>
<div class="viewcode-block" id="BrainCoordinates.r2ix"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.r2ix">[docs]</a>    <span class="k">def</span> <span class="nf">r2ix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainCoordinates.r2iy"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.r2iy">[docs]</a>    <span class="k">def</span> <span class="nf">r2iy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainCoordinates.r2iz"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.r2iz">[docs]</a>    <span class="k">def</span> <span class="nf">r2iz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span></div>

    <span class="sd">&quot;&quot;&quot;Methods distance to indice&quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_round</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">nanval</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">round</span><span class="p">:</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">ii</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">nanval</span>
            <span class="k">return</span> <span class="n">ii</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span>

<div class="viewcode-block" id="BrainCoordinates.x2i"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.x2i">[docs]</a>    <span class="k">def</span> <span class="nf">x2i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainCoordinates.y2i"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.y2i">[docs]</a>    <span class="k">def</span> <span class="nf">y2i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round</span><span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainCoordinates.z2i"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.z2i">[docs]</a>    <span class="k">def</span> <span class="nf">z2i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round</span><span class="p">((</span><span class="n">z</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">z0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainCoordinates.xyz2i"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.xyz2i">[docs]</a>    <span class="k">def</span> <span class="nf">xyz2i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="nb">int</span> <span class="k">if</span> <span class="nb">round</span> <span class="k">else</span> <span class="nb">float</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

    <span class="sd">&quot;&quot;&quot;Methods indices to distance&quot;&quot;&quot;</span>
<div class="viewcode-block" id="BrainCoordinates.i2x"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.i2x">[docs]</a>    <span class="k">def</span> <span class="nf">i2x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ind</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span></div>

<div class="viewcode-block" id="BrainCoordinates.i2y"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.i2y">[docs]</a>    <span class="k">def</span> <span class="nf">i2y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ind</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span></div>

<div class="viewcode-block" id="BrainCoordinates.i2z"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.i2z">[docs]</a>    <span class="k">def</span> <span class="nf">i2z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ind</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">z0</span></div>

<div class="viewcode-block" id="BrainCoordinates.i2xyz"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.i2xyz">[docs]</a>    <span class="k">def</span> <span class="nf">i2xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iii</span><span class="p">):</span>
        <span class="n">iii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">iii</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">iii</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2x</span><span class="p">(</span><span class="n">iii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2y</span><span class="p">(</span><span class="n">iii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">iii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">out</span></div>

    <span class="sd">&quot;&quot;&quot;Methods bounds&quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xlim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2x</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ylim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2y</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">zlim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>

<div class="viewcode-block" id="BrainCoordinates.lim"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.lim">[docs]</a>    <span class="k">def</span> <span class="nf">lim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xlim</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ylim</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span></div>

    <span class="sd">&quot;&quot;&quot;returns scales&quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2x</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">yscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2y</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">zscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>

    <span class="sd">&quot;&quot;&quot;returns the 3d mgrid used for 3d visualization&quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xscale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yscale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zscale</span><span class="p">)</span></div>


<div class="viewcode-block" id="BrainAtlas"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas">[docs]</a><span class="k">class</span> <span class="nc">BrainAtlas</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Objects that holds image, labels and coordinate transforms for a brain Atlas.</span>
<span class="sd">    Currently this is designed for the AllenCCF at several resolutions,</span>
<span class="sd">    yet this class can be used for other atlases arises.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">dxyz</span><span class="p">,</span> <span class="n">regions</span><span class="p">,</span> <span class="n">iorigin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                 <span class="n">dims2xyz</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">xyz2dims</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        self.image: image volume (ap, ml, dv)</span>
<span class="sd">        self.label: label volume (ap, ml, dv)</span>
<span class="sd">        self.bc: atlas.BrainCoordinate object</span>
<span class="sd">        self.regions: atlas.BrainRegions object</span>
<span class="sd">        self.top: 2d np array (ap, ml) containing the z-coordinate (m) of the surface of the brain</span>
<span class="sd">        self.dims2xyz and self.zyz2dims: map image axis order to xyz coordinates order</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regions</span> <span class="o">=</span> <span class="n">regions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dims2xyz</span> <span class="o">=</span> <span class="n">dims2xyz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span> <span class="o">=</span> <span class="n">xyz2dims</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims2xyz</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dims2xyz</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
        <span class="c1"># create the coordinate transform object that maps volume indices to real world coordinates</span>
        <span class="n">nxyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">dims2xyz</span><span class="p">]</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">BrainCoordinates</span><span class="p">(</span><span class="n">nxyz</span><span class="o">=</span><span class="n">nxyz</span><span class="p">,</span> <span class="n">xyz0</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dxyz</span><span class="o">=</span><span class="n">dxyz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">=</span> <span class="n">BrainCoordinates</span><span class="p">(</span><span class="n">nxyz</span><span class="o">=</span><span class="n">nxyz</span><span class="p">,</span> <span class="n">xyz0</span><span class="o">=-</span> <span class="n">bc</span><span class="o">.</span><span class="n">i2xyz</span><span class="p">(</span><span class="n">iorigin</span><span class="p">),</span> <span class="n">dxyz</span><span class="o">=</span><span class="n">dxyz</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="BrainAtlas.compute_surface"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.compute_surface">[docs]</a>    <span class="k">def</span> <span class="nf">compute_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the volume top, bottom, left and right surfaces, and from these the outer surface of</span>
<span class="sd">        the image volume. This is needed to compute probe insertions intersections</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># only compute if it hasn&#39;t already been computed</span>
            <span class="n">axz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># this is the dv axis</span>
            <span class="n">_surface</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="n">l0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_surface</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axz</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">l0</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axz</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">_top</span><span class="p">[</span><span class="n">_top</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">_bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nz</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axz</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axz</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">_bottom</span><span class="p">[</span><span class="n">_bottom</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nz</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">_top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">_bottom</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_surface</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">l0</span>
            <span class="n">idx_srf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="p">[</span><span class="n">idx_srf</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">srf_xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">i2xyz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">idx_srf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">idx_srf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                               <span class="n">idx_srf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span></div>

<div class="viewcode-block" id="BrainAtlas.compute_boundaries"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.compute_boundaries">[docs]</a>    <span class="k">def</span> <span class="nf">compute_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the boundaries between regions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># only compute if it hasn&#39;t already been computed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Compute boundary on top view</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_surface</span><span class="p">()</span>
            <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span>
            <span class="n">iz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">z2i</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_inds</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">acronym</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">_top_boundary</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">inds</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">top_boundary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_top_boundary</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">top_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_boundary</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_top_boundary</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">top_boundary</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">top_boundary</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span></div>

    <span class="k">def</span> <span class="nf">_lookup_inds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ixyz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a 3D lookup from volume indices ixyz to the image volume</span>
<span class="sd">        :param ixyz: [n, 3] array of indices in the mlapdv order</span>
<span class="sd">        :return: n array of flat indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ixyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">idims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nxyz</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">inds</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a 3D lookup from real world coordinates to the flat indices in the volume</span>
<span class="sd">        defined in the BrainCoordinates object</span>
<span class="sd">        :param xyz: [n, 3] array of coordinates</span>
<span class="sd">        :return: n array of flat indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_inds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">))</span>

<div class="viewcode-block" id="BrainAtlas.get_labels"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.get_labels">[docs]</a>    <span class="k">def</span> <span class="nf">get_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="s1">&#39;Allen&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a 3D lookup from real world coordinates to the volume labels</span>
<span class="sd">        and return the regions ids according to the mapping</span>
<span class="sd">        :param xyz: [n, 3] array of coordinates</span>
<span class="sd">        :param mapping: brain region mapping (defaults to original Allen mapping)</span>
<span class="sd">        :return: n array of region ids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">regions_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mapping</span><span class="p">(</span><span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_lookup</span><span class="p">(</span><span class="n">xyz</span><span class="p">)]]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="n">regions_indices</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="s1">&#39;Allen&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Safe way to get mappings if nothing defined in regions.</span>
<span class="sd">        A mapping transforms from the full allen brain Atlas ids to the remapped ids</span>
<span class="sd">        new_ids = ids[mapping]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="p">,</span> <span class="s1">&#39;mappings&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">mappings</span><span class="p">[</span><span class="n">mapping</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_label2rgb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imlabel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a slice from the label volume to its RGB equivalent for display</span>
<span class="sd">        :param imlabel: 2D np-array containing label ids (slice of the label volume)</span>
<span class="sd">        :return: 3D np-array of the slice uint8 rgb values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="p">,</span> <span class="s1">&#39;rgb&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="n">imlabel</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if the regions exist and have the rgb attribute, do the rgb lookup</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">rgb</span><span class="p">[</span><span class="n">imlabel</span><span class="p">]</span>

<div class="viewcode-block" id="BrainAtlas.tilted_slice"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.tilted_slice">[docs]</a>    <span class="k">def</span> <span class="nf">tilted_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        From line coordinates, extracts the tilted plane containing the line from the 3D volume</span>
<span class="sd">        :param xyz: np.array: points defining a probe trajectory in 3D space (xyz triplets)</span>
<span class="sd">        if more than 2 points are provided will take the best fit</span>
<span class="sd">        :param axis:</span>
<span class="sd">            0: along ml = sagittal-slice</span>
<span class="sd">            1: along ap = coronal-slice</span>
<span class="sd">            2: along dv = horizontal-slice</span>
<span class="sd">        :param volume: &#39;image&#39; or &#39;annotation&#39;</span>
<span class="sd">        :return: np.array, abscissa extent (width), ordinate extent (height),</span>
<span class="sd">        squeezed axis extent (depth)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>   <span class="c1"># sagittal slice (squeeze/take along ml-axis)</span>
            <span class="n">wdim</span><span class="p">,</span> <span class="n">hdim</span><span class="p">,</span> <span class="n">ddim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># coronal slice (squeeze/take along ap-axis)</span>
            <span class="n">wdim</span><span class="p">,</span> <span class="n">hdim</span><span class="p">,</span> <span class="n">ddim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># horizontal slice (squeeze/take along dv-axis)</span>
            <span class="n">wdim</span><span class="p">,</span> <span class="n">hdim</span><span class="p">,</span> <span class="n">ddim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># get the best fit and find exit points of the volume along squeezed axis</span>
        <span class="n">trj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">sub_volume</span> <span class="o">=</span> <span class="n">trj</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">hdim</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">hdim</span><span class="p">)</span>
        <span class="n">sub_volume</span><span class="p">[:,</span> <span class="n">wdim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">wdim</span><span class="p">)</span>
        <span class="n">sub_volume_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">sub_volume</span><span class="p">)</span>
        <span class="n">tile_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sub_volume_i</span><span class="p">[:,</span> <span class="n">hdim</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nxyz</span><span class="p">[</span><span class="n">wdim</span><span class="p">]])</span>
        <span class="c1"># get indices along each dimension</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tile_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">indy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tile_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">sub_volume_i</span><span class="p">[:,</span> <span class="n">ddim</span><span class="p">],</span> <span class="n">tile_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># compute the slice indices and output the slice</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">INDS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">inds</span><span class="p">)))</span>
        <span class="n">INDX</span><span class="p">,</span> <span class="n">INDY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">indy</span><span class="p">)</span>
        <span class="n">indsl</span> <span class="o">=</span> <span class="p">[[</span><span class="n">INDX</span><span class="p">,</span> <span class="n">INDY</span><span class="p">,</span> <span class="n">INDS</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="n">wdim</span><span class="p">,</span> <span class="n">hdim</span><span class="p">,</span> <span class="n">ddim</span><span class="p">])[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">tslice</span> <span class="o">=</span> <span class="n">volume</span><span class="p">[</span><span class="n">indsl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">volume</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;annotation&#39;</span><span class="p">:</span>
            <span class="n">tslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label2rgb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="n">indsl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="n">volume</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="n">tslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">indsl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">volume</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;surface&#39;</span><span class="p">:</span>
            <span class="n">tslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="p">[</span><span class="n">indsl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

        <span class="c1">#  get extents with correct convention NB: matplotlib flips the y-axis on imshow !</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sub_volume</span><span class="p">[:,</span> <span class="n">wdim</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">wdim</span><span class="p">))]</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sub_volume</span><span class="p">[:,</span> <span class="n">hdim</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">hdim</span><span class="p">))])</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sub_volume</span><span class="p">[:,</span> <span class="n">ddim</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">ddim</span><span class="p">))])</span>
        <span class="k">return</span> <span class="n">tslice</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span></div>

<div class="viewcode-block" id="BrainAtlas.plot_tilted_slice"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.plot_tilted_slice">[docs]</a>    <span class="k">def</span> <span class="nf">plot_tilted_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        From line coordinates, extracts the tilted plane containing the line from the 3D volume</span>
<span class="sd">        :param xyz: np.array: points defining a probe trajectory in 3D space (xyz triplets)</span>
<span class="sd">        if more than 2 points are provided will take the best fit</span>
<span class="sd">        :param axis:</span>
<span class="sd">            0: along ml = sagittal-slice</span>
<span class="sd">            1: along ap = coronal-slice</span>
<span class="sd">            2: along dv = horizontal-slice</span>
<span class="sd">        :param volume: &#39;image&#39; or &#39;annotation&#39;</span>
<span class="sd">        :return: matplotlib axis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axis_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;ap (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;dv (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;ml (um)&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">axis_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;ml (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;dv (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;ap (um)&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">axis_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;ml (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;ap (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;dv (um)&#39;</span><span class="p">])</span>

        <span class="n">tslice</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tilted_slice</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cmap</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;bone&#39;</span><span class="p">)</span>
        <span class="c1"># get the transfer function from y-axis to squeezed axis for second axe</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">height</span><span class="p">,</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">depth</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">*</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">tslice</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">sec_ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">secondary_yaxis</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">functions</span><span class="o">=</span><span class="p">(</span>
                                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">axis_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">axis_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">sec_ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">axis_labels</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ax</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_plot_slice</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cmap</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;bone&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

<div class="viewcode-block" id="BrainAtlas.extent"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.extent">[docs]</a>    <span class="k">def</span> <span class="nf">extent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param axis: direction along which the volume is stacked:</span>
<span class="sd">         (2 = z for horizontal slice)</span>
<span class="sd">         (1 = y for coronal slice)</span>
<span class="sd">         (0 = x for sagittal slice)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">ylim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">zlim</span><span class="p">)]</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xlim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">zlim</span><span class="p">)]</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xlim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">ylim</span><span class="p">)]</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="k">return</span> <span class="n">extent</span></div>

<div class="viewcode-block" id="BrainAtlas.slice"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.slice">[docs]</a>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">mapping</span><span class="o">=</span><span class="s2">&quot;Allen&quot;</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get slice through atlas</span>

<span class="sd">        :param coordinate: coordinate to slice in metres, float</span>
<span class="sd">        :param axis: xyz convention:  0 for ml, 1 for ap, 2 for dv</span>
<span class="sd">            - 0: sagittal slice (along ml axis)</span>
<span class="sd">            - 1: coronal slice (along ap axis)</span>
<span class="sd">            - 2: horizontal slice (along dv axis)</span>
<span class="sd">        :param volume:</span>
<span class="sd">            - &#39;image&#39; - allen image volume</span>
<span class="sd">            - &#39;annotation&#39; - allen annotation volume</span>
<span class="sd">            - &#39;surface&#39; - outer surface of mesh</span>
<span class="sd">            - &#39;boundary&#39; - outline of boundaries between all regions</span>
<span class="sd">            - &#39;volume&#39; - custom volume, must pass in volume of shape ba.image.shape as regions_value argument</span>
<span class="sd">            - &#39;value&#39; - custom value per allen region, must pass in array of shape ba.regions.id as regions_value argument</span>
<span class="sd">        :param mode: error mode for out of bounds coordinates</span>
<span class="sd">            -   &#39;raise&#39; raise an error</span>
<span class="sd">            -   &#39;clip&#39; gets the first or last index</span>
<span class="sd">        :param region_values: custom values to plot</span>
<span class="sd">            - if volume=&#39;volume&#39;, region_values must have shape ba.image.shape</span>
<span class="sd">            - if volume=&#39;value&#39;, region_values must have shape ba.regions.id</span>
<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :return: 2d array or 3d RGB numpy int8 array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coordinate</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))[</span><span class="n">axis</span><span class="p">]</span>

        <span class="c1"># np.take is 50 thousand times slower than straight slicing !</span>
        <span class="k">def</span> <span class="nf">_take</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;clip&#39;</span><span class="p">:</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">vol</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">vol</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">vol</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ind</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">_take_remap</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
            <span class="c1"># For the labels, remap the regions indices according to the mapping</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mapping</span><span class="p">(</span><span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">)[</span><span class="n">_take</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_take</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="ow">in</span> <span class="s1">&#39;annotation&#39;</span><span class="p">:</span>
            <span class="n">iregion</span> <span class="o">=</span> <span class="n">_take_remap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">mapping</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label2rgb</span><span class="p">(</span><span class="n">iregion</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">region_values</span><span class="p">[</span><span class="n">_take_remap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">mapping</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">,</span> <span class="s1">&#39;edges&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_surface</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">_take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;boundary&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_boundaries</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">_take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;volume&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coordinate</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">_take</span><span class="p">(</span><span class="n">region_values</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span></div>

<div class="viewcode-block" id="BrainAtlas.plot_cslice"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.plot_cslice">[docs]</a>    <span class="k">def</span> <span class="nf">plot_cslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ap_coordinate</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="s1">&#39;Allen&#39;</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot coronal slice through atlas at given ap_coordinate</span>

<span class="sd">        :param: ap_coordinate (m)</span>
<span class="sd">        :param volume:</span>
<span class="sd">            - &#39;image&#39; - allen image volume</span>
<span class="sd">            - &#39;annotation&#39; - allen annotation volume</span>
<span class="sd">            - &#39;surface&#39; - outer surface of mesh</span>
<span class="sd">            - &#39;boundary&#39; - outline of boundaries between all regions</span>
<span class="sd">            - &#39;volume&#39; - custom volume, must pass in volume of shape ba.image.shape as regions_value argument</span>
<span class="sd">            - &#39;value&#39; - custom value per allen region, must pass in array of shape ba.regions.id as regions_value argument</span>
<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :param region_values: custom values to plot</span>
<span class="sd">            - if volume=&#39;volume&#39;, region_values must have shape ba.image.shape</span>
<span class="sd">            - if volume=&#39;value&#39;, region_values must have shape ba.regions.id</span>
<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :param **kwargs: matplotlib.pyplot.imshow kwarg arguments</span>
<span class="sd">        :return: matplotlib ax object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">ap_coordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="n">region_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_slice</span><span class="p">(</span><span class="n">cslice</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainAtlas.plot_hslice"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.plot_hslice">[docs]</a>    <span class="k">def</span> <span class="nf">plot_hslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dv_coordinate</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="s1">&#39;Allen&#39;</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot horizontal slice through atlas at given dv_coordinate</span>

<span class="sd">        :param: dv_coordinate (m)</span>
<span class="sd">        :param volume:</span>
<span class="sd">            - &#39;image&#39; - allen image volume</span>
<span class="sd">            - &#39;annotation&#39; - allen annotation volume</span>
<span class="sd">            - &#39;surface&#39; - outer surface of mesh</span>
<span class="sd">            - &#39;boundary&#39; - outline of boundaries between all regions</span>
<span class="sd">            - &#39;volume&#39; - custom volume, must pass in volume of shape ba.image.shape as regions_value argument</span>
<span class="sd">            - &#39;value&#39; - custom value per allen region, must pass in array of shape ba.regions.id as regions_value argument</span>
<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :param region_values: custom values to plot</span>
<span class="sd">            - if volume=&#39;volume&#39;, region_values must have shape ba.image.shape</span>
<span class="sd">            - if volume=&#39;value&#39;, region_values must have shape ba.regions.id</span>
<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :param **kwargs: matplotlib.pyplot.imshow kwarg arguments</span>
<span class="sd">        :return: matplotlib ax object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">hslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">dv_coordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="n">region_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_slice</span><span class="p">(</span><span class="n">hslice</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainAtlas.plot_sslice"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.plot_sslice">[docs]</a>    <span class="k">def</span> <span class="nf">plot_sslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ml_coordinate</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="s1">&#39;Allen&#39;</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot sagittal slice through atlas at given ml_coordinate</span>

<span class="sd">        :param: ml_coordinate (m)</span>
<span class="sd">        :param volume:</span>
<span class="sd">            - &#39;image&#39; - allen image volume</span>
<span class="sd">            - &#39;annotation&#39; - allen annotation volume</span>
<span class="sd">            - &#39;surface&#39; - outer surface of mesh</span>
<span class="sd">            - &#39;boundary&#39; - outline of boundaries between all regions</span>
<span class="sd">            - &#39;volume&#39; - custom volume, must pass in volume of shape ba.image.shape as regions_value argument</span>
<span class="sd">            - &#39;value&#39; - custom value per allen region, must pass in array of shape ba.regions.id as regions_value argument</span>
<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :param region_values: custom values to plot</span>
<span class="sd">            - if volume=&#39;volume&#39;, region_values must have shape ba.image.shape</span>
<span class="sd">            - if volume=&#39;value&#39;, region_values must have shape ba.regions.id</span>
<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :param **kwargs: matplotlib.pyplot.imshow kwarg arguments</span>
<span class="sd">        :return: matplotlib ax object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">ml_coordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="n">region_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_slice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">sslice</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainAtlas.plot_top"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.plot_top">[docs]</a>    <span class="k">def</span> <span class="nf">plot_top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;annotation&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="s1">&#39;Allen&#39;</span><span class="p">,</span> <span class="n">region_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot top view of atlas</span>
<span class="sd">        :param volume:</span>
<span class="sd">            - &#39;image&#39; - allen image volume</span>
<span class="sd">            - &#39;annotation&#39; - allen annotation volume</span>
<span class="sd">            - &#39;boundary&#39; - outline of boundaries between all regions</span>
<span class="sd">            - &#39;volume&#39; - custom volume, must pass in volume of shape ba.image.shape as regions_value argument</span>
<span class="sd">            - &#39;value&#39; - custom value per allen region, must pass in array of shape ba.regions.id as regions_value argument</span>

<span class="sd">        :param mapping: mapping to use. Options can be found using ba.regions.mappings.keys()</span>
<span class="sd">        :param region_values:</span>
<span class="sd">        :param ax:</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compute_surface</span><span class="p">()</span>
        <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span>
        <span class="n">iz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">z2i</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_inds</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">regions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mapping</span><span class="p">(</span><span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">inds</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;annotation&#39;</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label2rgb</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">region_values</span><span class="p">[</span><span class="n">regions</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;volume&#39;</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">iz</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">im</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">region_values</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">iz</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;boundary&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_boundaries</span><span class="p">()</span>
            <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_boundary</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_slice</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Trajectory"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Trajectory</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    3D Trajectory (usually for a linear probe). Minimally defined by a vector and a point.</span>
<span class="sd">    instantiate from a best fit from a n by 3 array containing xyz coordinates:</span>
<span class="sd">        trj = Trajectory.fit(xyz)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">point</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

<div class="viewcode-block" id="Trajectory.fit"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory.fit">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="n">xyz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        fits a line to a 3D cloud of points, returns a Trajectory object</span>
<span class="sd">        :param xyz: n by 3 numpy array containing cloud of points</span>
<span class="sd">        :returns: a Trajectory object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Trajectory</span><span class="p">(</span><span class="n">vector</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">xyz_mean</span><span class="p">)[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">point</span><span class="o">=</span><span class="n">xyz_mean</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trajectory.eval_x"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory.eval_x">[docs]</a>    <span class="k">def</span> <span class="nf">eval_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        given an array of x coordinates, returns the xyz array of coordinates along the insertion</span>
<span class="sd">        :param x: n by 1 or numpy array containing x-coordinates</span>
<span class="sd">        :return: n by 3 numpy array containing xyz-coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trajectory.eval_y"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory.eval_y">[docs]</a>    <span class="k">def</span> <span class="nf">eval_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        given an array of y coordinates, returns the xyz array of coordinates along the insertion</span>
<span class="sd">        :param y: n by 1 or numpy array containing y-coordinates</span>
<span class="sd">        :return: n by 3 numpy array containing xyz-coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trajectory.eval_z"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory.eval_z">[docs]</a>    <span class="k">def</span> <span class="nf">eval_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        given an array of z coordinates, returns the xyz array of coordinates along the insertion</span>
<span class="sd">        :param z: n by 1 or numpy array containing z-coordinates</span>
<span class="sd">        :return: n by 3 numpy array containing xyz-coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trajectory.project"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory.project">[docs]</a>    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        projects a point onto the trajectory line</span>
<span class="sd">        :param point: np.array(x, y, z) coordinates</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html</span>
        <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span> <span class="o">/</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trajectory.mindist"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory.mindist">[docs]</a>    <span class="k">def</span> <span class="nf">mindist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the minimum distance to the trajectory line for one or a set of points.</span>
<span class="sd">        If bounds are provided, computes the minimum distance to the segment instead of an</span>
<span class="sd">        infinite line.</span>
<span class="sd">        :param xyz: [..., 3]</span>
<span class="sd">        :param bounds: defaults to None.  np.array [2, 3]: segment boundaries, inf line if None</span>
<span class="sd">        :return: minimum distance [...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">proj</span> <span class="o">-</span> <span class="n">xyz</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># project the boundaries and the points along the traj</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>
            <span class="n">ob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="c1"># for points below and above boundaries, compute cartesian distance to the boundary</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">xyz</span><span class="p">[</span><span class="n">imin</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="n">ob</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">imax</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">xyz</span><span class="p">[</span><span class="n">imax</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="n">ob</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span></div>

    <span class="k">def</span> <span class="nf">_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="c1"># uses symmetric form of 3d line equation to get xyz coordinates given one coordinate</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="c1"># there are cases where it&#39;s impossible to project if a line is // to the axis</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span>

<div class="viewcode-block" id="Trajectory.exit_points"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory.exit_points">[docs]</a>    <span class="k">def</span> <span class="nf">exit_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a Trajectory and a BrainCoordinates object, computes the intersection of the</span>
<span class="sd">        trajectory with the brain coordinates bounding box</span>
<span class="sd">        :param bc: BrainCoordinate objects</span>
<span class="sd">        :return: np.ndarray 2 y 3 corresponding to exit points xyz coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">xlim</span><span class="p">,</span> <span class="n">bc</span><span class="o">.</span><span class="n">ylim</span><span class="p">,</span> <span class="n">bc</span><span class="o">.</span><span class="n">zlim</span><span class="p">]</span>
        <span class="n">epoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_x</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">xlim</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_y</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">ylim</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_z</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">zlim</span><span class="p">)]</span>
        <span class="n">epoints</span> <span class="o">=</span> <span class="n">epoints</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">epoints</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;=</span> <span class="n">epoints</span><span class="p">,</span> <span class="n">epoints</span> <span class="o">&lt;=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">epoints</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="p">:]</span></div></div>


<div class="viewcode-block" id="Insertion"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Insertion">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Insertion</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines an ephys probe insertion in 3D coordinate. IBL conventions.</span>
<span class="sd">    To instantiate, use the static methods:</span>
<span class="sd">    Insertion.from_track</span>
<span class="sd">    Insertion.from_dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">phi</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="Insertion.from_track"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Insertion.from_track">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_track</span><span class="p">(</span><span class="n">xyzs</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param brain_atlas: None. If provided, disregards the z coordinate and locks the insertion</span>
<span class="sd">        point to the z of the brain surface</span>
<span class="sd">        :return: Trajectory object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">brain_atlas</span><span class="p">,</span> <span class="s1">&#39;Input argument brain_atlas must be defined&#39;</span>
        <span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">xyzs</span><span class="p">)</span>
        <span class="c1"># project the deepest point into the vector to get the tip coordinate</span>
        <span class="n">tip</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">xyzs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">xyzs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span> <span class="p">:])</span>
        <span class="c1"># get intersection with the brain surface as an entry point</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="n">Insertion</span><span class="o">.</span><span class="n">get_brain_entry</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">)</span>
        <span class="c1"># convert to spherical system to store the insertion</span>
        <span class="n">depth</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">cart2sph</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">entry</span> <span class="o">-</span> <span class="n">tip</span><span class="p">))</span>
        <span class="n">insertion_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                          <span class="s1">&#39;phi&#39;</span><span class="p">:</span> <span class="n">phi</span><span class="p">,</span> <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="n">theta</span><span class="p">,</span> <span class="s1">&#39;depth&#39;</span><span class="p">:</span> <span class="n">depth</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">Insertion</span><span class="p">(</span><span class="o">**</span><span class="n">insertion_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="Insertion.from_dict"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Insertion.from_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs an Insertion object from the json information stored in probes.description file</span>
<span class="sd">        :param trj: dictionary containing at least the following keys, in um</span>
<span class="sd">           {</span>
<span class="sd">            &#39;x&#39;: 544.0,</span>
<span class="sd">            &#39;y&#39;: 1285.0,</span>
<span class="sd">            &#39;z&#39;: 0.0,</span>
<span class="sd">            &#39;phi&#39;: 0.0,</span>
<span class="sd">            &#39;theta&#39;: 5.0,</span>
<span class="sd">            &#39;depth&#39;: 4501.0</span>
<span class="sd">            }</span>
<span class="sd">        :param brain_atlas: None. If provided, disregards the z coordinate and locks the insertion</span>
<span class="sd">        point to the z of the brain surface</span>
<span class="sd">        :return: Trajectory object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span>
        <span class="k">if</span> <span class="n">brain_atlas</span><span class="p">:</span>
            <span class="n">iy</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">y2i</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">)</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">x2i</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">top</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Insertion</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span>
                         <span class="n">phi</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">],</span> <span class="n">theta</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">],</span> <span class="n">depth</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">,</span>
                         <span class="n">beta</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;beta&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the trajectory object matching insertion coordinates</span>
<span class="sd">        :return: atlas.Trajectory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Trajectory</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tip</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sph2cart</span><span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_surface_intersection</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">):</span>

        <span class="n">brain_atlas</span><span class="o">.</span><span class="n">compute_surface</span><span class="p">()</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">mindist</span><span class="p">(</span><span class="n">brain_atlas</span><span class="o">.</span><span class="n">srf_xyz</span><span class="p">)</span>
        <span class="n">dist_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
        <span class="c1"># In some cases the nearest two intersection points are not the top and bottom of brain</span>
        <span class="c1"># So we find all intersection points that fall within one voxel and take the one with</span>
        <span class="c1"># highest dV to be entry and lowest dV to be exit</span>
        <span class="n">idx_lim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">distance</span><span class="p">[</span><span class="n">dist_sort</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e6</span> <span class="o">&lt;</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">res_um</span><span class="p">)</span>
        <span class="n">dist_lim</span> <span class="o">=</span> <span class="n">dist_sort</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">idx_lim</span><span class="p">]</span>
        <span class="n">z_val</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">srf_xyz</span><span class="p">[</span><span class="n">dist_lim</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">surface</span> <span class="o">==</span> <span class="s1">&#39;top&#39;</span><span class="p">:</span>
            <span class="n">ma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">z_val</span><span class="p">)</span>
            <span class="n">_xyz</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">srf_xyz</span><span class="p">[</span><span class="n">dist_lim</span><span class="p">[</span><span class="n">ma</span><span class="p">],</span> <span class="p">:]</span>
            <span class="n">_ixyz</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">_xyz</span><span class="p">)</span>
            <span class="n">_ixyz</span><span class="p">[</span><span class="n">brain_atlas</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">surface</span> <span class="o">==</span> <span class="s1">&#39;bottom&#39;</span><span class="p">:</span>
            <span class="n">ma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">z_val</span><span class="p">)</span>
            <span class="n">_xyz</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">srf_xyz</span><span class="p">[</span><span class="n">dist_lim</span><span class="p">[</span><span class="n">ma</span><span class="p">],</span> <span class="p">:]</span>
            <span class="n">_ixyz</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">_xyz</span><span class="p">)</span>

        <span class="n">xyz</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">i2xyz</span><span class="p">(</span><span class="n">_ixyz</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">xyz</span>

<div class="viewcode-block" id="Insertion.get_brain_exit"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Insertion.get_brain_exit">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_brain_exit</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a Trajectory and a BrainAtlas object, computes the brain exit coordinate as the</span>
<span class="sd">        intersection of the trajectory and the brain surface (brain_atlas.surface)</span>
<span class="sd">        :param brain_atlas:</span>
<span class="sd">        :return: 3 element array x,y,z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find point where trajectory intersects with bottom of brain</span>
        <span class="k">return</span> <span class="n">Insertion</span><span class="o">.</span><span class="n">_get_surface_intersection</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Insertion.get_brain_entry"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Insertion.get_brain_entry">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_brain_entry</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a Trajectory and a BrainAtlas object, computes the brain entry coordinate as the</span>
<span class="sd">        intersection of the trajectory and the brain surface (brain_atlas.surface)</span>
<span class="sd">        :param brain_atlas:</span>
<span class="sd">        :return: 3 element array x,y,z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find point where trajectory intersects with top of brain</span>
        <span class="k">return</span> <span class="n">Insertion</span><span class="o">.</span><span class="n">_get_surface_intersection</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AllenAtlas"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.AllenAtlas">[docs]</a><span class="k">class</span> <span class="nc">AllenAtlas</span><span class="p">(</span><span class="n">BrainAtlas</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instantiates an atlas.BrainAtlas corresponding to the Allen CCF at the given resolution</span>
<span class="sd">    using the IBL Bregma and coordinate system</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res_um</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">mock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">hist_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param res_um: 10, 25 or 50 um</span>
<span class="sd">        :param scaling: scale factor along ml, ap, dv for squeeze and stretch ([1, 1, 1])</span>
<span class="sd">        :param mock: for testing purpose</span>
<span class="sd">        :param hist_path</span>
<span class="sd">        :return: atlas.BrainAtlas</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">par</span> <span class="o">=</span> <span class="n">one</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">silent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">FLAT_IRON_ATLAS_REL_PATH</span> <span class="o">=</span> <span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">&#39;histology&#39;</span><span class="p">,</span> <span class="s1">&#39;ATLAS&#39;</span><span class="p">,</span> <span class="s1">&#39;Needles&#39;</span><span class="p">,</span> <span class="s1">&#39;Allen&#39;</span><span class="p">)</span>
        <span class="n">LUT_VERSION</span> <span class="o">=</span> <span class="s2">&quot;v01&quot;</span>  <span class="c1"># version 01 is the lateralized version</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="n">BrainRegions</span><span class="p">()</span>
        <span class="n">xyz2dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># this is the c-contiguous ordering</span>
        <span class="n">dims2xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="c1"># we use Bregma as the origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_um</span> <span class="o">=</span> <span class="n">res_um</span>
        <span class="n">ibregma</span> <span class="o">=</span> <span class="p">(</span><span class="n">ALLEN_CCF_LANDMARKS_MLAPDV_UM</span><span class="p">[</span><span class="s1">&#39;bregma&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_um</span><span class="p">)</span>
        <span class="n">dxyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_um</span> <span class="o">*</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">scaling</span>
        <span class="k">if</span> <span class="n">mock</span><span class="p">:</span>
            <span class="n">image</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">528</span><span class="p">,</span> <span class="mi">456</span><span class="p">,</span> <span class="mi">320</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
            <span class="n">label</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">100</span><span class="p">:</span><span class="mi">105</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1327</span>  <span class="c1"># lookup index for retina, id 304325711 (no id 1327)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">path_atlas</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="n">CACHE_DIR</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">FLAT_IRON_ATLAS_REL_PATH</span><span class="p">)</span>
            <span class="n">file_image</span> <span class="o">=</span> <span class="n">hist_path</span> <span class="ow">or</span> <span class="n">path_atlas</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;average_template_</span><span class="si">{</span><span class="n">res_um</span><span class="si">}</span><span class="s1">.nrrd&#39;</span><span class="p">)</span>
            <span class="c1"># get the image volume</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_image</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">_download_atlas_allen</span><span class="p">(</span><span class="n">file_image</span><span class="p">,</span> <span class="n">FLAT_IRON_ATLAS_REL_PATH</span><span class="p">,</span> <span class="n">par</span><span class="p">)</span>
            <span class="c1"># get the remapped label volume</span>
            <span class="n">file_label</span> <span class="o">=</span> <span class="n">path_atlas</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;annotation_</span><span class="si">{</span><span class="n">res_um</span><span class="si">}</span><span class="s1">.nrrd&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_label</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">_download_atlas_allen</span><span class="p">(</span><span class="n">file_label</span><span class="p">,</span> <span class="n">FLAT_IRON_ATLAS_REL_PATH</span><span class="p">,</span> <span class="n">par</span><span class="p">)</span>
            <span class="n">file_label_remap</span> <span class="o">=</span> <span class="n">path_atlas</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;annotation_</span><span class="si">{</span><span class="n">res_um</span><span class="si">}</span><span class="s1">_lut_</span><span class="si">{</span><span class="n">LUT_VERSION</span><span class="si">}</span><span class="s1">.npz&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_label_remap</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_volume</span><span class="p">(</span><span class="n">file_label</span><span class="p">)</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;computing brain atlas annotations lookup table&quot;</span><span class="p">)</span>
                <span class="c1"># lateralize atlas: for this the regions of the left hemisphere have primary</span>
                <span class="c1"># keys opposite to to the normal ones</span>
                <span class="n">lateral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">lateral</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">ibregma</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">lateral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">lateral</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">label</span> <span class="o">*</span> <span class="n">lateral</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">ismember</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">regions</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">),</span> <span class="n">label</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;saving </span><span class="si">{</span><span class="n">file_label_remap</span><span class="si">}</span><span class="s2"> ...&quot;</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">file_label_remap</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
            <span class="c1"># loads the files</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_volume</span><span class="p">(</span><span class="n">file_label_remap</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_volume</span><span class="p">(</span><span class="n">file_image</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">dxyz</span><span class="p">,</span> <span class="n">regions</span><span class="p">,</span> <span class="n">ibregma</span><span class="p">,</span>
                         <span class="n">dims2xyz</span><span class="o">=</span><span class="n">dims2xyz</span><span class="p">,</span> <span class="n">xyz2dims</span><span class="o">=</span><span class="n">xyz2dims</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_volume</span><span class="p">(</span><span class="n">file_volume</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">file_volume</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s1">&#39;.nrrd&#39;</span><span class="p">:</span>
            <span class="n">volume</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nrrd</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">file_volume</span><span class="p">,</span> <span class="n">index_order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>  <span class="c1"># ml, dv, ap</span>
            <span class="c1"># we want the coronal slice to be the most contiguous</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># image[iap, iml, idv]</span>
        <span class="k">elif</span> <span class="n">file_volume</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s1">&#39;.npz&#39;</span><span class="p">:</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_volume</span><span class="p">)[</span><span class="s1">&#39;arr_0&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">volume</span>

<div class="viewcode-block" id="AllenAtlas.xyz2ccf"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.AllenAtlas.xyz2ccf">[docs]</a>    <span class="k">def</span> <span class="nf">xyz2ccf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">ccf_order</span><span class="o">=</span><span class="s1">&#39;mlapdv&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts coordinates to the CCF coordinates, which is assumed to be the cube indices</span>
<span class="sd">        times the spacing.</span>
<span class="sd">        :param xyz: mlapdv coordinates in meters, origin Bregma</span>
<span class="sd">        :param ccf_order: order that you want values returned &#39;mlapdv&#39; (ibl) or &#39;apdvml&#39;</span>
<span class="sd">        (Allen mcc vertices)</span>
<span class="sd">        :return: coordinates in CCF space um, origin is the front left top corner of the data</span>
<span class="sd">        volume, order determined by ccf_order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ordre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ccf_order</span><span class="p">(</span><span class="n">ccf_order</span><span class="p">)</span>
        <span class="n">ccf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_um</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ccf</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ordre</span><span class="p">]</span></div>

<div class="viewcode-block" id="AllenAtlas.ccf2xyz"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.AllenAtlas.ccf2xyz">[docs]</a>    <span class="k">def</span> <span class="nf">ccf2xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ccf</span><span class="p">,</span> <span class="n">ccf_order</span><span class="o">=</span><span class="s1">&#39;mlapdv&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts coordinates from the CCF coordinates, which is assumed to be the cube indices</span>
<span class="sd">        times the spacing.</span>
<span class="sd">        :param ccf coordinates in CCF space in um, origin is the front left top corner of the data</span>
<span class="sd">        volume</span>
<span class="sd">        :param ccf_order: order of ccf coordinates given &#39;mlapdv&#39; (ibl) or &#39;apdvml&#39;</span>
<span class="sd">        (Allen mcc vertices)</span>
<span class="sd">        :return: xyz: mlapdv coordinates in m, origin Bregma</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ordre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ccf_order</span><span class="p">(</span><span class="n">ccf_order</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">i2xyz</span><span class="p">((</span><span class="n">ccf</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ordre</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_um</span><span class="p">)))</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_ccf_order</span><span class="p">(</span><span class="n">ccf_order</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the mapping to go from CCF coordinates order to the brain atlas xyz</span>
<span class="sd">        :param ccf_order: &#39;mlapdv&#39; or &#39;apdvml&#39;</span>
<span class="sd">        :param reverse: defaults to False.</span>
<span class="sd">            If False, returns from CCF to brain atlas</span>
<span class="sd">            If True, returns from brain atlas to CCF</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ccf_order</span> <span class="o">==</span> <span class="s1">&#39;mlapdv&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">ccf_order</span> <span class="o">==</span> <span class="s1">&#39;apdvml&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ccf_order needs to be either &#39;mlapdv&#39; or &#39;apdvml&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="NeedlesAtlas"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.NeedlesAtlas">[docs]</a><span class="k">def</span> <span class="nf">NeedlesAtlas</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instantiates an atlas.BrainAtlas corresponding to the Allen CCF at the given resolution</span>
<span class="sd">    using the IBL Bregma and coordinate system. The Needles atlas defines a stretch along AP</span>
<span class="sd">    axis and a sqeeze along the DV axis.</span>
<span class="sd">    :param res_um: 10, 25 or 50 um</span>
<span class="sd">    :return: atlas.BrainAtlas</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DV_SCALE</span> <span class="o">=</span> <span class="mf">0.952</span>  <span class="c1"># multiplicative factor on DV dimension, determined from MRI-&gt;CCF transform</span>
    <span class="n">AP_SCALE</span> <span class="o">=</span> <span class="mf">1.087</span>  <span class="c1"># multiplicative factor on AP dimension</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;scaling&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">AP_SCALE</span><span class="p">,</span> <span class="n">DV_SCALE</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">AllenAtlas</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_download_atlas_allen</span><span class="p">(</span><span class="n">file_image</span><span class="p">,</span> <span class="n">FLAT_IRON_ATLAS_REL_PATH</span><span class="p">,</span> <span class="n">par</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     2015 Allen Institute for Brain Science. Allen Mouse Brain Atlas (2015)</span>
<span class="sd">    with region annotations (2017).</span>
<span class="sd">    Available from: http://download.alleninstitute.org/informatics-archive/current-release/</span>
<span class="sd">    mouse_ccf/annotation/</span>
<span class="sd">    See Allen Mouse Common Coordinate Framework Technical White Paper for details</span>
<span class="sd">    http://help.brain-map.org/download/attachments/8323525/</span>
<span class="sd">    Mouse_Common_Coordinate_Framework.pdf?version=3&amp;modificationDate=1508178848279&amp;api=v2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">file_image</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">template_url</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;http://download.alleninstitute.org/informatics-archive/&#39;</span>
                    <span class="s1">&#39;current-release/mouse_ccf/average_template&#39;</span><span class="p">)</span>
    <span class="n">annotation_url</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;http://download.alleninstitute.org/informatics-archive/&#39;</span>
                      <span class="s1">&#39;current-release/mouse_ccf/annotation/ccf_2017&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">file_image</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">template_url</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">file_image</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="n">file_image</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;annotation&#39;</span><span class="p">:</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">annotation_url</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">file_image</span><span class="o">.</span><span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unrecognized file image&#39;</span><span class="p">)</span>

    <span class="n">cache_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="n">CACHE_DIR</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">FLAT_IRON_ATLAS_REL_PATH</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">http_download_file</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">cache_dir</span><span class="o">=</span><span class="n">cache_dir</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, International Brain Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>